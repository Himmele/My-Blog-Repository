<html><head><title>NASM Manual</title></head>
<body><h1 align=center>The Netwide Assembler: NASM</h1>

<p align=center><a href="nasmdo10.htm">Previous Chapter</a> |
<a href="nasmdoc0.htm">Contents</a> |
<a href="nasmdoci.htm">Index</a>
<h2><a name="appendix-A">Appendix A: Intel x86 Instruction Reference</a></h2>
<p>This appendix provides a complete list of the machine instructions which
NASM will assemble, and a short description of the function of each one.
<p>It is not intended to be exhaustive documentation on the fine details of
the instructions' function, such as which exceptions they can trigger: for
such documentation, you should go to Intel's web site
<a href="http://www.intel.com"><code><nobr>http://www.intel.com</nobr></code></a>
or AMD's web site
<a href="http://www.amd.com"><code><nobr>http://www.amd.com</nobr></code></a>.
<p>Instead, this appendix is intended primarily to provide documentation on
the way the instructions may be used within NASM. For example, looking up
<code><nobr>LOOP</nobr></code> will tell you that NASM allows
<code><nobr>CX</nobr></code> or <code><nobr>ECX</nobr></code> to be
specified as an optional second argument to the
<code><nobr>LOOP</nobr></code> instruction, to enforce which of the two
possible counter registers should be used if the default is not the one
desired.
<p>The instructions are not quite listed in alphabetical order, since
groups of instructions with similar functions are lumped together in the
same entry. Most of them don't move very far from their alphabetic position
because of this.
<h3><a name="section-A.1">A.1 Key to Operand Specifications</a></h3>
<p>The instruction descriptions in this appendix specify their operands
using the following notation:
<ul>
<li>Registers: <code><nobr>reg8</nobr></code> denotes an 8-bit general
purpose register, <code><nobr>reg16</nobr></code> denotes a 16-bit general
purpose register, and <code><nobr>reg32</nobr></code> a 32-bit one.
<code><nobr>fpureg</nobr></code> denotes one of the eight FPU stack
registers, <code><nobr>mmxreg</nobr></code> denotes one of the eight 64-bit
MMX registers, <code><nobr>xmmreg</nobr></code> denotes one of the 128-bit
XMM/SSE registers and <code><nobr>segreg</nobr></code> denotes a segment
register. In addition, some registers (such as
<code><nobr>AL</nobr></code>, <code><nobr>DX</nobr></code> or
<code><nobr>ECX</nobr></code>) may be specified explicitly.
<li>Immediate operands: <code><nobr>imm</nobr></code> denotes a generic
immediate operand. <code><nobr>imm8</nobr></code>,
<code><nobr>imm16</nobr></code> and <code><nobr>imm32</nobr></code> are
used when the operand is intended to be a specific size. For some of these
instructions, NASM needs an explicit specifier: for example,
<code><nobr>ADD ESP,16</nobr></code> could be interpreted as either
<code><nobr>ADD r/m32,imm32</nobr></code> or
<code><nobr>ADD r/m32,imm8</nobr></code>. NASM chooses the former by
default, and so you must specify <code><nobr>ADD ESP,BYTE 16</nobr></code>
for the latter.
<li>Memory references: <code><nobr>mem</nobr></code> denotes a generic
memory reference; <code><nobr>mem8</nobr></code>,
<code><nobr>mem16</nobr></code>, <code><nobr>mem32</nobr></code>,
<code><nobr>mem64</nobr></code> and <code><nobr>mem80</nobr></code> are
used when the operand needs to be a specific size. Again, a specifier is
needed in some cases: <code><nobr>DEC [address]</nobr></code> is ambiguous
and will be rejected by NASM. You must specify
<code><nobr>DEC BYTE [address]</nobr></code>,
<code><nobr>DEC WORD [address]</nobr></code> or
<code><nobr>DEC DWORD [address]</nobr></code> instead.
<li>Restricted memory references: one form of the
<code><nobr>MOV</nobr></code> instruction allows a memory address to be
specified <em>without</em> allowing the normal range of register
combinations and effective address processing. This is denoted by
<code><nobr>memoffs8</nobr></code>, <code><nobr>memoffs16</nobr></code> and
<code><nobr>memoffs32</nobr></code>.
<li>Register or memory choices: many instructions can accept either a
register <em>or</em> a memory reference as an operand.
<code><nobr>r/m8</nobr></code> is a shorthand for
<code><nobr>reg8/mem8</nobr></code>; similarly
<code><nobr>r/m16</nobr></code> and <code><nobr>r/m32</nobr></code>.
<code><nobr>r/m64</nobr></code> is MMX-related, and is a shorthand for
<code><nobr>mmxreg/mem64</nobr></code>. <code><nobr>r/m128</nobr></code> is
for SSE instructions, and is short for
<code><nobr>xmmreg/mem128</nobr></code>.
</ul>
<h3><a name="section-A.2">A.2 Key to Opcode Descriptions</a></h3>
<p>This appendix also provides the opcodes which NASM will generate for
each form of each instruction. The opcodes are listed in the following way:
<ul>
<li>A hex number, such as <code><nobr>3F</nobr></code>, indicates a fixed
byte containing that number.
<li>A hex number followed by <code><nobr>+r</nobr></code>, such as
<code><nobr>C8+r</nobr></code>, indicates that one of the operands to the
instruction is a register, and the `register value' of that register should
be added to the hex number to produce the generated byte. For example, EDX
has register value 2, so the code <code><nobr>C8+r</nobr></code>, when the
register operand is EDX, generates the hex byte
<code><nobr>CA</nobr></code>. Register values for specific registers are
given in <a href="#section-A.2.1">section A.2.1</a>.
<li>A hex number followed by <code><nobr>+cc</nobr></code>, such as
<code><nobr>40+cc</nobr></code>, indicates that the instruction name has a
condition code suffix, and the numeric representation of the condition code
should be added to the hex number to produce the generated byte. For
example, the code <code><nobr>40+cc</nobr></code>, when the instruction
contains the <code><nobr>NE</nobr></code> condition, generates the hex byte
<code><nobr>45</nobr></code>. Condition codes and their numeric
representations are given in <a href="#section-A.2.2">section A.2.2</a>.
<li>A slash followed by a digit, such as <code><nobr>/2</nobr></code>,
indicates that one of the operands to the instruction is a memory address
or register (denoted <code><nobr>mem</nobr></code> or
<code><nobr>r/m</nobr></code>, with an optional size). This is to be
encoded as an effective address, with a ModR/M byte, an optional SIB byte,
and an optional displacement, and the spare (register) field of the ModR/M
byte should be the digit given (which will be from 0 to 7, so it fits in
three bits). The encoding of effective addresses is given in
<a href="#section-A.2.3">section A.2.3</a>.
<li>The code <code><nobr>/r</nobr></code> combines the above two: it
indicates that one of the operands is a memory address or
<code><nobr>r/m</nobr></code>, and another is a register, and that an
effective address should be generated with the spare (register) field in
the ModR/M byte being equal to the `register value' of the register
operand. The encoding of effective addresses is given in
<a href="#section-A.2.3">section A.2.3</a>; register values are given in
<a href="#section-A.2.1">section A.2.1</a>.
<li>The codes <code><nobr>ib</nobr></code>, <code><nobr>iw</nobr></code>
and <code><nobr>id</nobr></code> indicate that one of the operands to the
instruction is an immediate value, and that this is to be encoded as a
byte, little-endian word or little-endian doubleword respectively.
<li>The codes <code><nobr>rb</nobr></code>, <code><nobr>rw</nobr></code>
and <code><nobr>rd</nobr></code> indicate that one of the operands to the
instruction is an immediate value, and that the <em>difference</em> between
this value and the address of the end of the instruction is to be encoded
as a byte, word or doubleword respectively. Where the form
<code><nobr>rw/rd</nobr></code> appears, it indicates that either
<code><nobr>rw</nobr></code> or <code><nobr>rd</nobr></code> should be used
according to whether assembly is being performed in
<code><nobr>BITS 16</nobr></code> or <code><nobr>BITS 32</nobr></code>
state respectively.
<li>The codes <code><nobr>ow</nobr></code> and <code><nobr>od</nobr></code>
indicate that one of the operands to the instruction is a reference to the
contents of a memory address specified as an immediate value: this encoding
is used in some forms of the <code><nobr>MOV</nobr></code> instruction in
place of the standard effective-address mechanism. The displacement is
encoded as a word or doubleword. Again, <code><nobr>ow/od</nobr></code>
denotes that <code><nobr>ow</nobr></code> or <code><nobr>od</nobr></code>
should be chosen according to the <code><nobr>BITS</nobr></code> setting.
<li>The codes <code><nobr>o16</nobr></code> and
<code><nobr>o32</nobr></code> indicate that the given form of the
instruction should be assembled with operand size 16 or 32 bits. In other
words, <code><nobr>o16</nobr></code> indicates a
<code><nobr>66</nobr></code> prefix in <code><nobr>BITS 32</nobr></code>
state, but generates no code in <code><nobr>BITS 16</nobr></code> state;
and <code><nobr>o32</nobr></code> indicates a <code><nobr>66</nobr></code>
prefix in <code><nobr>BITS 16</nobr></code> state but generates nothing in
<code><nobr>BITS 32</nobr></code>.
<li>The codes <code><nobr>a16</nobr></code> and
<code><nobr>a32</nobr></code>, similarly to <code><nobr>o16</nobr></code>
and <code><nobr>o32</nobr></code>, indicate the address size of the given
form of the instruction. Where this does not match the
<code><nobr>BITS</nobr></code> setting, a <code><nobr>67</nobr></code>
prefix is required.
</ul>
<h4><a name="section-A.2.1">A.2.1 Register Values</a></h4>
<p>Where an instruction requires a register value, it is already implicit
in the encoding of the rest of the instruction what type of register is
intended: an 8-bit general-purpose register, a segment register, a debug
register, an MMX register, or whatever. Therefore there is no problem with
registers of different types sharing an encoding value.
<p>The encodings for the various classes of register are:
<ul>
<li>8-bit general registers: <code><nobr>AL</nobr></code> is 0,
<code><nobr>CL</nobr></code> is 1, <code><nobr>DL</nobr></code> is 2,
<code><nobr>BL</nobr></code> is 3, <code><nobr>AH</nobr></code> is 4,
<code><nobr>CH</nobr></code> is 5, <code><nobr>DH</nobr></code> is 6, and
<code><nobr>BH</nobr></code> is 7.
<li>16-bit general registers: <code><nobr>AX</nobr></code> is 0,
<code><nobr>CX</nobr></code> is 1, <code><nobr>DX</nobr></code> is 2,
<code><nobr>BX</nobr></code> is 3, <code><nobr>SP</nobr></code> is 4,
<code><nobr>BP</nobr></code> is 5, <code><nobr>SI</nobr></code> is 6, and
<code><nobr>DI</nobr></code> is 7.
<li>32-bit general registers: <code><nobr>EAX</nobr></code> is 0,
<code><nobr>ECX</nobr></code> is 1, <code><nobr>EDX</nobr></code> is 2,
<code><nobr>EBX</nobr></code> is 3, <code><nobr>ESP</nobr></code> is 4,
<code><nobr>EBP</nobr></code> is 5, <code><nobr>ESI</nobr></code> is 6, and
<code><nobr>EDI</nobr></code> is 7.
<li>Segment registers: <code><nobr>ES</nobr></code> is 0,
<code><nobr>CS</nobr></code> is 1, <code><nobr>SS</nobr></code> is 2,
<code><nobr>DS</nobr></code> is 3, <code><nobr>FS</nobr></code> is 4, and
<code><nobr>GS</nobr></code> is 5.
<li>{Floating-point registers}: <code><nobr>ST0</nobr></code> is 0,
<code><nobr>ST1</nobr></code> is 1, <code><nobr>ST2</nobr></code> is 2,
<code><nobr>ST3</nobr></code> is 3, <code><nobr>ST4</nobr></code> is 4,
<code><nobr>ST5</nobr></code> is 5, <code><nobr>ST6</nobr></code> is 6, and
<code><nobr>ST7</nobr></code> is 7.
<li>64-bit MMX registers: <code><nobr>MM0</nobr></code> is 0,
<code><nobr>MM1</nobr></code> is 1, <code><nobr>MM2</nobr></code> is 2,
<code><nobr>MM3</nobr></code> is 3, <code><nobr>MM4</nobr></code> is 4,
<code><nobr>MM5</nobr></code> is 5, <code><nobr>MM6</nobr></code> is 6, and
<code><nobr>MM7</nobr></code> is 7.
<li>Control registers: <code><nobr>CR0</nobr></code> is 0,
<code><nobr>CR2</nobr></code> is 2, <code><nobr>CR3</nobr></code> is 3, and
<code><nobr>CR4</nobr></code> is 4.
<li>Debug registers: <code><nobr>DR0</nobr></code> is 0,
<code><nobr>DR1</nobr></code> is 1, <code><nobr>DR2</nobr></code> is 2,
<code><nobr>DR3</nobr></code> is 3, <code><nobr>DR6</nobr></code> is 6, and
<code><nobr>DR7</nobr></code> is 7.
<li>Test registers: <code><nobr>TR3</nobr></code> is 3,
<code><nobr>TR4</nobr></code> is 4, <code><nobr>TR5</nobr></code> is 5,
<code><nobr>TR6</nobr></code> is 6, and <code><nobr>TR7</nobr></code> is 7.
</ul>
<p>(Note that wherever a register name contains a number, that number is
also the register value for that register.)
<h4><a name="section-A.2.2">A.2.2 Condition Codes</a></h4>
<p>The available condition codes are given here, along with their numeric
representations as part of opcodes. Many of these condition codes have
synonyms, so several will be listed at a time.
<p>In the following descriptions, the word `either', when applied to two
possible trigger conditions, is used to mean `either or both'. If `either
but not both' is meant, the phrase `exactly one of' is used.
<ul>
<li><code><nobr>O</nobr></code> is 0 (trigger if the overflow flag is set);
<code><nobr>NO</nobr></code> is 1.
<li><code><nobr>B</nobr></code>, <code><nobr>C</nobr></code> and
<code><nobr>NAE</nobr></code> are 2 (trigger if the carry flag is set);
<code><nobr>AE</nobr></code>, <code><nobr>NB</nobr></code> and
<code><nobr>NC</nobr></code> are 3.
<li><code><nobr>E</nobr></code> and <code><nobr>Z</nobr></code> are 4
(trigger if the zero flag is set); <code><nobr>NE</nobr></code> and
<code><nobr>NZ</nobr></code> are 5.
<li><code><nobr>BE</nobr></code> and <code><nobr>NA</nobr></code> are 6
(trigger if either of the carry or zero flags is set);
<code><nobr>A</nobr></code> and <code><nobr>NBE</nobr></code> are 7.
<li><code><nobr>S</nobr></code> is 8 (trigger if the sign flag is set);
<code><nobr>NS</nobr></code> is 9.
<li><code><nobr>P</nobr></code> and <code><nobr>PE</nobr></code> are 10
(trigger if the parity flag is set); <code><nobr>NP</nobr></code> and
<code><nobr>PO</nobr></code> are 11.
<li><code><nobr>L</nobr></code> and <code><nobr>NGE</nobr></code> are 12
(trigger if exactly one of the sign and overflow flags is set);
<code><nobr>GE</nobr></code> and <code><nobr>NL</nobr></code> are 13.
<li><code><nobr>LE</nobr></code> and <code><nobr>NG</nobr></code> are 14
(trigger if either the zero flag is set, or exactly one of the sign and
overflow flags is set); <code><nobr>G</nobr></code> and
<code><nobr>NLE</nobr></code> are 15.
</ul>
<p>Note that in all cases, the sense of a condition code may be reversed by
changing the low bit of the numeric representation.
<h4><a name="section-A.2.3">A.2.3 Effective Address Encoding: ModR/M and SIB</a></h4>
<p>An effective address is encoded in up to three parts: a ModR/M byte, an
optional SIB byte, and an optional byte, word or doubleword displacement
field.
<p>The ModR/M byte consists of three fields: the
<code><nobr>mod</nobr></code> field, ranging from 0 to 3, in the upper two
bits of the byte, the <code><nobr>r/m</nobr></code> field, ranging from 0
to 7, in the lower three bits, and the spare (register) field in the middle
(bit 3 to bit 5). The spare field is not relevant to the effective address
being encoded, and either contains an extension to the instruction opcode
or the register value of another operand.
<p>The ModR/M system can be used to encode a direct register reference
rather than a memory access. This is always done by setting the
<code><nobr>mod</nobr></code> field to 3 and the
<code><nobr>r/m</nobr></code> field to the register value of the register
in question (it must be a general-purpose register, and the size of the
register must already be implicit in the encoding of the rest of the
instruction). In this case, the SIB byte and displacement field are both
absent.
<p>In 16-bit addressing mode (either <code><nobr>BITS 16</nobr></code> with
no <code><nobr>67</nobr></code> prefix, or
<code><nobr>BITS 32</nobr></code> with a <code><nobr>67</nobr></code>
prefix), the SIB byte is never used. The general rules for
<code><nobr>mod</nobr></code> and <code><nobr>r/m</nobr></code> (there is
an exception, given below) are:
<ul>
<li>The <code><nobr>mod</nobr></code> field gives the length of the
displacement field: 0 means no displacement, 1 means one byte, and 2 means
two bytes.
<li>The <code><nobr>r/m</nobr></code> field encodes the combination of
registers to be added to the displacement to give the accessed address: 0
means <code><nobr>BX+SI</nobr></code>, 1 means
<code><nobr>BX+DI</nobr></code>, 2 means <code><nobr>BP+SI</nobr></code>, 3
means <code><nobr>BP+DI</nobr></code>, 4 means <code><nobr>SI</nobr></code>
only, 5 means <code><nobr>DI</nobr></code> only, 6 means
<code><nobr>BP</nobr></code> only, and 7 means <code><nobr>BX</nobr></code>
only.
</ul>
<p>However, there is a special case:
<ul>
<li>If <code><nobr>mod</nobr></code> is 0 and <code><nobr>r/m</nobr></code>
is 6, the effective address encoded is not <code><nobr>[BP]</nobr></code>
as the above rules would suggest, but instead
<code><nobr>[disp16]</nobr></code>: the displacement field is present and
is two bytes long, and no registers are added to the displacement.
</ul>
<p>Therefore the effective address <code><nobr>[BP]</nobr></code> cannot be
encoded as efficiently as <code><nobr>[BX]</nobr></code>; so if you code
<code><nobr>[BP]</nobr></code> in a program, NASM adds a notional 8-bit
zero displacement, and sets <code><nobr>mod</nobr></code> to 1,
<code><nobr>r/m</nobr></code> to 6, and the one-byte displacement field to
0.
<p>In 32-bit addressing mode (either <code><nobr>BITS 16</nobr></code> with
a <code><nobr>67</nobr></code> prefix, or <code><nobr>BITS 32</nobr></code>
with no <code><nobr>67</nobr></code> prefix) the general rules (again,
there are exceptions) for <code><nobr>mod</nobr></code> and
<code><nobr>r/m</nobr></code> are:
<ul>
<li>The <code><nobr>mod</nobr></code> field gives the length of the
displacement field: 0 means no displacement, 1 means one byte, and 2 means
four bytes.
<li>If only one register is to be added to the displacement, and it is not
<code><nobr>ESP</nobr></code>, the <code><nobr>r/m</nobr></code> field
gives its register value, and the SIB byte is absent. If the
<code><nobr>r/m</nobr></code> field is 4 (which would encode
<code><nobr>ESP</nobr></code>), the SIB byte is present and gives the
combination and scaling of registers to be added to the displacement.
</ul>
<p>If the SIB byte is present, it describes the combination of registers
(an optional base register, and an optional index register scaled by
multiplication by 1, 2, 4 or 8) to be added to the displacement. The SIB
byte is divided into the <code><nobr>scale</nobr></code> field, in the top
two bits, the <code><nobr>index</nobr></code> field in the next three, and
the <code><nobr>base</nobr></code> field in the bottom three. The general
rules are:
<ul>
<li>The <code><nobr>base</nobr></code> field encodes the register value of
the base register.
<li>The <code><nobr>index</nobr></code> field encodes the register value of
the index register, unless it is 4, in which case no index register is used
(so <code><nobr>ESP</nobr></code> cannot be used as an index register).
<li>The <code><nobr>scale</nobr></code> field encodes the multiplier by
which the index register is scaled before adding it to the base and
displacement: 0 encodes a multiplier of 1, 1 encodes 2, 2 encodes 4 and 3
encodes 8.
</ul>
<p>The exceptions to the 32-bit encoding rules are:
<ul>
<li>If <code><nobr>mod</nobr></code> is 0 and <code><nobr>r/m</nobr></code>
is 5, the effective address encoded is not <code><nobr>[EBP]</nobr></code>
as the above rules would suggest, but instead
<code><nobr>[disp32]</nobr></code>: the displacement field is present and
is four bytes long, and no registers are added to the displacement.
<li>If <code><nobr>mod</nobr></code> is 0, <code><nobr>r/m</nobr></code> is
4 (meaning the SIB byte is present) and <code><nobr>base</nobr></code> is
4, the effective address encoded is not
<code><nobr>[EBP+index]</nobr></code> as the above rules would suggest, but
instead <code><nobr>[disp32+index]</nobr></code>: the displacement field is
present and is four bytes long, and there is no base register (but the
index register is still processed in the normal way).
</ul>
<h3><a name="section-A.3">A.3 Key to Instruction Flags</a></h3>
<p>Given along with each instruction in this appendix is a set of flags,
denoting the type of the instruction. The types are as follows:
<ul>
<li><code><nobr>8086</nobr></code>, <code><nobr>186</nobr></code>,
<code><nobr>286</nobr></code>, <code><nobr>386</nobr></code>,
<code><nobr>486</nobr></code>, <code><nobr>PENT</nobr></code> and
<code><nobr>P6</nobr></code> denote the lowest processor type that supports
the instruction. Most instructions run on all processors above the given
type; those that do not are documented. The Pentium II contains no
additional instructions beyond the P6 (Pentium Pro); from the point of view
of its instruction set, it can be thought of as a P6 with MMX capability.
<li><code><nobr>CYRIX</nobr></code> indicates that the instruction is
specific to Cyrix processors, for example the extra MMX instructions in the
Cyrix extended MMX instruction set.
<li><code><nobr>FPU</nobr></code> indicates that the instruction is a
floating-point one, and will only run on machines with a coprocessor
(automatically including 486DX, Pentium and above).
<li><code><nobr>MMX</nobr></code> indicates that the instruction is an MMX
one, and will run on MMX-capable Pentium processors and the Pentium II.
<li><code><nobr>PRIV</nobr></code> indicates that the instruction is a
protected-mode management instruction. Many of these may only be used in
protected mode, or only at privilege level zero.
<li><code><nobr>UNDOC</nobr></code> indicates that the instruction is an
undocumented one, and not part of the official Intel Architecture; it may
or may not be supported on any given machine.
</ul>
<h3><a name="section-A.4">A.4 <code><nobr>AAA</nobr></code>, <code><nobr>AAS</nobr></code>, <code><nobr>AAM</nobr></code>, <code><nobr>AAD</nobr></code>: ASCII Adjustments</a></h3>
<p><pre>
AAA                           ; 37                   [8086]
</pre>
<p><pre>
AAS                           ; 3F                   [8086]
</pre>
<p><pre>
AAD                           ; D5 0A                [8086] 
AAD imm                       ; D5 ib                [8086]
</pre>
<p><pre>
AAM                           ; D4 0A                [8086] 
AAM imm                       ; D4 ib                [8086]
</pre>
<p>These instructions are used in conjunction with the add, subtract,
multiply and divide instructions to perform binary-coded decimal arithmetic
in <em>unpacked</em> (one BCD digit per byte - easy to translate to and
from ASCII, hence the instruction names) form. There are also packed BCD
instructions <code><nobr>DAA</nobr></code> and
<code><nobr>DAS</nobr></code>: see <a href="#section-A.34">section
A.34</a>.
<p><code><nobr>AAA</nobr></code> should be used after a one-byte
<code><nobr>ADD</nobr></code> instruction whose destination was the
<code><nobr>AL</nobr></code> register: by means of examining the value in
the low nibble of <code><nobr>AL</nobr></code> and also the auxiliary carry
flag <code><nobr>AF</nobr></code>, it determines whether the addition has
overflowed, and adjusts it (and sets the carry flag) if so. You can add
long BCD strings together by doing
<code><nobr>ADD</nobr></code>/<code><nobr>AAA</nobr></code> on the low
digits, then doing
<code><nobr>ADC</nobr></code>/<code><nobr>AAA</nobr></code> on each
subsequent digit.
<p><code><nobr>AAS</nobr></code> works similarly to
<code><nobr>AAA</nobr></code>, but is for use after
<code><nobr>SUB</nobr></code> instructions rather than
<code><nobr>ADD</nobr></code>.
<p><code><nobr>AAM</nobr></code> is for use after you have multiplied two
decimal digits together and left the result in
<code><nobr>AL</nobr></code>: it divides <code><nobr>AL</nobr></code> by
ten and stores the quotient in <code><nobr>AH</nobr></code>, leaving the
remainder in <code><nobr>AL</nobr></code>. The divisor 10 can be changed by
specifying an operand to the instruction: a particularly handy use of this
is <code><nobr>AAM 16</nobr></code>, causing the two nibbles in
<code><nobr>AL</nobr></code> to be separated into
<code><nobr>AH</nobr></code> and <code><nobr>AL</nobr></code>.
<p><code><nobr>AAD</nobr></code> performs the inverse operation to
<code><nobr>AAM</nobr></code>: it multiplies <code><nobr>AH</nobr></code>
by ten, adds it to <code><nobr>AL</nobr></code>, and sets
<code><nobr>AH</nobr></code> to zero. Again, the multiplier 10 can be
changed.
<h3><a name="section-A.5">A.5 <code><nobr>ADC</nobr></code>: Add with Carry</a></h3>
<p><pre>
ADC r/m8,reg8                 ; 10 /r                [8086] 
ADC r/m16,reg16               ; o16 11 /r            [8086] 
ADC r/m32,reg32               ; o32 11 /r            [386]
</pre>
<p><pre>
ADC reg8,r/m8                 ; 12 /r                [8086] 
ADC reg16,r/m16               ; o16 13 /r            [8086] 
ADC reg32,r/m32               ; o32 13 /r            [386]
</pre>
<p><pre>
ADC r/m8,imm8                 ; 80 /2 ib             [8086] 
ADC r/m16,imm16               ; o16 81 /2 iw         [8086] 
ADC r/m32,imm32               ; o32 81 /2 id         [386]
</pre>
<p><pre>
ADC r/m16,imm8                ; o16 83 /2 ib         [8086] 
ADC r/m32,imm8                ; o32 83 /2 ib         [386]
</pre>
<p><pre>
ADC AL,imm8                   ; 14 ib                [8086] 
ADC AX,imm16                  ; o16 15 iw            [8086] 
ADC EAX,imm32                 ; o32 15 id            [386]
</pre>
<p><code><nobr>ADC</nobr></code> performs integer addition: it adds its two
operands together, plus the value of the carry flag, and leaves the result
in its destination (first) operand. The flags are set according to the
result of the operation: in particular, the carry flag is affected and can
be used by a subsequent <code><nobr>ADC</nobr></code> instruction.
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<p>To add two numbers without also adding the contents of the carry flag,
use <code><nobr>ADD</nobr></code> (<a href="#section-A.6">section A.6</a>).
<h3><a name="section-A.6">A.6 <code><nobr>ADD</nobr></code>: Add Integers</a></h3>
<p><pre>
ADD r/m8,reg8                 ; 00 /r                [8086] 
ADD r/m16,reg16               ; o16 01 /r            [8086] 
ADD r/m32,reg32               ; o32 01 /r            [386]
</pre>
<p><pre>
ADD reg8,r/m8                 ; 02 /r                [8086] 
ADD reg16,r/m16               ; o16 03 /r            [8086] 
ADD reg32,r/m32               ; o32 03 /r            [386]
</pre>
<p><pre>
ADD r/m8,imm8                 ; 80 /0 ib             [8086] 
ADD r/m16,imm16               ; o16 81 /0 iw         [8086] 
ADD r/m32,imm32               ; o32 81 /0 id         [386]
</pre>
<p><pre>
ADD r/m16,imm8                ; o16 83 /0 ib         [8086] 
ADD r/m32,imm8                ; o32 83 /0 ib         [386]
</pre>
<p><pre>
ADD AL,imm8                   ; 04 ib                [8086] 
ADD AX,imm16                  ; o16 05 iw            [8086] 
ADD EAX,imm32                 ; o32 05 id            [386]
</pre>
<p><code><nobr>ADD</nobr></code> performs integer addition: it adds its two
operands together, and leaves the result in its destination (first)
operand. The flags are set according to the result of the operation: in
particular, the carry flag is affected and can be used by a subsequent
<code><nobr>ADC</nobr></code> instruction (<a href="#section-A.5">section
A.5</a>).
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<h3><a name="section-A.7">A.7 <code><nobr>ADDPS</nobr></code>: SSE Packed Single-FP ADD</a></h3>
<p><pre>
ADDPS xmmreg,r/m128           ; 0F 58 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>ADDPS</nobr></code> treats both operands as vectors of four
32-bit floating-point numbers and adds each number in the source operand to
the corresponding number in the destination register.
<h3><a name="section-A.8">A.8 <code><nobr>ADDSS</nobr></code>: SSE Scalar Single-FP ADD</a></h3>
<p><pre>
ADDSS xmmreg,xmmreg/mem32     ; F3 0F 58 /r          [KATMAI,SSE]
</pre>
<p><code><nobr>ADDSS</nobr></code> adds the 32-bit floating-point number in
the lowest 4 bytes of the source operand to the floating-point number in
the lowest quarter of the destination register.
<h3><a name="section-A.9">A.9 <code><nobr>AND</nobr></code>: Bitwise AND</a></h3>
<p><pre>
AND r/m8,reg8                 ; 20 /r                [8086] 
AND r/m16,reg16               ; o16 21 /r            [8086] 
AND r/m32,reg32               ; o32 21 /r            [386]
</pre>
<p><pre>
AND reg8,r/m8                 ; 22 /r                [8086] 
AND reg16,r/m16               ; o16 23 /r            [8086] 
AND reg32,r/m32               ; o32 23 /r            [386]
</pre>
<p><pre>
AND r/m8,imm8                 ; 80 /4 ib             [8086] 
AND r/m16,imm16               ; o16 81 /4 iw         [8086] 
AND r/m32,imm32               ; o32 81 /4 id         [386]
</pre>
<p><pre>
AND r/m16,imm8                ; o16 83 /4 ib         [8086] 
AND r/m32,imm8                ; o32 83 /4 ib         [386]
</pre>
<p><pre>
AND AL,imm8                   ; 24 ib                [8086] 
AND AX,imm16                  ; o16 25 iw            [8086] 
AND EAX,imm32                 ; o32 25 id            [386]
</pre>
<p><code><nobr>AND</nobr></code> performs a bitwise AND operation between
its two operands (i.e. each bit of the result is 1 if and only if the
corresponding bits of the two inputs were both 1), and stores the result in
the destination (first) operand.
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<p>The MMX instruction <code><nobr>PAND</nobr></code> (see
<a href="#section-A.153">section A.153</a>) performs the same operation on
the 64-bit MMX registers.
<h3><a name="section-A.10">A.10 <code><nobr>ANDNPS</nobr></code>: SSE Bitwise Logical AND NOT</a></h3>
<p><pre>
ANDNPS xmmreg,r/m128          ; 0F 55 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>ANDNPS</nobr></code> performs a bitwise AND operation on the
source operand and the complement of the destination register, and stores
the result in the destination register.
<h3><a name="section-A.11">A.11 <code><nobr>ANDPS</nobr></code>: SSE Bitwise Logical AND</a></h3>
<p><pre>
ANDPS xmmreg,r/m128           ; 0F 54 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>ANDPS</nobr></code> performs a bitwise AND operation on the
source operand and the destination register, and stores the result in the
destination register.
<h3><a name="section-A.12">A.12 <code><nobr>ARPL</nobr></code>: Adjust RPL Field of Selector</a></h3>
<p><pre>
ARPL r/m16,reg16              ; 63 /r                [286,PRIV]
</pre>
<p><code><nobr>ARPL</nobr></code> expects its two word operands to be
segment selectors. It adjusts the RPL (requested privilege level - stored
in the bottom two bits of the selector) field of the destination (first)
operand to ensure that it is no less (i.e. no more privileged than) the RPL
field of the source operand. The zero flag is set if and only if a change
had to be made.
<h3><a name="section-A.13">A.13 <code><nobr>BOUND</nobr></code>: Check Array Index against Bounds</a></h3>
<p><pre>
BOUND reg16,mem               ; o16 62 /r            [186] 
BOUND reg32,mem               ; o32 62 /r            [386]
</pre>
<p><code><nobr>BOUND</nobr></code> expects its second operand to point to
an area of memory containing two signed values of the same size as its
first operand (i.e. two words for the 16-bit form; two doublewords for the
32-bit form). It performs two signed comparisons: if the value in the
register passed as its first operand is less than the first of the
in-memory values, or is greater than or equal to the second, it throws a BR
exception. Otherwise, it does nothing.
<h3><a name="section-A.14">A.14 <code><nobr>BSF</nobr></code>, <code><nobr>BSR</nobr></code>: Bit Scan</a></h3>
<p><pre>
BSF reg16,r/m16               ; o16 0F BC /r         [386] 
BSF reg32,r/m32               ; o32 0F BC /r         [386]
</pre>
<p><pre>
BSR reg16,r/m16               ; o16 0F BD /r         [386] 
BSR reg32,r/m32               ; o32 0F BD /r         [386]
</pre>
<p><code><nobr>BSF</nobr></code> searches for a set bit in its source
(second) operand, starting from the bottom, and if it finds one, stores the
index in its destination (first) operand. If no set bit is found, the
contents of the destination operand are undefined.
<p><code><nobr>BSR</nobr></code> performs the same function, but searches
from the top instead, so it finds the most significant set bit.
<p>Bit indices are from 0 (least significant) to 15 or 31 (most
significant).
<h3><a name="section-A.15">A.15 <code><nobr>BSWAP</nobr></code>: Byte Swap</a></h3>
<p><pre>
BSWAP reg32                   ; o32 0F C8+r          [486]
</pre>
<p><code><nobr>BSWAP</nobr></code> swaps the order of the four bytes of a
32-bit register: bits 0-7 exchange places with bits 24-31, and bits 8-15
swap with bits 16-23. There is no explicit 16-bit equivalent: to byte-swap
<code><nobr>AX</nobr></code>, <code><nobr>BX</nobr></code>,
<code><nobr>CX</nobr></code> or <code><nobr>DX</nobr></code>,
<code><nobr>XCHG</nobr></code> can be used.
<h3><a name="section-A.16">A.16 <code><nobr>BT</nobr></code>, <code><nobr>BTC</nobr></code>, <code><nobr>BTR</nobr></code>, <code><nobr>BTS</nobr></code>: Bit Test</a></h3>
<p><pre>
BT r/m16,reg16                ; o16 0F A3 /r         [386] 
BT r/m32,reg32                ; o32 0F A3 /r         [386] 
BT r/m16,imm8                 ; o16 0F BA /4 ib      [386] 
BT r/m32,imm8                 ; o32 0F BA /4 ib      [386]
</pre>
<p><pre>
BTC r/m16,reg16               ; o16 0F BB /r         [386] 
BTC r/m32,reg32               ; o32 0F BB /r         [386] 
BTC r/m16,imm8                ; o16 0F BA /7 ib      [386] 
BTC r/m32,imm8                ; o32 0F BA /7 ib      [386]
</pre>
<p><pre>
BTR r/m16,reg16               ; o16 0F B3 /r         [386] 
BTR r/m32,reg32               ; o32 0F B3 /r         [386] 
BTR r/m16,imm8                ; o16 0F BA /6 ib      [386] 
BTR r/m32,imm8                ; o32 0F BA /6 ib      [386]
</pre>
<p><pre>
BTS r/m16,reg16               ; o16 0F AB /r         [386] 
BTS r/m32,reg32               ; o32 0F AB /r         [386] 
BTS r/m16,imm                 ; o16 0F BA /5 ib      [386] 
BTS r/m32,imm                 ; o32 0F BA /5 ib      [386]
</pre>
<p>These instructions all test one bit of their first operand, whose index
is given by the second operand, and store the value of that bit into the
carry flag. Bit indices are from 0 (least significant) to 15 or 31 (most
significant).
<p>In addition to storing the original value of the bit into the carry
flag, <code><nobr>BTR</nobr></code> also resets (clears) the bit in the
operand itself. <code><nobr>BTS</nobr></code> sets the bit, and
<code><nobr>BTC</nobr></code> complements the bit.
<code><nobr>BT</nobr></code> does not modify its operands.
<p>The bit offset should be no greater than the size of the operand.
<h3><a name="section-A.17">A.17 <code><nobr>CALL</nobr></code>: Call Subroutine</a></h3>
<p><pre>
CALL imm                      ; E8 rw/rd             [8086] 
CALL imm:imm16                ; o16 9A iw iw         [8086] 
CALL imm:imm32                ; o32 9A id iw         [386] 
CALL FAR mem16                ; o16 FF /3            [8086] 
CALL FAR mem32                ; o32 FF /3            [386] 
CALL r/m16                    ; o16 FF /2            [8086] 
CALL r/m32                    ; o32 FF /2            [386]
</pre>
<p><code><nobr>CALL</nobr></code> calls a subroutine, by means of pushing
the current instruction pointer (<code><nobr>IP</nobr></code>) and
optionally <code><nobr>CS</nobr></code> as well on the stack, and then
jumping to a given address.
<p><code><nobr>CS</nobr></code> is pushed as well as
<code><nobr>IP</nobr></code> if and only if the call is a far call, i.e. a
destination segment address is specified in the instruction. The forms
involving two colon-separated arguments are far calls; so are the
<code><nobr>CALL FAR mem</nobr></code> forms.
<p>You can choose between the two immediate far call forms
(<code><nobr>CALL imm:imm</nobr></code>) by the use of the
<code><nobr>WORD</nobr></code> and <code><nobr>DWORD</nobr></code>
keywords: <code><nobr>CALL WORD 0x1234:0x5678</nobr></code>) or
<code><nobr>CALL DWORD 0x1234:0x56789abc</nobr></code>.
<p>The <code><nobr>CALL FAR mem</nobr></code> forms execute a far call by
loading the destination address out of memory. The address loaded consists
of 16 or 32 bits of offset (depending on the operand size), and 16 bits of
segment. The operand size may be overridden using
<code><nobr>CALL WORD FAR mem</nobr></code> or
<code><nobr>CALL DWORD FAR mem</nobr></code>.
<p>The <code><nobr>CALL r/m</nobr></code> forms execute a near call (within
the same segment), loading the destination address out of memory or out of
a register. The keyword <code><nobr>NEAR</nobr></code> may be specified,
for clarity, in these forms, but is not necessary. Again, operand size can
be overridden using <code><nobr>CALL WORD mem</nobr></code> or
<code><nobr>CALL DWORD mem</nobr></code>.
<p>As a convenience, NASM does not require you to call a far procedure
symbol by coding the cumbersome
<code><nobr>CALL SEG routine:routine</nobr></code>, but instead allows the
easier synonym <code><nobr>CALL FAR routine</nobr></code>.
<p>The <code><nobr>CALL r/m</nobr></code> forms given above are near calls;
NASM will accept the <code><nobr>NEAR</nobr></code> keyword (e.g.
<code><nobr>CALL NEAR [address]</nobr></code>), even though it is not
strictly necessary.
<h3><a name="section-A.18">A.18 <code><nobr>CBW</nobr></code>, <code><nobr>CWD</nobr></code>, <code><nobr>CDQ</nobr></code>, <code><nobr>CWDE</nobr></code>: Sign Extensions</a></h3>
<p><pre>
CBW                           ; o16 98               [8086] 
CWD                           ; o16 99               [8086] 
CDQ                           ; o32 99               [386] 
CWDE                          ; o32 98               [386]
</pre>
<p>All these instructions sign-extend a short value into a longer one, by
replicating the top bit of the original value to fill the extended one.
<p><code><nobr>CBW</nobr></code> extends <code><nobr>AL</nobr></code> into
<code><nobr>AX</nobr></code> by repeating the top bit of
<code><nobr>AL</nobr></code> in every bit of <code><nobr>AH</nobr></code>.
<code><nobr>CWD</nobr></code> extends <code><nobr>AX</nobr></code> into
<code><nobr>DX:AX</nobr></code> by repeating the top bit of
<code><nobr>AX</nobr></code> throughout <code><nobr>DX</nobr></code>.
<code><nobr>CWDE</nobr></code> extends <code><nobr>AX</nobr></code> into
<code><nobr>EAX</nobr></code>, and <code><nobr>CDQ</nobr></code> extends
<code><nobr>EAX</nobr></code> into <code><nobr>EDX:EAX</nobr></code>.
<h3><a name="section-A.19">A.19 <code><nobr>CLC</nobr></code>, <code><nobr>CLD</nobr></code>, <code><nobr>CLI</nobr></code>, <code><nobr>CLTS</nobr></code>: Clear Flags</a></h3>
<p><pre>
CLC                           ; F8                   [8086] 
CLD                           ; FC                   [8086] 
CLI                           ; FA                   [8086] 
CLTS                          ; 0F 06                [286,PRIV]
</pre>
<p>These instructions clear various flags. <code><nobr>CLC</nobr></code>
clears the carry flag; <code><nobr>CLD</nobr></code> clears the direction
flag; <code><nobr>CLI</nobr></code> clears the interrupt flag (thus
disabling interrupts); and <code><nobr>CLTS</nobr></code> clears the
task-switched (<code><nobr>TS</nobr></code>) flag in
<code><nobr>CR0</nobr></code>.
<p>To set the carry, direction, or interrupt flags, use the
<code><nobr>STC</nobr></code>, <code><nobr>STD</nobr></code> and
<code><nobr>STI</nobr></code> instructions
(<a href="#section-A.241">section A.241</a>). To invert the carry flag, use
<code><nobr>CMC</nobr></code> (<a href="#section-A.20">section A.20</a>).
<h3><a name="section-A.20">A.20 <code><nobr>CMC</nobr></code>: Complement Carry Flag</a></h3>
<p><pre>
CMC                           ; F5                   [8086]
</pre>
<p><code><nobr>CMC</nobr></code> changes the value of the carry flag: if it
was 0, it sets it to 1, and vice versa.
<h3><a name="section-A.21">A.21 <code><nobr>CMOVcc</nobr></code>: Conditional Move</a></h3>
<p><pre>
CMOVcc reg16,r/m16            ; o16 0F 40+cc /r      [P6] 
CMOVcc reg32,r/m32            ; o32 0F 40+cc /r      [P6]
</pre>
<p><code><nobr>CMOV</nobr></code> moves its source (second) operand into
its destination (first) operand if the given condition code is satisfied;
otherwise it does nothing.
<p>For a list of condition codes, see <a href="#section-A.2.2">section
A.2.2</a>.
<p>Although the <code><nobr>CMOV</nobr></code> instructions are flagged
<code><nobr>P6</nobr></code> above, they may not be supported by all
Pentium Pro processors; the <code><nobr>CPUID</nobr></code> instruction
(<a href="#section-A.29">section A.29</a>) will return a bit which
indicates whether conditional moves are supported.
<h3><a name="section-A.22">A.22 <code><nobr>CMP</nobr></code>: Compare Integers</a></h3>
<p><pre>
CMP r/m8,reg8                 ; 38 /r                [8086] 
CMP r/m16,reg16               ; o16 39 /r            [8086] 
CMP r/m32,reg32               ; o32 39 /r            [386]
</pre>
<p><pre>
CMP reg8,r/m8                 ; 3A /r                [8086] 
CMP reg16,r/m16               ; o16 3B /r            [8086] 
CMP reg32,r/m32               ; o32 3B /r            [386]
</pre>
<p><pre>
CMP r/m8,imm8                 ; 80 /0 ib             [8086] 
CMP r/m16,imm16               ; o16 81 /0 iw         [8086] 
CMP r/m32,imm32               ; o32 81 /0 id         [386]
</pre>
<p><pre>
CMP r/m16,imm8                ; o16 83 /0 ib         [8086] 
CMP r/m32,imm8                ; o32 83 /0 ib         [386]
</pre>
<p><pre>
CMP AL,imm8                   ; 3C ib                [8086] 
CMP AX,imm16                  ; o16 3D iw            [8086] 
CMP EAX,imm32                 ; o32 3D id            [386]
</pre>
<p><code><nobr>CMP</nobr></code> performs a `mental' subtraction of its
second operand from its first operand, and affects the flags as if the
subtraction had taken place, but does not store the result of the
subtraction anywhere.
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<h3><a name="section-A.23">A.23 <code><nobr>CMPccPS</nobr></code>: SSE Packed Single-FP Compare</a></h3>
<p><pre>
CMPPS xmmreg,r/m128,imm8      ; 0F C2 /r ib          [KATMAI,SSE]
</pre>
<p><pre>
CMPEQPS xmmreg,r/m128         ; 0F C2 /r 00          [KATMAI,SSE] 
CMPLEPS xmmreg,r/m128         ; 0F C2 /r 02          [KATMAI,SSE] 
CMPLTPS xmmreg,r/m128         ; 0F C2 /r 01          [KATMAI,SSE] 
CMPNEQPS xmmreg,r/m128        ; 0F C2 /r 04          [KATMAI,SSE] 
CMPNLEPS xmmreg,r/m128        ; 0F C2 /r 06          [KATMAI,SSE] 
CMPNLTPS xmmreg,r/m128        ; 0F C2 /r 05          [KATMAI,SSE] 
CMPORDPS xmmreg,r/m128        ; 0F C2 /r 07          [KATMAI,SSE] 
CMPUNORDPS xmmreg,r/m128      ; 0F C2 /r 03          [KATMAI,SSE]
</pre>
<p><code><nobr>CMPPS</nobr></code> treats both operands as vectors of four
32-bit floating-point numbers. For each pair of such numbers
<code><nobr>CMPPS</nobr></code> produces an all <code><nobr>1</nobr></code>
32-bit mask or an all <code><nobr>0</nobr></code> 32-bit mask, using the
comparison specified by imm8, and puts this mask in the corresponding
location in the destination register. The allowed values of imm8 are 0-7,
which correspond to the eight pseudo-ops shown above.
<h3><a name="section-A.24">A.24 <code><nobr>CMPSB</nobr></code>, <code><nobr>CMPSW</nobr></code>, <code><nobr>CMPSD</nobr></code>: Compare Strings</a></h3>
<p><pre>
CMPSB                         ; A6                   [8086] 
CMPSW                         ; o16 A7               [8086] 
CMPSD                         ; o32 A7               [386]
</pre>
<p><code><nobr>CMPSB</nobr></code> compares the byte at
<code><nobr>[DS:SI]</nobr></code> or <code><nobr>[DS:ESI]</nobr></code>
with the byte at <code><nobr>[ES:DI]</nobr></code> or
<code><nobr>[ES:EDI]</nobr></code>, and sets the flags accordingly. It then
increments or decrements (depending on the direction flag: increments if
the flag is clear, decrements if it is set) <code><nobr>SI</nobr></code>
and <code><nobr>DI</nobr></code> (or <code><nobr>ESI</nobr></code> and
<code><nobr>EDI</nobr></code>).
<p>The registers used are <code><nobr>SI</nobr></code> and
<code><nobr>DI</nobr></code> if the address size is 16 bits, and
<code><nobr>ESI</nobr></code> and <code><nobr>EDI</nobr></code> if it is 32
bits. If you need to use an address size not equal to the current
<code><nobr>BITS</nobr></code> setting, you can use an explicit
<code><nobr>a16</nobr></code> or <code><nobr>a32</nobr></code> prefix.
<p>The segment register used to load from <code><nobr>[SI]</nobr></code> or
<code><nobr>[ESI]</nobr></code> can be overridden by using a segment
register name as a prefix (for example,
<code><nobr>es cmpsb</nobr></code>). The use of
<code><nobr>ES</nobr></code> for the load from
<code><nobr>[DI]</nobr></code> or <code><nobr>[EDI]</nobr></code> cannot be
overridden.
<p><code><nobr>CMPSW</nobr></code> and <code><nobr>CMPSD</nobr></code> work
in the same way, but they compare a word or a doubleword instead of a byte,
and increment or decrement the addressing registers by 2 or 4 instead of 1.
<p>The <code><nobr>REPE</nobr></code> and <code><nobr>REPNE</nobr></code>
prefixes (equivalently, <code><nobr>REPZ</nobr></code> and
<code><nobr>REPNZ</nobr></code>) may be used to repeat the instruction up
to <code><nobr>CX</nobr></code> (or <code><nobr>ECX</nobr></code> - again,
the address size chooses which) times until the first unequal or equal byte
is found.
<h3><a name="section-A.25">A.25 <code><nobr>CMPccSS</nobr></code>: SSE Scalar Single-FP Compare</a></h3>
<p><pre>
CMPSS xmmreg,xmmreg/mem32,imm8; F3 0F C2 /r ib       [KATMAI,SSE]
</pre>
<p><pre>
CMPEQSS xmmreg,xmmreg/mem32   ; F3 0F C2 /r 00       [KATMAI,SSE] 
CMPLESS xmmreg,xmmreg/mem32   ; F3 0F C2 /r 02       [KATMAI,SSE] 
CMPLTSS xmmreg,xmmreg/mem32   ; F3 0F C2 /r 01       [KATMAI,SSE] 
CMPNEQSS xmmreg,xmmreg/mem32  ; F3 0F C2 /r 04       [KATMAI,SSE] 
CMPNLESS xmmreg,xmmreg/mem32  ; F3 0F C2 /r 06       [KATMAI,SSE] 
CMPNLTSS xmmreg,xmmreg/mem32  ; F3 0F C2 /r 05       [KATMAI,SSE] 
CMPORDSS xmmreg,xmmreg/mem32  ; F3 0F C2 /r 07       [KATMAI,SSE] 
CMPUNORDSS xmmreg,xmmreg/mem32; F3 0F C2 /r 03       [KATMAI,SSE]
</pre>
<p><code><nobr>CMPSS</nobr></code> is the same as
<code><nobr>CMPPS</nobr></code> except that it compares only the first pair
of 32-bit floating point numbers.
<h3><a name="section-A.26">A.26 <code><nobr>CMPXCHG</nobr></code>, <code><nobr>CMPXCHG486</nobr></code>: Compare and Exchange</a></h3>
<p><pre>
CMPXCHG r/m8,reg8             ; 0F B0 /r             [PENT] 
CMPXCHG r/m16,reg16           ; o16 0F B1 /r         [PENT] 
CMPXCHG r/m32,reg32           ; o32 0F B1 /r         [PENT]
</pre>
<p><pre>
CMPXCHG486 r/m8,reg8          ; 0F A6 /r             [486,UNDOC] 
CMPXCHG486 r/m16,reg16        ; o16 0F A7 /r         [486,UNDOC] 
CMPXCHG486 r/m32,reg32        ; o32 0F A7 /r         [486,UNDOC]
</pre>
<p>These two instructions perform exactly the same operation; however,
apparently some (not all) 486 processors support it under a non-standard
opcode, so NASM provides the undocumented
<code><nobr>CMPXCHG486</nobr></code> form to generate the non-standard
opcode.
<p><code><nobr>CMPXCHG</nobr></code> compares its destination (first)
operand to the value in <code><nobr>AL</nobr></code>,
<code><nobr>AX</nobr></code> or <code><nobr>EAX</nobr></code> (depending on
the size of the instruction). If they are equal, it copies its source
(second) operand into the destination and sets the zero flag. Otherwise, it
clears the zero flag and leaves the destination alone.
<p><code><nobr>CMPXCHG</nobr></code> is intended to be used for atomic
operations in multitasking or multiprocessor environments. To safely update
a value in shared memory, for example, you might load the value into
<code><nobr>EAX</nobr></code>, load the updated value into
<code><nobr>EBX</nobr></code>, and then execute the instruction
<code><nobr>lock cmpxchg [value],ebx</nobr></code>. If
<code><nobr>value</nobr></code> has not changed since being loaded, it is
updated with your desired new value, and the zero flag is set to let you
know it has worked. (The <code><nobr>LOCK</nobr></code> prefix prevents
another processor doing anything in the middle of this operation: it
guarantees atomicity.) However, if another processor has modified the value
in between your load and your attempted store, the store does not happen,
and you are notified of the failure by a cleared zero flag, so you can go
round and try again.
<h3><a name="section-A.27">A.27 <code><nobr>CMPXCHG8B</nobr></code>: Compare and Exchange Eight Bytes</a></h3>
<p><pre>
CMPXCHG8B mem                 ; 0F C7 /1             [PENT]
</pre>
<p>This is a larger and more unwieldy version of
<code><nobr>CMPXCHG</nobr></code>: it compares the 64-bit (eight-byte)
value stored at <code><nobr>[mem]</nobr></code> with the value in
<code><nobr>EDX:EAX</nobr></code>. If they are equal, it sets the zero flag
and stores <code><nobr>ECX:EBX</nobr></code> into the memory area. If they
are unequal, it clears the zero flag and leaves the memory area untouched.
<h3><a name="section-A.28">A.28 <code><nobr>COMISS</nobr></code>: SSE Scalar Compare and Set EFLAGS</a></h3>
<p><pre>
COMISS xmmreg,xmmreg/mem32    ; 0F 2F /r             [KATMAI,SSE]
</pre>
<p><code><nobr>COMISS</nobr></code> compares the 32-bit floating-point
numbers in the lowest part of the two operands, and sets the CPU flags
appropriately. <code><nobr>COMISS</nobr></code> differs from
<code><nobr>UCOMISS</nobr></code> in that it signals an invalid numeric
exeception if an operand is an sNaN or a qNaN, whereas
<code><nobr>UCOMISS</nobr></code> does so only if an operand is an sNaN.
<h3><a name="section-A.29">A.29 <code><nobr>CPUID</nobr></code>: Get CPU Identification Code</a></h3>
<p><pre>
CPUID                         ; 0F A2                [PENT]
</pre>
<p><code><nobr>CPUID</nobr></code> returns various information about the
processor it is being executed on. It fills the four registers
<code><nobr>EAX</nobr></code>, <code><nobr>EBX</nobr></code>,
<code><nobr>ECX</nobr></code> and <code><nobr>EDX</nobr></code> with
information, which varies depending on the input contents of
<code><nobr>EAX</nobr></code>.
<p><code><nobr>CPUID</nobr></code> also acts as a barrier to serialise
instruction execution: executing the <code><nobr>CPUID</nobr></code>
instruction guarantees that all the effects (memory modification, flag
modification, register modification) of previous instructions have been
completed before the next instruction gets fetched.
<p>The information returned is as follows:
<ul>
<li>If <code><nobr>EAX</nobr></code> is zero on input,
<code><nobr>EAX</nobr></code> on output holds the maximum acceptable input
value of <code><nobr>EAX</nobr></code>, and
<code><nobr>EBX:EDX:ECX</nobr></code> contain the string
<code><nobr>"GenuineIntel"</nobr></code> (or not, if you have a clone
processor). That is to say, <code><nobr>EBX</nobr></code> contains
<code><nobr>"Genu"</nobr></code> (in NASM's own sense of character
constants, described in <a href="nasmdoc3.htm#section-3.4.2">section
3.4.2</a>), <code><nobr>EDX</nobr></code> contains
<code><nobr>"ineI"</nobr></code> and <code><nobr>ECX</nobr></code> contains
<code><nobr>"ntel"</nobr></code>.
<li>If <code><nobr>EAX</nobr></code> is one on input,
<code><nobr>EAX</nobr></code> on output contains version information about
the processor, and <code><nobr>EDX</nobr></code> contains a set of feature
flags, showing the presence and absence of various features. For example,
bit 8 is set if the <code><nobr>CMPXCHG8B</nobr></code> instruction
(<a href="#section-A.27">section A.27</a>) is supported, bit 15 is set if
the conditional move instructions (<a href="#section-A.21">section A.21</a>
and <a href="#section-A.47">section A.47</a>) are supported, and bit 23 is
set if MMX instructions are supported.
<li>If <code><nobr>EAX</nobr></code> is two on input,
<code><nobr>EAX</nobr></code>, <code><nobr>EBX</nobr></code>,
<code><nobr>ECX</nobr></code> and <code><nobr>EDX</nobr></code> all contain
information about caches and TLBs (Translation Lookahead Buffers).
</ul>
<p>For more information on the data returned from
<code><nobr>CPUID</nobr></code>, see the documentation on Intel's web site.
<h3><a name="section-A.30">A.30 <code><nobr>CVTPI2PS</nobr></code>: SSE Packed Integer to Floating-Point Conversion</a></h3>
<p><pre>
CVTPI2PS xmmreg,r/m64         ; 0F 2A /r             [KATMAI,SSE]
</pre>
<p><code><nobr>CVTPI2PS</nobr></code> considers the source operand as a
pair of signed 32-bit integers and converts them to 32-bit floating-point
numbers, storing the result in the lower half of the destination register.
<h3><a name="section-A.31">A.31 <code><nobr>CVTPS2PI</nobr></code>, <code><nobr>CVTTPS2PI</nobr></code>: SSE Packed Floating-Point to Integer Conversion</a></h3>
<p><pre>
CVTPS2PI mmxreg,xmmreg/mem64  ; 0F 2D /r             [KATMAI,SSE] 
CVTTPS2PI mmxreg,xmmreg/mem64 ; 0F 2C /r             [KATMAI,SSE]
</pre>
<p>These instructions consider the source operand as a pair of 32-bit
floating-point numbers and convert them to signed 32-bit integers, storing
the result in the destination register. Note that if the source operand is
a register then only its lower half is used. If the conversion is inexact,
then <code><nobr>CVTTPS2PI</nobr></code> truncates, whereas
<code><nobr>CVTPS2PI</nobr></code> rounds according to the MXCSR.
<h3><a name="section-A.32">A.32 <code><nobr>CVTSI2SS</nobr></code>: SSE Scalar Integer to Floating-Point Conversion</a></h3>
<p><pre>
CVTSI2SS xmmreg,r/m32         ; F3 0F 2A /r          [KATMAI,SSE]
</pre>
<p><code><nobr>CVTSI2SS</nobr></code> considers the source operand as a
32-bit signed integer, and converts it to a 32-bit float, storing the
result in the lowest quarter of the destination register.
<h3><a name="section-A.33">A.33 <code><nobr>CVTSS2SI</nobr></code>, <code><nobr>CVTTSS2SI</nobr></code>: SSE Scalar Floating-Point to Integer Conversion</a></h3>
<p><pre>
CVTSS2SI reg32,xmmreg/mem32   ; F3 0F 2D /r          [KATMAI,SSE] 
CVTTSS2SI reg32,xmmreg/mem32  ; F3 0F 2C /r          [KATMAI,SSE]
</pre>
<p>These instructions consider the source operand as a 32-bit
floating-point number and convert it to a signed 32-bit integer, storing
the result in the destination register. Note that if the source operand is
a register then only its lowest quarter is used. If the conversion is
inexact, then <code><nobr>CVTTSS2SI</nobr></code> truncates, whereas
<code><nobr>CVTSS2SI</nobr></code> rounds according to the MXCSR.
<h3><a name="section-A.34">A.34 <code><nobr>DAA</nobr></code>, <code><nobr>DAS</nobr></code>: Decimal Adjustments</a></h3>
<p><pre>
DAA                           ; 27                   [8086] 
DAS                           ; 2F                   [8086]
</pre>
<p>These instructions are used in conjunction with the add and subtract
instructions to perform binary-coded decimal arithmetic in <em>packed</em>
(one BCD digit per nibble) form. For the unpacked equivalents, see
<a href="#section-A.4">section A.4</a>.
<p><code><nobr>DAA</nobr></code> should be used after a one-byte
<code><nobr>ADD</nobr></code> instruction whose destination was the
<code><nobr>AL</nobr></code> register: by means of examining the value in
the <code><nobr>AL</nobr></code> and also the auxiliary carry flag
<code><nobr>AF</nobr></code>, it determines whether either digit of the
addition has overflowed, and adjusts it (and sets the carry and
auxiliary-carry flags) if so. You can add long BCD strings together by
doing <code><nobr>ADD</nobr></code>/<code><nobr>DAA</nobr></code> on the
low two digits, then doing
<code><nobr>ADC</nobr></code>/<code><nobr>DAA</nobr></code> on each
subsequent pair of digits.
<p><code><nobr>DAS</nobr></code> works similarly to
<code><nobr>DAA</nobr></code>, but is for use after
<code><nobr>SUB</nobr></code> instructions rather than
<code><nobr>ADD</nobr></code>.
<h3><a name="section-A.35">A.35 <code><nobr>DEC</nobr></code>: Decrement Integer</a></h3>
<p><pre>
DEC reg16                     ; o16 48+r             [8086] 
DEC reg32                     ; o32 48+r             [386] 
DEC r/m8                      ; FE /1                [8086] 
DEC r/m16                     ; o16 FF /1            [8086] 
DEC r/m32                     ; o32 FF /1            [386]
</pre>
<p><code><nobr>DEC</nobr></code> subtracts 1 from its operand. It does
<em>not</em> affect the carry flag: to affect the carry flag, use
<code><nobr>SUB something,1</nobr></code> (see
<a href="#section-A.245">section A.245</a>). See also
<code><nobr>INC</nobr></code> (<a href="#section-A.97">section A.97</a>).
<h3><a name="section-A.36">A.36 <code><nobr>DIV</nobr></code>: Unsigned Integer Divide</a></h3>
<p><pre>
DIV r/m8                      ; F6 /6                [8086] 
DIV r/m16                     ; o16 F7 /6            [8086] 
DIV r/m32                     ; o32 F7 /6            [386]
</pre>
<p><code><nobr>DIV</nobr></code> performs unsigned integer division. The
explicit operand provided is the divisor; the dividend and destination
operands are implicit, in the following way:
<ul>
<li>For <code><nobr>DIV r/m8</nobr></code>, <code><nobr>AX</nobr></code> is
divided by the given operand; the quotient is stored in
<code><nobr>AL</nobr></code> and the remainder in
<code><nobr>AH</nobr></code>.
<li>For <code><nobr>DIV r/m16</nobr></code>,
<code><nobr>DX:AX</nobr></code> is divided by the given operand; the
quotient is stored in <code><nobr>AX</nobr></code> and the remainder in
<code><nobr>DX</nobr></code>.
<li>For <code><nobr>DIV r/m32</nobr></code>,
<code><nobr>EDX:EAX</nobr></code> is divided by the given operand; the
quotient is stored in <code><nobr>EAX</nobr></code> and the remainder in
<code><nobr>EDX</nobr></code>.
</ul>
<p>Signed integer division is performed by the
<code><nobr>IDIV</nobr></code> instruction: see
<a href="#section-A.94">section A.94</a>.
<h3><a name="section-A.37">A.37 <code><nobr>DIVPS</nobr></code>: Packed Single-FP Divide</a></h3>
<p><pre>
DIVPS xmmreg,r/m128           ; 0F 5E /r             [KATMAI,SSE]
</pre>
<p><code><nobr>DIVPS</nobr></code> considers both operands as vectors of
four 32-bit floating-point numbers and divides each such number in the
destination register by the corresponding number in the source operand.
<h3><a name="section-A.38">A.38 <code><nobr>DIVSS</nobr></code>: Scalar Single-FP Divide</a></h3>
<p><pre>
DIVSS xmmreg,xmmreg/mem32     ; F3 0F 5E /r          [KATMAI,SSE]
</pre>
<p>c{DIVSS} divides the 32-bit floating-point number in the lowest quarter
of the destination register by the corresponding number in the source
operand.
<h3><a name="section-A.39">A.39 <code><nobr>EMMS</nobr></code>: Empty MMX State</a></h3>
<p><pre>
EMMS                          ; 0F 77                [PENT,MMX]
</pre>
<p><code><nobr>EMMS</nobr></code> sets the FPU tag word (marking which
floating-point registers are available) to all ones, meaning all registers
are available for the FPU to use. It should be used after executing MMX
instructions and before executing any subsequent floating-point operations.
<h3><a name="section-A.40">A.40 <code><nobr>ENTER</nobr></code>: Create Stack Frame</a></h3>
<p><pre>
ENTER imm,imm                 ; C8 iw ib             [186]
</pre>
<p><code><nobr>ENTER</nobr></code> constructs a stack frame for a
high-level language procedure call. The first operand (the
<code><nobr>iw</nobr></code> in the opcode definition above refers to the
first operand) gives the amount of stack space to allocate for local
variables; the second (the <code><nobr>ib</nobr></code> above) gives the
nesting level of the procedure (for languages like Pascal, with nested
procedures).
<p>The function of <code><nobr>ENTER</nobr></code>, with a nesting level of
zero, is equivalent to
<p><pre>
          PUSH EBP            ; or PUSH BP         in 16 bits 
          MOV EBP,ESP         ; or MOV BP,SP       in 16 bits 
          SUB ESP,operand1    ; or SUB SP,operand1 in 16 bits
</pre>
<p>This creates a stack frame with the procedure parameters accessible
upwards from <code><nobr>EBP</nobr></code>, and local variables accessible
downwards from <code><nobr>EBP</nobr></code>.
<p>With a nesting level of one, the stack frame created is 4 (or 2) bytes
bigger, and the value of the final frame pointer
<code><nobr>EBP</nobr></code> is accessible in memory at
<code><nobr>[EBP-4]</nobr></code>.
<p>This allows <code><nobr>ENTER</nobr></code>, when called with a nesting
level of two, to look at the stack frame described by the <em>previous</em>
value of <code><nobr>EBP</nobr></code>, find the frame pointer at offset -4
from that, and push it along with its new frame pointer, so that when a
level-two procedure is called from within a level-one procedure,
<code><nobr>[EBP-4]</nobr></code> holds the frame pointer of the most
recent level-one procedure call and <code><nobr>[EBP-8]</nobr></code> holds
that of the most recent level-two call. And so on, for nesting levels up to
31.
<p>Stack frames created by <code><nobr>ENTER</nobr></code> can be destroyed
by the <code><nobr>LEAVE</nobr></code> instruction: see
<a href="#section-A.113">section A.113</a>.
<h3><a name="section-A.41">A.41 <code><nobr>F2XM1</nobr></code>: Calculate 2**X-1</a></h3>
<p><pre>
F2XM1                         ; D9 F0                [8086,FPU]
</pre>
<p><code><nobr>F2XM1</nobr></code> raises 2 to the power of
<code><nobr>ST0</nobr></code>, subtracts one, and stores the result back
into <code><nobr>ST0</nobr></code>. The initial contents of
<code><nobr>ST0</nobr></code> must be a number in the range -1 to +1.
<h3><a name="section-A.42">A.42 <code><nobr>FABS</nobr></code>: Floating-Point Absolute Value</a></h3>
<p><pre>
FABS                          ; D9 E1                [8086,FPU]
</pre>
<p><code><nobr>FABS</nobr></code> computes the absolute value of
<code><nobr>ST0</nobr></code>, storing the result back in
<code><nobr>ST0</nobr></code>.
<h3><a name="section-A.43">A.43 <code><nobr>FADD</nobr></code>, <code><nobr>FADDP</nobr></code>: Floating-Point Addition</a></h3>
<p><pre>
FADD mem32                    ; D8 /0                [8086,FPU] 
FADD mem64                    ; DC /0                [8086,FPU]
</pre>
<p><pre>
FADD fpureg                   ; D8 C0+r              [8086,FPU] 
FADD ST0,fpureg               ; D8 C0+r              [8086,FPU]
</pre>
<p><pre>
FADD TO fpureg                ; DC C0+r              [8086,FPU] 
FADD fpureg,ST0               ; DC C0+r              [8086,FPU]
</pre>
<p><pre>
FADDP fpureg                  ; DE C0+r              [8086,FPU] 
FADDP fpureg,ST0              ; DE C0+r              [8086,FPU]
</pre>
<p><code><nobr>FADD</nobr></code>, given one operand, adds the operand to
<code><nobr>ST0</nobr></code> and stores the result back in
<code><nobr>ST0</nobr></code>. If the operand has the
<code><nobr>TO</nobr></code> modifier, the result is stored in the register
given rather than in <code><nobr>ST0</nobr></code>.
<p><code><nobr>FADDP</nobr></code> performs the same function as
<code><nobr>FADD TO</nobr></code>, but pops the register stack after
storing the result.
<p>The given two-operand forms are synonyms for the one-operand forms.
<h3><a name="section-A.44">A.44 <code><nobr>FBLD</nobr></code>, <code><nobr>FBSTP</nobr></code>: BCD Floating-Point Load and Store</a></h3>
<p><pre>
FBLD mem80                    ; DF /4                [8086,FPU] 
FBSTP mem80                   ; DF /6                [8086,FPU]
</pre>
<p><code><nobr>FBLD</nobr></code> loads an 80-bit (ten-byte) packed
binary-coded decimal number from the given memory address, converts it to a
real, and pushes it on the register stack. <code><nobr>FBSTP</nobr></code>
stores the value of <code><nobr>ST0</nobr></code>, in packed BCD, at the
given address and then pops the register stack.
<h3><a name="section-A.45">A.45 <code><nobr>FCHS</nobr></code>: Floating-Point Change Sign</a></h3>
<p><pre>
FCHS                          ; D9 E0                [8086,FPU]
</pre>
<p><code><nobr>FCHS</nobr></code> negates the number in
<code><nobr>ST0</nobr></code>: negative numbers become positive, and vice
versa.
<h3><a name="section-A.46">A.46 <code><nobr>FCLEX</nobr></code>, <code><nobr>FNCLEX</nobr></code>: Clear Floating-Point Exceptions</a></h3>
<p><pre>
FCLEX                         ; 9B DB E2             [8086,FPU] 
FNCLEX                        ; DB E2                [8086,FPU]
</pre>
<p><code><nobr>FCLEX</nobr></code> clears any floating-point exceptions
which may be pending. <code><nobr>FNCLEX</nobr></code> does the same thing
but doesn't wait for previous floating-point operations (including the
<em>handling</em> of pending exceptions) to finish first.
<h3><a name="section-A.47">A.47 <code><nobr>FCMOVcc</nobr></code>: Floating-Point Conditional Move</a></h3>
<p><pre>
FCMOVB fpureg                 ; DA C0+r              [P6,FPU] 
FCMOVB ST0,fpureg             ; DA C0+r              [P6,FPU]
</pre>
<p><pre>
FCMOVBE fpureg                ; DA D0+r              [P6,FPU] 
FCMOVBE ST0,fpureg            ; DA D0+r              [P6,FPU]
</pre>
<p><pre>
FCMOVE fpureg                 ; DA C8+r              [P6,FPU] 
FCMOVE ST0,fpureg             ; DA C8+r              [P6,FPU]
</pre>
<p><pre>
FCMOVNB fpureg                ; DB C0+r              [P6,FPU] 
FCMOVNB ST0,fpureg            ; DB C0+r              [P6,FPU]
</pre>
<p><pre>
FCMOVNBE fpureg               ; DB D0+r              [P6,FPU] 
FCMOVNBE ST0,fpureg           ; DB D0+r              [P6,FPU]
</pre>
<p><pre>
FCMOVNE fpureg                ; DB C8+r              [P6,FPU] 
FCMOVNE ST0,fpureg            ; DB C8+r              [P6,FPU]
</pre>
<p><pre>
FCMOVNU fpureg                ; DB D8+r              [P6,FPU] 
FCMOVNU ST0,fpureg            ; DB D8+r              [P6,FPU]
</pre>
<p><pre>
FCMOVU fpureg                 ; DA D8+r              [P6,FPU] 
FCMOVU ST0,fpureg             ; DA D8+r              [P6,FPU]
</pre>
<p>The <code><nobr>FCMOV</nobr></code> instructions perform conditional
move operations: each of them moves the contents of the given register into
<code><nobr>ST0</nobr></code> if its condition is satisfied, and does
nothing if not.
<p>The conditions are not the same as the standard condition codes used
with conditional jump instructions. The conditions
<code><nobr>B</nobr></code>, <code><nobr>BE</nobr></code>,
<code><nobr>NB</nobr></code>, <code><nobr>NBE</nobr></code>,
<code><nobr>E</nobr></code> and <code><nobr>NE</nobr></code> are exactly as
normal, but none of the other standard ones are supported. Instead, the
condition <code><nobr>U</nobr></code> and its counterpart
<code><nobr>NU</nobr></code> are provided; the <code><nobr>U</nobr></code>
condition is satisfied if the last two floating-point numbers compared were
<em>unordered</em>, i.e. they were not equal but neither one could be said
to be greater than the other, for example if they were NaNs. (The flag
state which signals this is the setting of the parity flag: so the
<code><nobr>U</nobr></code> condition is notionally equivalent to
<code><nobr>PE</nobr></code>, and <code><nobr>NU</nobr></code> is
equivalent to <code><nobr>PO</nobr></code>.)
<p>The <code><nobr>FCMOV</nobr></code> conditions test the main processor's
status flags, not the FPU status flags, so using
<code><nobr>FCMOV</nobr></code> directly after
<code><nobr>FCOM</nobr></code> will not work. Instead, you should either
use <code><nobr>FCOMI</nobr></code> which writes directly to the main CPU
flags word, or use <code><nobr>FSTSW</nobr></code> to extract the FPU
flags.
<p>Although the <code><nobr>FCMOV</nobr></code> instructions are flagged
<code><nobr>P6</nobr></code> above, they may not be supported by all
Pentium Pro processors; the <code><nobr>CPUID</nobr></code> instruction
(<a href="#section-A.29">section A.29</a>) will return a bit which
indicates whether conditional moves are supported.
<h3><a name="section-A.48">A.48 <code><nobr>FCOM</nobr></code>, <code><nobr>FCOMP</nobr></code>, <code><nobr>FCOMPP</nobr></code>, <code><nobr>FCOMI</nobr></code>, <code><nobr>FCOMIP</nobr></code>: Floating-Point Compare</a></h3>
<p><pre>
FCOM mem32                    ; D8 /2                [8086,FPU] 
FCOM mem64                    ; DC /2                [8086,FPU] 
FCOM fpureg                   ; D8 D0+r              [8086,FPU] 
FCOM ST0,fpureg               ; D8 D0+r              [8086,FPU]
</pre>
<p><pre>
FCOMP mem32                   ; D8 /3                [8086,FPU] 
FCOMP mem64                   ; DC /3                [8086,FPU] 
FCOMP fpureg                  ; D8 D8+r              [8086,FPU] 
FCOMP ST0,fpureg              ; D8 D8+r              [8086,FPU]
</pre>
<p><pre>
FCOMPP                        ; DE D9                [8086,FPU]
</pre>
<p><pre>
FCOMI fpureg                  ; DB F0+r              [P6,FPU] 
FCOMI ST0,fpureg              ; DB F0+r              [P6,FPU]
</pre>
<p><pre>
FCOMIP fpureg                 ; DF F0+r              [P6,FPU] 
FCOMIP ST0,fpureg             ; DF F0+r              [P6,FPU]
</pre>
<p><code><nobr>FCOM</nobr></code> compares <code><nobr>ST0</nobr></code>
with the given operand, and sets the FPU flags accordingly.
<code><nobr>ST0</nobr></code> is treated as the left-hand side of the
comparison, so that the carry flag is set (for a `less-than' result) if
<code><nobr>ST0</nobr></code> is less than the given operand.
<p><code><nobr>FCOMP</nobr></code> does the same as
<code><nobr>FCOM</nobr></code>, but pops the register stack afterwards.
<code><nobr>FCOMPP</nobr></code> compares <code><nobr>ST0</nobr></code>
with <code><nobr>ST1</nobr></code> and then pops the register stack twice.
<p><code><nobr>FCOMI</nobr></code> and <code><nobr>FCOMIP</nobr></code>
work like the corresponding forms of <code><nobr>FCOM</nobr></code> and
<code><nobr>FCOMP</nobr></code>, but write their results directly to the
CPU flags register rather than the FPU status word, so they can be
immediately followed by conditional jump or conditional move instructions.
<p>The <code><nobr>FCOM</nobr></code> instructions differ from the
<code><nobr>FUCOM</nobr></code> instructions
(<a href="#section-A.84">section A.84</a>) only in the way they handle
quiet NaNs: <code><nobr>FUCOM</nobr></code> will handle them silently and
set the condition code flags to an `unordered' result, whereas
<code><nobr>FCOM</nobr></code> will generate an exception.
<h3><a name="section-A.49">A.49 <code><nobr>FCOS</nobr></code>: Cosine</a></h3>
<p><pre>
FCOS                          ; D9 FF                [386,FPU]
</pre>
<p><code><nobr>FCOS</nobr></code> computes the cosine of
<code><nobr>ST0</nobr></code> (in radians), and stores the result in
<code><nobr>ST0</nobr></code>. See also <code><nobr>FSINCOS</nobr></code>
(<a href="#section-A.76">section A.76</a>).
<h3><a name="section-A.50">A.50 <code><nobr>FDECSTP</nobr></code>: Decrement Floating-Point Stack Pointer</a></h3>
<p><pre>
FDECSTP                       ; D9 F6                [8086,FPU]
</pre>
<p><code><nobr>FDECSTP</nobr></code> decrements the `top' field in the
floating-point status word. This has the effect of rotating the FPU
register stack by one, as if the contents of <code><nobr>ST7</nobr></code>
had been pushed on the stack. See also <code><nobr>FINCSTP</nobr></code>
(<a href="#section-A.61">section A.61</a>).
<h3><a name="section-A.51">A.51 <code><nobr>FxDISI</nobr></code>, <code><nobr>FxENI</nobr></code>: Disable and Enable Floating-Point Interrupts</a></h3>
<p><pre>
FDISI                         ; 9B DB E1             [8086,FPU] 
FNDISI                        ; DB E1                [8086,FPU]
</pre>
<p><pre>
FENI                          ; 9B DB E0             [8086,FPU] 
FNENI                         ; DB E0                [8086,FPU]
</pre>
<p><code><nobr>FDISI</nobr></code> and <code><nobr>FENI</nobr></code>
disable and enable floating-point interrupts. These instructions are only
meaningful on original 8087 processors: the 287 and above treat them as
no-operation instructions.
<p><code><nobr>FNDISI</nobr></code> and <code><nobr>FNENI</nobr></code> do
the same thing as <code><nobr>FDISI</nobr></code> and
<code><nobr>FENI</nobr></code> respectively, but without waiting for the
floating-point processor to finish what it was doing first.
<h3><a name="section-A.52">A.52 <code><nobr>FDIV</nobr></code>, <code><nobr>FDIVP</nobr></code>, <code><nobr>FDIVR</nobr></code>, <code><nobr>FDIVRP</nobr></code>: Floating-Point Division</a></h3>
<p><pre>
FDIV mem32                    ; D8 /6                [8086,FPU] 
FDIV mem64                    ; DC /6                [8086,FPU]
</pre>
<p><pre>
FDIV fpureg                   ; D8 F0+r              [8086,FPU] 
FDIV ST0,fpureg               ; D8 F0+r              [8086,FPU]
</pre>
<p><pre>
FDIV TO fpureg                ; DC F8+r              [8086,FPU] 
FDIV fpureg,ST0               ; DC F8+r              [8086,FPU]
</pre>
<p><pre>
FDIVR mem32                   ; D8 /0                [8086,FPU] 
FDIVR mem64                   ; DC /0                [8086,FPU]
</pre>
<p><pre>
FDIVR fpureg                  ; D8 F8+r              [8086,FPU] 
FDIVR ST0,fpureg              ; D8 F8+r              [8086,FPU]
</pre>
<p><pre>
FDIVR TO fpureg               ; DC F0+r              [8086,FPU] 
FDIVR fpureg,ST0              ; DC F0+r              [8086,FPU]
</pre>
<p><pre>
FDIVP fpureg                  ; DE F8+r              [8086,FPU] 
FDIVP fpureg,ST0              ; DE F8+r              [8086,FPU]
</pre>
<p><pre>
FDIVRP fpureg                 ; DE F0+r              [8086,FPU] 
FDIVRP fpureg,ST0             ; DE F0+r              [8086,FPU]
</pre>
<p><code><nobr>FDIV</nobr></code> divides <code><nobr>ST0</nobr></code> by
the given operand and stores the result back in
<code><nobr>ST0</nobr></code>, unless the <code><nobr>TO</nobr></code>
qualifier is given, in which case it divides the given operand by
<code><nobr>ST0</nobr></code> and stores the result in the operand.
<p><code><nobr>FDIVR</nobr></code> does the same thing, but does the
division the other way up: so if <code><nobr>TO</nobr></code> is not given,
it divides the given operand by <code><nobr>ST0</nobr></code> and stores
the result in <code><nobr>ST0</nobr></code>, whereas if
<code><nobr>TO</nobr></code> is given it divides
<code><nobr>ST0</nobr></code> by its operand and stores the result in the
operand.
<p><code><nobr>FDIVP</nobr></code> operates like
<code><nobr>FDIV TO</nobr></code>, but pops the register stack once it has
finished. <code><nobr>FDIVRP</nobr></code> operates like
<code><nobr>FDIVR TO</nobr></code>, but pops the register stack once it has
finished.
<h3><a name="section-A.53">A.53 <code><nobr>FEMMS</nobr></code>: Fast EMMS</a></h3>
<p><pre>
FEMMS                         ; 0F 0E                [3DNOW]
</pre>
<p><code><nobr>FEMMS</nobr></code> is like <code><nobr>EMMS</nobr></code>
except that it is faster and leaves the contents of the MMX /
floating-point registers undefined.
<h3><a name="section-A.54">A.54 <code><nobr>FFREE</nobr></code>: Flag Floating-Point Register as Unused</a></h3>
<p><pre>
FFREE fpureg                  ; DD C0+r              [8086,FPU]
</pre>
<p><code><nobr>FFREE</nobr></code> marks the given register as being empty.
<h3><a name="section-A.55">A.55 <code><nobr>FFREEP</nobr></code>: Flag Floating-Point Register as Unused and Pop</a></h3>
<p><pre>
FFREEP fpureg                 ; DF C0+r              [P6,FPU,UNDOC]
</pre>
<p><code><nobr>FFREEP</nobr></code> marks the given register as being
empty, and then pops <code><nobr>ST0</nobr></code>.
<h3><a name="section-A.56">A.56 <code><nobr>FIADD</nobr></code>: Floating-Point/Integer Addition</a></h3>
<p><pre>
FIADD mem16                   ; DE /0                [8086,FPU] 
FIADD mem32                   ; DA /0                [8086,FPU]
</pre>
<p><code><nobr>FIADD</nobr></code> adds the 16-bit or 32-bit integer stored
in the given memory location to <code><nobr>ST0</nobr></code>, storing the
result in <code><nobr>ST0</nobr></code>.
<h3><a name="section-A.57">A.57 <code><nobr>FICOM</nobr></code>, <code><nobr>FICOMP</nobr></code>: Floating-Point/Integer Compare</a></h3>
<p><pre>
FICOM mem16                   ; DE /2                [8086,FPU] 
FICOM mem32                   ; DA /2                [8086,FPU]
</pre>
<p><pre>
FICOMP mem16                  ; DE /3                [8086,FPU] 
FICOMP mem32                  ; DA /3                [8086,FPU]
</pre>
<p><code><nobr>FICOM</nobr></code> compares <code><nobr>ST0</nobr></code>
with the 16-bit or 32-bit integer stored in the given memory location, and
sets the FPU flags accordingly. <code><nobr>FICOMP</nobr></code> does the
same, but pops the register stack afterwards.
<h3><a name="section-A.58">A.58 <code><nobr>FIDIV</nobr></code>, <code><nobr>FIDIVR</nobr></code>: Floating-Point/Integer Division</a></h3>
<p><pre>
FIDIV mem16                   ; DE /6                [8086,FPU] 
FIDIV mem32                   ; DA /6                [8086,FPU]
</pre>
<p><pre>
FIDIVR mem16                  ; DE /0                [8086,FPU] 
FIDIVR mem32                  ; DA /0                [8086,FPU]
</pre>
<p><code><nobr>FIDIV</nobr></code> divides <code><nobr>ST0</nobr></code> by
the 16-bit or 32-bit integer stored in the given memory location, and
stores the result in <code><nobr>ST0</nobr></code>.
<code><nobr>FIDIVR</nobr></code> does the division the other way up: it
divides the integer by <code><nobr>ST0</nobr></code>, but still stores the
result in <code><nobr>ST0</nobr></code>.
<h3><a name="section-A.59">A.59 <code><nobr>FILD</nobr></code>, <code><nobr>FIST</nobr></code>, <code><nobr>FISTP</nobr></code>: Floating-Point/Integer Conversion</a></h3>
<p><pre>
FILD mem16                    ; DF /0                [8086,FPU] 
FILD mem32                    ; DB /0                [8086,FPU] 
FILD mem64                    ; DF /5                [8086,FPU]
</pre>
<p><pre>
FIST mem16                    ; DF /2                [8086,FPU] 
FIST mem32                    ; DB /2                [8086,FPU]
</pre>
<p><pre>
FISTP mem16                   ; DF /3                [8086,FPU] 
FISTP mem32                   ; DB /3                [8086,FPU] 
FISTP mem64                   ; DF /0                [8086,FPU]
</pre>
<p><code><nobr>FILD</nobr></code> loads an integer out of a memory
location, converts it to a real, and pushes it on the FPU register stack.
<code><nobr>FIST</nobr></code> converts <code><nobr>ST0</nobr></code> to an
integer and stores that in memory; <code><nobr>FISTP</nobr></code> does the
same as <code><nobr>FIST</nobr></code>, but pops the register stack
afterwards.
<h3><a name="section-A.60">A.60 <code><nobr>FIMUL</nobr></code>: Floating-Point/Integer Multiplication</a></h3>
<p><pre>
FIMUL mem16                   ; DE /1                [8086,FPU] 
FIMUL mem32                   ; DA /1                [8086,FPU]
</pre>
<p><code><nobr>FIMUL</nobr></code> multiplies <code><nobr>ST0</nobr></code>
by the 16-bit or 32-bit integer stored in the given memory location, and
stores the result in <code><nobr>ST0</nobr></code>.
<h3><a name="section-A.61">A.61 <code><nobr>FINCSTP</nobr></code>: Increment Floating-Point Stack Pointer</a></h3>
<p><pre>
FINCSTP                       ; D9 F7                [8086,FPU]
</pre>
<p><code><nobr>FINCSTP</nobr></code> increments the `top' field in the
floating-point status word. This has the effect of rotating the FPU
register stack by one, as if the register stack had been popped; however,
unlike the popping of the stack performed by many FPU instructions, it does
not flag the new <code><nobr>ST7</nobr></code> (previously
<code><nobr>ST0</nobr></code>) as empty. See also
<code><nobr>FDECSTP</nobr></code> (<a href="#section-A.50">section
A.50</a>).
<h3><a name="section-A.62">A.62 <code><nobr>FINIT</nobr></code>, <code><nobr>FNINIT</nobr></code>: Initialise Floating-Point Unit</a></h3>
<p><pre>
FINIT                         ; 9B DB E3             [8086,FPU] 
FNINIT                        ; DB E3                [8086,FPU]
</pre>
<p><code><nobr>FINIT</nobr></code> initialises the FPU to its default
state. It flags all registers as empty, though it does not actually change
their values. <code><nobr>FNINIT</nobr></code> does the same, without first
waiting for pending exceptions to clear.
<h3><a name="section-A.63">A.63 <code><nobr>FISUB</nobr></code>: Floating-Point/Integer Subtraction</a></h3>
<p><pre>
FISUB mem16                   ; DE /4                [8086,FPU] 
FISUB mem32                   ; DA /4                [8086,FPU]
</pre>
<p><pre>
FISUBR mem16                  ; DE /5                [8086,FPU] 
FISUBR mem32                  ; DA /5                [8086,FPU]
</pre>
<p><code><nobr>FISUB</nobr></code> subtracts the 16-bit or 32-bit integer
stored in the given memory location from <code><nobr>ST0</nobr></code>, and
stores the result in <code><nobr>ST0</nobr></code>.
<code><nobr>FISUBR</nobr></code> does the subtraction the other way round,
i.e. it subtracts <code><nobr>ST0</nobr></code> from the given integer, but
still stores the result in <code><nobr>ST0</nobr></code>.
<h3><a name="section-A.64">A.64 <code><nobr>FLD</nobr></code>: Floating-Point Load</a></h3>
<p><pre>
FLD mem32                     ; D9 /0                [8086,FPU] 
FLD mem64                     ; DD /0                [8086,FPU] 
FLD mem80                     ; DB /5                [8086,FPU] 
FLD fpureg                    ; D9 C0+r              [8086,FPU]
</pre>
<p><code><nobr>FLD</nobr></code> loads a floating-point value out of the
given register or memory location, and pushes it on the FPU register stack.
<h3><a name="section-A.65">A.65 <code><nobr>FLDxx</nobr></code>: Floating-Point Load Constants</a></h3>
<p><pre>
FLD1                          ; D9 E8                [8086,FPU] 
FLDL2E                        ; D9 EA                [8086,FPU] 
FLDL2T                        ; D9 E9                [8086,FPU] 
FLDLG2                        ; D9 EC                [8086,FPU] 
FLDLN2                        ; D9 ED                [8086,FPU] 
FLDPI                         ; D9 EB                [8086,FPU] 
FLDZ                          ; D9 EE                [8086,FPU]
</pre>
<p>These instructions push specific standard constants on the FPU register
stack. <code><nobr>FLD1</nobr></code> pushes the value 1;
<code><nobr>FLDL2E</nobr></code> pushes the base-2 logarithm of e;
<code><nobr>FLDL2T</nobr></code> pushes the base-2 log of 10;
<code><nobr>FLDLG2</nobr></code> pushes the base-10 log of 2;
<code><nobr>FLDLN2</nobr></code> pushes the base-e log of 2;
<code><nobr>FLDPI</nobr></code> pushes pi; and
<code><nobr>FLDZ</nobr></code> pushes zero.
<h3><a name="section-A.66">A.66 <code><nobr>FLDCW</nobr></code>: Load Floating-Point Control Word</a></h3>
<p><pre>
FLDCW mem16                   ; D9 /5                [8086,FPU]
</pre>
<p><code><nobr>FLDCW</nobr></code> loads a 16-bit value out of memory and
stores it into the FPU control word (governing things like the rounding
mode, the precision, and the exception masks). See also
<code><nobr>FSTCW</nobr></code> (<a href="#section-A.79">section A.79</a>).
<h3><a name="section-A.67">A.67 <code><nobr>FLDENV</nobr></code>: Load Floating-Point Environment</a></h3>
<p><pre>
FLDENV mem                    ; D9 /4                [8086,FPU]
</pre>
<p><code><nobr>FLDENV</nobr></code> loads the FPU operating environment
(control word, status word, tag word, instruction pointer, data pointer and
last opcode) from memory. The memory area is 14 or 28 bytes long, depending
on the CPU mode at the time. See also <code><nobr>FSTENV</nobr></code>
(<a href="#section-A.80">section A.80</a>).
<h3><a name="section-A.68">A.68 <code><nobr>FMUL</nobr></code>, <code><nobr>FMULP</nobr></code>: Floating-Point Multiply</a></h3>
<p><pre>
FMUL mem32                    ; D8 /1                [8086,FPU] 
FMUL mem64                    ; DC /1                [8086,FPU]
</pre>
<p><pre>
FMUL fpureg                   ; D8 C8+r              [8086,FPU] 
FMUL ST0,fpureg               ; D8 C8+r              [8086,FPU]
</pre>
<p><pre>
FMUL TO fpureg                ; DC C8+r              [8086,FPU] 
FMUL fpureg,ST0               ; DC C8+r              [8086,FPU]
</pre>
<p><pre>
FMULP fpureg                  ; DE C8+r              [8086,FPU] 
FMULP fpureg,ST0              ; DE C8+r              [8086,FPU]
</pre>
<p><code><nobr>FMUL</nobr></code> multiplies <code><nobr>ST0</nobr></code>
by the given operand, and stores the result in
<code><nobr>ST0</nobr></code>, unless the <code><nobr>TO</nobr></code>
qualifier is used in which case it stores the result in the operand.
<code><nobr>FMULP</nobr></code> performs the same operation as
<code><nobr>FMUL TO</nobr></code>, and then pops the register stack.
<h3><a name="section-A.69">A.69 <code><nobr>FNOP</nobr></code>: Floating-Point No Operation</a></h3>
<p><pre>
FNOP                          ; D9 D0                [8086,FPU]
</pre>
<p><code><nobr>FNOP</nobr></code> does nothing.
<h3><a name="section-A.70">A.70 <code><nobr>FPATAN</nobr></code>, <code><nobr>FPTAN</nobr></code>: Arctangent and Tangent</a></h3>
<p><pre>
FPATAN                        ; D9 F3                [8086,FPU] 
FPTAN                         ; D9 F2                [8086,FPU]
</pre>
<p><code><nobr>FPATAN</nobr></code> computes the arctangent, in radians, of
the result of dividing <code><nobr>ST1</nobr></code> by
<code><nobr>ST0</nobr></code>, stores the result in
<code><nobr>ST1</nobr></code>, and pops the register stack. It works like
the C <code><nobr>atan2</nobr></code> function, in that changing the sign
of both <code><nobr>ST0</nobr></code> and <code><nobr>ST1</nobr></code>
changes the output value by pi (so it performs true rectangular-to-polar
coordinate conversion, with <code><nobr>ST1</nobr></code> being the Y
coordinate and <code><nobr>ST0</nobr></code> being the X coordinate, not
merely an arctangent).
<p><code><nobr>FPTAN</nobr></code> computes the tangent of the value in
<code><nobr>ST0</nobr></code> (in radians), and stores the result back into
<code><nobr>ST0</nobr></code>.
<h3><a name="section-A.71">A.71 <code><nobr>FPREM</nobr></code>, <code><nobr>FPREM1</nobr></code>: Floating-Point Partial Remainder</a></h3>
<p><pre>
FPREM                         ; D9 F8                [8086,FPU] 
FPREM1                        ; D9 F5                [386,FPU]
</pre>
<p>These instructions both produce the remainder obtained by dividing
<code><nobr>ST0</nobr></code> by <code><nobr>ST1</nobr></code>. This is
calculated, notionally, by dividing <code><nobr>ST0</nobr></code> by
<code><nobr>ST1</nobr></code>, rounding the result to an integer,
multiplying by <code><nobr>ST1</nobr></code> again, and computing the value
which would need to be added back on to the result to get back to the
original value in <code><nobr>ST0</nobr></code>.
<p>The two instructions differ in the way the notional round-to-integer
operation is performed. <code><nobr>FPREM</nobr></code> does it by rounding
towards zero, so that the remainder it returns always has the same sign as
the original value in <code><nobr>ST0</nobr></code>;
<code><nobr>FPREM1</nobr></code> does it by rounding to the nearest
integer, so that the remainder always has at most half the magnitude of
<code><nobr>ST1</nobr></code>.
<p>Both instructions calculate <em>partial</em> remainders, meaning that
they may not manage to provide the final result, but might leave
intermediate results in <code><nobr>ST0</nobr></code> instead. If this
happens, they will set the C2 flag in the FPU status word; therefore, to
calculate a remainder, you should repeatedly execute
<code><nobr>FPREM</nobr></code> or <code><nobr>FPREM1</nobr></code> until
C2 becomes clear.
<h3><a name="section-A.72">A.72 <code><nobr>FRNDINT</nobr></code>: Floating-Point Round to Integer</a></h3>
<p><pre>
FRNDINT                       ; D9 FC                [8086,FPU]
</pre>
<p><code><nobr>FRNDINT</nobr></code> rounds the contents of
<code><nobr>ST0</nobr></code> to an integer, according to the current
rounding mode set in the FPU control word, and stores the result back in
<code><nobr>ST0</nobr></code>.
<h3><a name="section-A.73">A.73 <code><nobr>FSAVE</nobr></code>, <code><nobr>FRSTOR</nobr></code>: Save/Restore Floating-Point State</a></h3>
<p><pre>
FSAVE mem                     ; 9B DD /6             [8086,FPU] 
FNSAVE mem                    ; DD /6                [8086,FPU]
</pre>
<p><pre>
FRSTOR mem                    ; DD /4                [8086,FPU]
</pre>
<p><code><nobr>FSAVE</nobr></code> saves the entire floating-point unit
state, including all the information saved by
<code><nobr>FSTENV</nobr></code> (<a href="#section-A.80">section A.80</a>)
plus the contents of all the registers, to a 94 or 108 byte area of memory
(depending on the CPU mode). <code><nobr>FRSTOR</nobr></code> restores the
floating-point state from the same area of memory.
<p><code><nobr>FNSAVE</nobr></code> does the same as
<code><nobr>FSAVE</nobr></code>, without first waiting for pending
floating-point exceptions to clear.
<h3><a name="section-A.74">A.74 <code><nobr>FSCALE</nobr></code>: Scale Floating-Point Value by Power of Two</a></h3>
<p><pre>
FSCALE                        ; D9 FD                [8086,FPU]
</pre>
<p><code><nobr>FSCALE</nobr></code> scales a number by a power of two: it
rounds <code><nobr>ST1</nobr></code> towards zero to obtain an integer,
then multiplies <code><nobr>ST0</nobr></code> by two to the power of that
integer, and stores the result in <code><nobr>ST0</nobr></code>.
<h3><a name="section-A.75">A.75 <code><nobr>FSETPM</nobr></code>: Set Protected Mode</a></h3>
<p><pre>
FSETPM                        ; DB E4                [286,FPU]
</pre>
<p>This instruction initalises protected mode on the 287 floating-point
coprocessor. It is only meaningful on that processor: the 387 and above
treat the instruction as a no-operation.
<h3><a name="section-A.76">A.76 <code><nobr>FSIN</nobr></code>, <code><nobr>FSINCOS</nobr></code>: Sine and Cosine</a></h3>
<p><pre>
FSIN                          ; D9 FE                [386,FPU] 
FSINCOS                       ; D9 FB                [386,FPU]
</pre>
<p><code><nobr>FSIN</nobr></code> calculates the sine of
<code><nobr>ST0</nobr></code> (in radians) and stores the result in
<code><nobr>ST0</nobr></code>. <code><nobr>FSINCOS</nobr></code> does the
same, but then pushes the cosine of the same value on the register stack,
so that the sine ends up in <code><nobr>ST1</nobr></code> and the cosine in
<code><nobr>ST0</nobr></code>. <code><nobr>FSINCOS</nobr></code> is faster
than executing <code><nobr>FSIN</nobr></code> and
<code><nobr>FCOS</nobr></code> (see <a href="#section-A.49">section
A.49</a>) in succession.
<h3><a name="section-A.77">A.77 <code><nobr>FSQRT</nobr></code>: Floating-Point Square Root</a></h3>
<p><pre>
FSQRT                         ; D9 FA                [8086,FPU]
</pre>
<p><code><nobr>FSQRT</nobr></code> calculates the square root of
<code><nobr>ST0</nobr></code> and stores the result in
<code><nobr>ST0</nobr></code>.
<h3><a name="section-A.78">A.78 <code><nobr>FST</nobr></code>, <code><nobr>FSTP</nobr></code>: Floating-Point Store</a></h3>
<p><pre>
FST mem32                     ; D9 /2                [8086,FPU] 
FST mem64                     ; DD /2                [8086,FPU] 
FST fpureg                    ; DD D0+r              [8086,FPU]
</pre>
<p><pre>
FSTP mem32                    ; D9 /3                [8086,FPU] 
FSTP mem64                    ; DD /3                [8086,FPU] 
FSTP mem80                    ; DB /0                [8086,FPU] 
FSTP fpureg                   ; DD D8+r              [8086,FPU]
</pre>
<p><code><nobr>FST</nobr></code> stores the value in
<code><nobr>ST0</nobr></code> into the given memory location or other FPU
register. <code><nobr>FSTP</nobr></code> does the same, but then pops the
register stack.
<h3><a name="section-A.79">A.79 <code><nobr>FSTCW</nobr></code>: Store Floating-Point Control Word</a></h3>
<p><pre>
FSTCW mem16                   ; 9B D9 /0             [8086,FPU] 
FNSTCW mem16                  ; D9 /0                [8086,FPU]
</pre>
<p><code><nobr>FSTCW</nobr></code> stores the FPU control word (governing
things like the rounding mode, the precision, and the exception masks) into
a 2-byte memory area. See also <code><nobr>FLDCW</nobr></code>
(<a href="#section-A.66">section A.66</a>).
<p><code><nobr>FNSTCW</nobr></code> does the same thing as
<code><nobr>FSTCW</nobr></code>, without first waiting for pending
floating-point exceptions to clear.
<h3><a name="section-A.80">A.80 <code><nobr>FSTENV</nobr></code>: Store Floating-Point Environment</a></h3>
<p><pre>
FSTENV mem                    ; 9B D9 /6             [8086,FPU] 
FNSTENV mem                   ; D9 /6                [8086,FPU]
</pre>
<p><code><nobr>FSTENV</nobr></code> stores the FPU operating environment
(control word, status word, tag word, instruction pointer, data pointer and
last opcode) into memory. The memory area is 14 or 28 bytes long, depending
on the CPU mode at the time. See also <code><nobr>FLDENV</nobr></code>
(<a href="#section-A.67">section A.67</a>).
<p><code><nobr>FNSTENV</nobr></code> does the same thing as
<code><nobr>FSTENV</nobr></code>, without first waiting for pending
floating-point exceptions to clear.
<h3><a name="section-A.81">A.81 <code><nobr>FSTSW</nobr></code>: Store Floating-Point Status Word</a></h3>
<p><pre>
FSTSW mem16                   ; 9B DD /0             [8086,FPU] 
FSTSW AX                      ; 9B DF E0             [286,FPU]
</pre>
<p><pre>
FNSTSW mem16                  ; DD /0                [8086,FPU] 
FNSTSW AX                     ; DF E0                [286,FPU]
</pre>
<p><code><nobr>FSTSW</nobr></code> stores the FPU status word into
<code><nobr>AX</nobr></code> or into a 2-byte memory area.
<p><code><nobr>FNSTSW</nobr></code> does the same thing as
<code><nobr>FSTSW</nobr></code>, without first waiting for pending
floating-point exceptions to clear.
<h3><a name="section-A.82">A.82 <code><nobr>FSUB</nobr></code>, <code><nobr>FSUBP</nobr></code>, <code><nobr>FSUBR</nobr></code>, <code><nobr>FSUBRP</nobr></code>: Floating-Point Subtract</a></h3>
<p><pre>
FSUB mem32                    ; D8 /4                [8086,FPU] 
FSUB mem64                    ; DC /4                [8086,FPU]
</pre>
<p><pre>
FSUB fpureg                   ; D8 E0+r              [8086,FPU] 
FSUB ST0,fpureg               ; D8 E0+r              [8086,FPU]
</pre>
<p><pre>
FSUB TO fpureg                ; DC E8+r              [8086,FPU] 
FSUB fpureg,ST0               ; DC E8+r              [8086,FPU]
</pre>
<p><pre>
FSUBR mem32                   ; D8 /5                [8086,FPU] 
FSUBR mem64                   ; DC /5                [8086,FPU]
</pre>
<p><pre>
FSUBR fpureg                  ; D8 E8+r              [8086,FPU] 
FSUBR ST0,fpureg              ; D8 E8+r              [8086,FPU]
</pre>
<p><pre>
FSUBR TO fpureg               ; DC E0+r              [8086,FPU] 
FSUBR fpureg,ST0              ; DC E0+r              [8086,FPU]
</pre>
<p><pre>
FSUBP fpureg                  ; DE E8+r              [8086,FPU] 
FSUBP fpureg,ST0              ; DE E8+r              [8086,FPU]
</pre>
<p><pre>
FSUBRP fpureg                 ; DE E0+r              [8086,FPU] 
FSUBRP fpureg,ST0             ; DE E0+r              [8086,FPU]
</pre>
<p><code><nobr>FSUB</nobr></code> subtracts the given operand from
<code><nobr>ST0</nobr></code> and stores the result back in
<code><nobr>ST0</nobr></code>, unless the <code><nobr>TO</nobr></code>
qualifier is given, in which case it subtracts
<code><nobr>ST0</nobr></code> from the given operand and stores the result
in the operand.
<p><code><nobr>FSUBR</nobr></code> does the same thing, but does the
subtraction the other way up: so if <code><nobr>TO</nobr></code> is not
given, it subtracts <code><nobr>ST0</nobr></code> from the given operand
and stores the result in <code><nobr>ST0</nobr></code>, whereas if
<code><nobr>TO</nobr></code> is given it subtracts its operand from
<code><nobr>ST0</nobr></code> and stores the result in the operand.
<p><code><nobr>FSUBP</nobr></code> operates like
<code><nobr>FSUB TO</nobr></code>, but pops the register stack once it has
finished. <code><nobr>FSUBRP</nobr></code> operates like
<code><nobr>FSUBR TO</nobr></code>, but pops the register stack once it has
finished.
<h3><a name="section-A.83">A.83 <code><nobr>FTST</nobr></code>: Test <code><nobr>ST0</nobr></code> Against Zero</a></h3>
<p><pre>
FTST                          ; D9 E4                [8086,FPU]
</pre>
<p><code><nobr>FTST</nobr></code> compares <code><nobr>ST0</nobr></code>
with zero and sets the FPU flags accordingly. <code><nobr>ST0</nobr></code>
is treated as the left-hand side of the comparison, so that a `less-than'
result is generated if <code><nobr>ST0</nobr></code> is negative.
<h3><a name="section-A.84">A.84 <code><nobr>FUCOMxx</nobr></code>: Floating-Point Unordered Compare</a></h3>
<p><pre>
FUCOM fpureg                  ; DD E0+r              [386,FPU] 
FUCOM ST0,fpureg              ; DD E0+r              [386,FPU]
</pre>
<p><pre>
FUCOMP fpureg                 ; DD E8+r              [386,FPU] 
FUCOMP ST0,fpureg             ; DD E8+r              [386,FPU]
</pre>
<p><pre>
FUCOMPP                       ; DA E9                [386,FPU]
</pre>
<p><pre>
FUCOMI fpureg                 ; DB E8+r              [P6,FPU] 
FUCOMI ST0,fpureg             ; DB E8+r              [P6,FPU]
</pre>
<p><pre>
FUCOMIP fpureg                ; DF E8+r              [P6,FPU] 
FUCOMIP ST0,fpureg            ; DF E8+r              [P6,FPU]
</pre>
<p><code><nobr>FUCOM</nobr></code> compares <code><nobr>ST0</nobr></code>
with the given operand, and sets the FPU flags accordingly.
<code><nobr>ST0</nobr></code> is treated as the left-hand side of the
comparison, so that the carry flag is set (for a `less-than' result) if
<code><nobr>ST0</nobr></code> is less than the given operand.
<p><code><nobr>FUCOMP</nobr></code> does the same as
<code><nobr>FUCOM</nobr></code>, but pops the register stack afterwards.
<code><nobr>FUCOMPP</nobr></code> compares <code><nobr>ST0</nobr></code>
with <code><nobr>ST1</nobr></code> and then pops the register stack twice.
<p><code><nobr>FUCOMI</nobr></code> and <code><nobr>FUCOMIP</nobr></code>
work like the corresponding forms of <code><nobr>FUCOM</nobr></code> and
<code><nobr>FUCOMP</nobr></code>, but write their results directly to the
CPU flags register rather than the FPU status word, so they can be
immediately followed by conditional jump or conditional move instructions.
<p>The <code><nobr>FUCOM</nobr></code> instructions differ from the
<code><nobr>FCOM</nobr></code> instructions
(<a href="#section-A.48">section A.48</a>) only in the way they handle
quiet NaNs: <code><nobr>FUCOM</nobr></code> will handle them silently and
set the condition code flags to an `unordered' result, whereas
<code><nobr>FCOM</nobr></code> will generate an exception.
<h3><a name="section-A.85">A.85 <code><nobr>FWAIT</nobr></code>: Wait for Floating-Point Processor</a></h3>
<p><pre>
FWAIT                         ; 9B                   [8086]
</pre>
<p><code><nobr>FWAIT</nobr></code> is a synonym of
<code><nobr>WAIT</nobr></code> (<a href="#section-A.262">section
A.262</a>).
<h3><a name="section-A.86">A.86 <code><nobr>FXAM</nobr></code>: Examine Class of Value in <code><nobr>ST0</nobr></code></a></h3>
<p><pre>
FXAM                          ; D9 E5                [8086,FPU]
</pre>
<p><code><nobr>FXAM</nobr></code> sets the FPU flags C3, C2 and C0
depending on the type of value stored in <code><nobr>ST0</nobr></code>: 000
(respectively) for an unsupported format, 001 for a NaN, 010 for a normal
finite number, 011 for an infinity, 100 for a zero, 101 for an empty
register, and 110 for a denormal. It also sets the C1 flag to the sign of
the number.
<h3><a name="section-A.87">A.87 <code><nobr>FXCH</nobr></code>: Floating-Point Exchange</a></h3>
<p><pre>
FXCH                          ; D9 C9                [8086,FPU] 
FXCH fpureg                   ; D9 C8+r              [8086,FPU] 
FXCH fpureg,ST0               ; D9 C8+r              [8086,FPU] 
FXCH ST0,fpureg               ; D9 C8+r              [8086,FPU]
</pre>
<p><code><nobr>FXCH</nobr></code> exchanges <code><nobr>ST0</nobr></code>
with a given FPU register. The no-operand form exchanges
<code><nobr>ST0</nobr></code> with <code><nobr>ST1</nobr></code>.
<h3><a name="section-A.88">A.88 <code><nobr>FXRSTOR</nobr></code>: Restore FP, MMX and SSE States</a></h3>
<p><pre>
FXRSTOR m512byte              ; 0F AE /1             [P6,SSE,FPU]
</pre>
<p><code><nobr>FXRSTOR</nobr></code> reloads the FP and MMX state, and the
SSE state (environment and registers), from the memory area defined by
m512byte. This data should have been written by a previous
<code><nobr>FXSAVE</nobr></code>.
<h3><a name="section-A.89">A.89 <code><nobr>FXSAVE</nobr></code>: Store FP and MMX State and Streaming SIMD</a></h3>
<p><pre>
FXSAVE m512byte               ; 0F AE /0             [P6,SSE,FPU]
</pre>
<p><code><nobr>FXSAVE</nobr></code> writes the current FP and MMX state,
and SSE state (environment and registers), to the specified destination
defined by m512byte. It does this without checking for pending unmasked
floating-point exceptions (similar to the operation of
<code><nobr>FNSAVE</nobr></code>). Unlike the
<code><nobr>FSAVE</nobr></code>/<code><nobr>FNSAVE</nobr></code>
instructions, the processor retains the contents of the FP and MMX state
and Streaming SIMD Extension state in the processor after the state has
been saved. This instruction has been optimized to maximize floating-point
save performance.
<h3><a name="section-A.90">A.90 <code><nobr>FXTRACT</nobr></code>: Extract Exponent and Significand</a></h3>
<p><pre>
FXTRACT                       ; D9 F4                [8086,FPU]
</pre>
<p><code><nobr>FXTRACT</nobr></code> separates the number in
<code><nobr>ST0</nobr></code> into its exponent and significand (mantissa),
stores the exponent back into <code><nobr>ST0</nobr></code>, and then
pushes the significand on the register stack (so that the significand ends
up in <code><nobr>ST0</nobr></code>, and the exponent in
<code><nobr>ST1</nobr></code>).
<h3><a name="section-A.91">A.91 <code><nobr>FYL2X</nobr></code>, <code><nobr>FYL2XP1</nobr></code>: Compute Y times Log2(X) or Log2(X+1)</a></h3>
<p><pre>
FYL2X                         ; D9 F1                [8086,FPU] 
FYL2XP1                       ; D9 F9                [8086,FPU]
</pre>
<p><code><nobr>FYL2X</nobr></code> multiplies <code><nobr>ST1</nobr></code>
by the base-2 logarithm of <code><nobr>ST0</nobr></code>, stores the result
in <code><nobr>ST1</nobr></code>, and pops the register stack (so that the
result ends up in <code><nobr>ST0</nobr></code>).
<code><nobr>ST0</nobr></code> must be non-zero and positive.
<p><code><nobr>FYL2XP1</nobr></code> works the same way, but replacing the
base-2 log of <code><nobr>ST0</nobr></code> with that of
<code><nobr>ST0</nobr></code> plus one. This time,
<code><nobr>ST0</nobr></code> must have magnitude no greater than 1 minus
half the square root of two.
<h3><a name="section-A.92">A.92 <code><nobr>HLT</nobr></code>: Halt Processor</a></h3>
<p><pre>
HLT                           ; F4                   [8086]
</pre>
<p><code><nobr>HLT</nobr></code> puts the processor into a halted state,
where it will perform no more operations until restarted by an interrupt or
a reset.
<h3><a name="section-A.93">A.93 <code><nobr>IBTS</nobr></code>: Insert Bit String</a></h3>
<p><pre>
IBTS r/m16,reg16              ; o16 0F A7 /r         [386,UNDOC] 
IBTS r/m32,reg32              ; o32 0F A7 /r         [386,UNDOC]
</pre>
<p>No clear documentation seems to be available for this instruction: the
best I've been able to find reads `Takes a string of bits from the second
operand and puts them in the first operand'. It is present only in early
386 processors, and conflicts with the opcodes for
<code><nobr>CMPXCHG486</nobr></code>. NASM supports it only for
completeness. Its counterpart is <code><nobr>XBTS</nobr></code> (see
<a href="#section-A.267">section A.267</a>).
<h3><a name="section-A.94">A.94 <code><nobr>IDIV</nobr></code>: Signed Integer Divide</a></h3>
<p><pre>
IDIV r/m8                     ; F6 /7                [8086] 
IDIV r/m16                    ; o16 F7 /7            [8086] 
IDIV r/m32                    ; o32 F7 /7            [386]
</pre>
<p><code><nobr>IDIV</nobr></code> performs signed integer division. The
explicit operand provided is the divisor; the dividend and destination
operands are implicit, in the following way:
<ul>
<li>For <code><nobr>IDIV r/m8</nobr></code>, <code><nobr>AX</nobr></code>
is divided by the given operand; the quotient is stored in
<code><nobr>AL</nobr></code> and the remainder in
<code><nobr>AH</nobr></code>.
<li>For <code><nobr>IDIV r/m16</nobr></code>,
<code><nobr>DX:AX</nobr></code> is divided by the given operand; the
quotient is stored in <code><nobr>AX</nobr></code> and the remainder in
<code><nobr>DX</nobr></code>.
<li>For <code><nobr>IDIV r/m32</nobr></code>,
<code><nobr>EDX:EAX</nobr></code> is divided by the given operand; the
quotient is stored in <code><nobr>EAX</nobr></code> and the remainder in
<code><nobr>EDX</nobr></code>.
</ul>
<p>Unsigned integer division is performed by the
<code><nobr>DIV</nobr></code> instruction: see
<a href="#section-A.36">section A.36</a>.
<h3><a name="section-A.95">A.95 <code><nobr>IMUL</nobr></code>: Signed Integer Multiply</a></h3>
<p><pre>
IMUL r/m8                     ; F6 /5                [8086] 
IMUL r/m16                    ; o16 F7 /5            [8086] 
IMUL r/m32                    ; o32 F7 /5            [386]
</pre>
<p><pre>
IMUL reg16,r/m16              ; o16 0F AF /r         [386] 
IMUL reg32,r/m32              ; o32 0F AF /r         [386]
</pre>
<p><pre>
IMUL reg16,imm8               ; o16 6B /r ib         [286] 
IMUL reg16,imm16              ; o16 69 /r iw         [286] 
IMUL reg32,imm8               ; o32 6B /r ib         [386] 
IMUL reg32,imm32              ; o32 69 /r id         [386]
</pre>
<p><pre>
IMUL reg16,r/m16,imm8         ; o16 6B /r ib         [286] 
IMUL reg16,r/m16,imm16        ; o16 69 /r iw         [286] 
IMUL reg32,r/m32,imm8         ; o32 6B /r ib         [386] 
IMUL reg32,r/m32,imm32        ; o32 69 /r id         [386]
</pre>
<p><code><nobr>IMUL</nobr></code> performs signed integer multiplication.
For the single-operand form, the other operand and destination are
implicit, in the following way:
<ul>
<li>For <code><nobr>IMUL r/m8</nobr></code>, <code><nobr>AL</nobr></code>
is multiplied by the given operand; the product is stored in
<code><nobr>AX</nobr></code>.
<li>For <code><nobr>IMUL r/m16</nobr></code>, <code><nobr>AX</nobr></code>
is multiplied by the given operand; the product is stored in
<code><nobr>DX:AX</nobr></code>.
<li>For <code><nobr>IMUL r/m32</nobr></code>, <code><nobr>EAX</nobr></code>
is multiplied by the given operand; the product is stored in
<code><nobr>EDX:EAX</nobr></code>.
</ul>
<p>The two-operand form multiplies its two operands and stores the result
in the destination (first) operand. The three-operand form multiplies its
last two operands and stores the result in the first operand.
<p>The two-operand form is in fact a shorthand for the three-operand form,
as can be seen by examining the opcode descriptions: in the two-operand
form, the code <code><nobr>/r</nobr></code> takes both its register and
<code><nobr>r/m</nobr></code> parts from the same operand (the first one).
<p>In the forms with an 8-bit immediate operand and another longer source
operand, the immediate operand is considered to be signed, and is
sign-extended to the length of the other source operand. In these cases,
the <code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<p>Unsigned integer multiplication is performed by the
<code><nobr>MUL</nobr></code> instruction: see
<a href="#section-A.141">section A.141</a>.
<h3><a name="section-A.96">A.96 <code><nobr>IN</nobr></code>: Input from I/O Port</a></h3>
<p><pre>
IN AL,imm8                    ; E4 ib                [8086] 
IN AX,imm8                    ; o16 E5 ib            [8086] 
IN EAX,imm8                   ; o32 E5 ib            [386] 
IN AL,DX                      ; EC                   [8086] 
IN AX,DX                      ; o16 ED               [8086] 
IN EAX,DX                     ; o32 ED               [386]
</pre>
<p><code><nobr>IN</nobr></code> reads a byte, word or doubleword from the
specified I/O port, and stores it in the given destination register. The
port number may be specified as an immediate value if it is between 0 and
255, and otherwise must be stored in <code><nobr>DX</nobr></code>. See also
<code><nobr>OUT</nobr></code> (<a href="#section-A.148">section A.148</a>).
<h3><a name="section-A.97">A.97 <code><nobr>INC</nobr></code>: Increment Integer</a></h3>
<p><pre>
INC reg16                     ; o16 40+r             [8086] 
INC reg32                     ; o32 40+r             [386] 
INC r/m8                      ; FE /0                [8086] 
INC r/m16                     ; o16 FF /0            [8086] 
INC r/m32                     ; o32 FF /0            [386]
</pre>
<p><code><nobr>INC</nobr></code> adds 1 to its operand. It does
<em>not</em> affect the carry flag: to affect the carry flag, use
<code><nobr>ADD something,1</nobr></code> (see
<a href="#section-A.6">section A.6</a>). See also
<code><nobr>DEC</nobr></code> (<a href="#section-A.35">section A.35</a>).
<h3><a name="section-A.98">A.98 <code><nobr>INSB</nobr></code>, <code><nobr>INSW</nobr></code>, <code><nobr>INSD</nobr></code>: Input String from I/O Port</a></h3>
<p><pre>
INSB                          ; 6C                   [186] 
INSW                          ; o16 6D               [186] 
INSD                          ; o32 6D               [386]
</pre>
<p><code><nobr>INSB</nobr></code> inputs a byte from the I/O port specified
in <code><nobr>DX</nobr></code> and stores it at
<code><nobr>[ES:DI]</nobr></code> or <code><nobr>[ES:EDI]</nobr></code>. It
then increments or decrements (depending on the direction flag: increments
if the flag is clear, decrements if it is set) <code><nobr>DI</nobr></code>
or <code><nobr>EDI</nobr></code>.
<p>The register used is <code><nobr>DI</nobr></code> if the address size is
16 bits, and <code><nobr>EDI</nobr></code> if it is 32 bits. If you need to
use an address size not equal to the current <code><nobr>BITS</nobr></code>
setting, you can use an explicit <code><nobr>a16</nobr></code> or
<code><nobr>a32</nobr></code> prefix.
<p>Segment override prefixes have no effect for this instruction: the use
of <code><nobr>ES</nobr></code> for the load from
<code><nobr>[DI]</nobr></code> or <code><nobr>[EDI]</nobr></code> cannot be
overridden.
<p><code><nobr>INSW</nobr></code> and <code><nobr>INSD</nobr></code> work
in the same way, but they input a word or a doubleword instead of a byte,
and increment or decrement the addressing register by 2 or 4 instead of 1.
<p>The <code><nobr>REP</nobr></code> prefix may be used to repeat the
instruction <code><nobr>CX</nobr></code> (or <code><nobr>ECX</nobr></code>
- again, the address size chooses which) times.
<p>See also <code><nobr>OUTSB</nobr></code>,
<code><nobr>OUTSW</nobr></code> and <code><nobr>OUTSD</nobr></code>
(<a href="#section-A.149">section A.149</a>).
<h3><a name="section-A.99">A.99 <code><nobr>INT</nobr></code>: Software Interrupt</a></h3>
<p><pre>
INT imm8                      ; CD ib                [8086]
</pre>
<p><code><nobr>INT</nobr></code> causes a software interrupt through a
specified vector number from 0 to 255.
<p>The code generated by the <code><nobr>INT</nobr></code> instruction is
always two bytes long: although there are short forms for some
<code><nobr>INT</nobr></code> instructions, NASM does not generate them
when it sees the <code><nobr>INT</nobr></code> mnemonic. In order to
generate single-byte breakpoint instructions, use the
<code><nobr>INT3</nobr></code> or <code><nobr>INT1</nobr></code>
instructions (see <a href="#section-A.100">section A.100</a>) instead.
<h3><a name="section-A.100">A.100 <code><nobr>INT3</nobr></code>, <code><nobr>INT1</nobr></code>, <code><nobr>ICEBP</nobr></code>, <code><nobr>INT01</nobr></code>: Breakpoints</a></h3>
<p><pre>
INT1                          ; F1                   [P6] 
ICEBP                         ; F1                   [P6] 
INT01                         ; F1                   [P6]
</pre>
<p><pre>
INT3                          ; CC                   [8086] 
INT03                         ; CC                   [8086]
</pre>
<p><code><nobr>INT1</nobr></code> and <code><nobr>INT3</nobr></code> are
short one-byte forms of the instructions <code><nobr>INT 1</nobr></code>
and <code><nobr>INT 3</nobr></code> (see <a href="#section-A.99">section
A.99</a>). They perform a similar function to their longer counterparts,
but take up less code space. They are used as breakpoints by debuggers.
<p><code><nobr>INT1</nobr></code>, and its alternative synonyms
<code><nobr>INT01</nobr></code> and <code><nobr>ICEBP</nobr></code>, is an
instruction used by in-circuit emulators (ICEs). It is present, though not
documented, on some processors down to the 286, but is only documented for
the Pentium Pro. <code><nobr>INT3</nobr></code> is the instruction normally
used as a breakpoint by debuggers.
<p><code><nobr>INT3</nobr></code>, and its synonym
<code><nobr>INT03</nobr></code>, is not precisely equivalent
to<code><nobr>INT 3</nobr></code>: the short form, since it is designed to
be used as a breakpoint, bypasses the normal IOPL checks in virtual-8086
mode, and also does not go through interrupt redirection.
<h3><a name="section-A.101">A.101 <code><nobr>INTO</nobr></code>: Interrupt if Overflow</a></h3>
<p><pre>
INTO                          ; CE                   [8086]
</pre>
<p><code><nobr>INTO</nobr></code> performs an
<code><nobr>INT 4</nobr></code> software interrupt (see
<a href="#section-A.99">section A.99</a>) if and only if the overflow flag
is set.
<h3><a name="section-A.102">A.102 <code><nobr>INVD</nobr></code>: Invalidate Internal Caches</a></h3>
<p><pre>
INVD                          ; 0F 08                [486]
</pre>
<p><code><nobr>INVD</nobr></code> invalidates and empties the processor's
internal caches, and causes the processor to instruct external caches to do
the same. It does not write the contents of the caches back to memory
first: any modified data held in the caches will be lost. To write the data
back first, use <code><nobr>WBINVD</nobr></code>
(<a href="#section-A.263">section A.263</a>).
<h3><a name="section-A.103">A.103 <code><nobr>INVLPG</nobr></code>: Invalidate TLB Entry</a></h3>
<p><pre>
INVLPG mem                    ; 0F 01 /0             [486]
</pre>
<p><code><nobr>INVLPG</nobr></code> invalidates the translation lookahead
buffer (TLB) entry associated with the supplied memory address.
<h3><a name="section-A.104">A.104 <code><nobr>IRET</nobr></code>, <code><nobr>IRETW</nobr></code>, <code><nobr>IRETD</nobr></code>: Return from Interrupt</a></h3>
<p><pre>
IRET                          ; CF                   [8086] 
IRETW                         ; o16 CF               [8086] 
IRETD                         ; o32 CF               [386]
</pre>
<p><code><nobr>IRET</nobr></code> returns from an interrupt (hardware or
software) by means of popping <code><nobr>IP</nobr></code> (or
<code><nobr>EIP</nobr></code>), <code><nobr>CS</nobr></code> and the flags
off the stack and then continuing execution from the new
<code><nobr>CS:IP</nobr></code>.
<p><code><nobr>IRETW</nobr></code> pops <code><nobr>IP</nobr></code>,
<code><nobr>CS</nobr></code> and the flags as 2 bytes each, taking 6 bytes
off the stack in total. <code><nobr>IRETD</nobr></code> pops
<code><nobr>EIP</nobr></code> as 4 bytes, pops a further 4 bytes of which
the top two are discarded and the bottom two go into
<code><nobr>CS</nobr></code>, and pops the flags as 4 bytes as well, taking
12 bytes off the stack.
<p><code><nobr>IRET</nobr></code> is a shorthand for either
<code><nobr>IRETW</nobr></code> or <code><nobr>IRETD</nobr></code>,
depending on the default <code><nobr>BITS</nobr></code> setting at the
time.
<h3><a name="section-A.105">A.105 <code><nobr>JCXZ</nobr></code>, <code><nobr>JECXZ</nobr></code>: Jump if CX/ECX Zero</a></h3>
<p><pre>
JCXZ imm                      ; o16 E3 rb            [8086] 
JECXZ imm                     ; o32 E3 rb            [386]
</pre>
<p><code><nobr>JCXZ</nobr></code> performs a short jump (with maximum range
128 bytes) if and only if the contents of the <code><nobr>CX</nobr></code>
register is 0. <code><nobr>JECXZ</nobr></code> does the same thing, but
with <code><nobr>ECX</nobr></code>.
<h3><a name="section-A.106">A.106 <code><nobr>JMP</nobr></code>: Jump</a></h3>
<p><pre>
JMP imm                       ; E9 rw/rd             [8086] 
JMP SHORT imm                 ; EB rb                [8086] 
JMP imm:imm16                 ; o16 EA iw iw         [8086] 
JMP imm:imm32                 ; o32 EA id iw         [386] 
JMP FAR mem                   ; o16 FF /5            [8086] 
JMP FAR mem                   ; o32 FF /5            [386] 
JMP r/m16                     ; o16 FF /4            [8086] 
JMP r/m32                     ; o32 FF /4            [386]
</pre>
<p><code><nobr>JMP</nobr></code> jumps to a given address. The address may
be specified as an absolute segment and offset, or as a relative jump
within the current segment.
<p><code><nobr>JMP SHORT imm</nobr></code> has a maximum range of 128
bytes, since the displacement is specified as only 8 bits, but takes up
less code space. NASM does not choose when to generate
<code><nobr>JMP SHORT</nobr></code> for you: you must explicitly code
<code><nobr>SHORT</nobr></code> every time you want a short jump.
<p>You can choose between the two immediate far jump forms
(<code><nobr>JMP imm:imm</nobr></code>) by the use of the
<code><nobr>WORD</nobr></code> and <code><nobr>DWORD</nobr></code>
keywords: <code><nobr>JMP WORD 0x1234:0x5678</nobr></code>) or
<code><nobr>JMP DWORD 0x1234:0x56789abc</nobr></code>.
<p>The <code><nobr>JMP FAR mem</nobr></code> forms execute a far jump by
loading the destination address out of memory. The address loaded consists
of 16 or 32 bits of offset (depending on the operand size), and 16 bits of
segment. The operand size may be overridden using
<code><nobr>JMP WORD FAR mem</nobr></code> or
<code><nobr>JMP DWORD FAR mem</nobr></code>.
<p>The <code><nobr>JMP r/m</nobr></code> forms execute a near jump (within
the same segment), loading the destination address out of memory or out of
a register. The keyword <code><nobr>NEAR</nobr></code> may be specified,
for clarity, in these forms, but is not necessary. Again, operand size can
be overridden using <code><nobr>JMP WORD mem</nobr></code> or
<code><nobr>JMP DWORD mem</nobr></code>.
<p>As a convenience, NASM does not require you to jump to a far symbol by
coding the cumbersome <code><nobr>JMP SEG routine:routine</nobr></code>,
but instead allows the easier synonym
<code><nobr>JMP FAR routine</nobr></code>.
<p>The <code><nobr>CALL r/m</nobr></code> forms given above are near calls;
NASM will accept the <code><nobr>NEAR</nobr></code> keyword (e.g.
<code><nobr>CALL NEAR [address]</nobr></code>), even though it is not
strictly necessary.
<h3><a name="section-A.107">A.107 <code><nobr>Jcc</nobr></code>: Conditional Branch</a></h3>
<p><pre>
Jcc imm                       ; 70+cc rb             [8086] 
Jcc NEAR imm                  ; 0F 80+cc rw/rd       [386]
</pre>
<p>The conditional jump instructions execute a near (same segment) jump if
and only if their conditions are satisfied. For example,
<code><nobr>JNZ</nobr></code> jumps only if the zero flag is not set.
<p>The ordinary form of the instructions has only a 128-byte range; the
<code><nobr>NEAR</nobr></code> form is a 386 extension to the instruction
set, and can span the full size of a segment. NASM will not override your
choice of jump instruction: if you want <code><nobr>Jcc NEAR</nobr></code>,
you have to use the <code><nobr>NEAR</nobr></code> keyword.
<p>The <code><nobr>SHORT</nobr></code> keyword is allowed on the first form
of the instruction, for clarity, but is not necessary.
<h3><a name="section-A.108">A.108 <code><nobr>LAHF</nobr></code>: Load AH from Flags</a></h3>
<p><pre>
LAHF                          ; 9F                   [8086]
</pre>
<p><code><nobr>LAHF</nobr></code> sets the <code><nobr>AH</nobr></code>
register according to the contents of the low byte of the flags word. See
also <code><nobr>SAHF</nobr></code> (<a href="#section-A.225">section
A.225</a>).
<h3><a name="section-A.109">A.109 <code><nobr>LAR</nobr></code>: Load Access Rights</a></h3>
<p><pre>
LAR reg16,r/m16               ; o16 0F 02 /r         [286,PRIV] 
LAR reg32,r/m32               ; o32 0F 02 /r         [286,PRIV]
</pre>
<p><code><nobr>LAR</nobr></code> takes the segment selector specified by
its source (second) operand, finds the corresponding segment descriptor in
the GDT or LDT, and loads the access-rights byte of the descriptor into its
destination (first) operand.
<h3><a name="section-A.110">A.110 <code><nobr>LDS</nobr></code>, <code><nobr>LES</nobr></code>, <code><nobr>LFS</nobr></code>, <code><nobr>LGS</nobr></code>, <code><nobr>LSS</nobr></code>: Load Far Pointer</a></h3>
<p><pre>
LDS reg16,mem                 ; o16 C5 /r            [8086] 
LDS reg32,mem                 ; o32 C5 /r            [8086]
</pre>
<p><pre>
LES reg16,mem                 ; o16 C4 /r            [8086] 
LES reg32,mem                 ; o32 C4 /r            [8086]
</pre>
<p><pre>
LFS reg16,mem                 ; o16 0F B4 /r         [386] 
LFS reg32,mem                 ; o32 0F B4 /r         [386]
</pre>
<p><pre>
LGS reg16,mem                 ; o16 0F B5 /r         [386] 
LGS reg32,mem                 ; o32 0F B5 /r         [386]
</pre>
<p><pre>
LSS reg16,mem                 ; o16 0F B2 /r         [386] 
LSS reg32,mem                 ; o32 0F B2 /r         [386]
</pre>
<p>These instructions load an entire far pointer (16 or 32 bits of offset,
plus 16 bits of segment) out of memory in one go.
<code><nobr>LDS</nobr></code>, for example, loads 16 or 32 bits from the
given memory address into the given register (depending on the size of the
register), then loads the <em>next</em> 16 bits from memory into
<code><nobr>DS</nobr></code>. <code><nobr>LES</nobr></code>,
<code><nobr>LFS</nobr></code>, <code><nobr>LGS</nobr></code> and
<code><nobr>LSS</nobr></code> work in the same way but use the other
segment registers.
<h3><a name="section-A.111">A.111 <code><nobr>LDMXCSR</nobr></code>: SSE Load MXCSR</a></h3>
<p><pre>
LDMXCSR mem32                 ; 0F AE /2             [KATMAI,SSE]
</pre>
<p><code><nobr>LDMXCSR</nobr></code> loads a 32-bit value out of memory and
stores it into the MXCSR (the SSE control/status register).
<h3><a name="section-A.112">A.112 <code><nobr>LEA</nobr></code>: Load Effective Address</a></h3>
<p><pre>
LEA reg16,mem                 ; o16 8D /r            [8086] 
LEA reg32,mem                 ; o32 8D /r            [8086]
</pre>
<p><code><nobr>LEA</nobr></code>, despite its syntax, does not access
memory. It calculates the effective address specified by its second operand
as if it were going to load or store data from it, but instead it stores
the calculated address into the register specified by its first operand.
This can be used to perform quite complex calculations (e.g.
<code><nobr>LEA EAX,[EBX+ECX*4+100]</nobr></code>) in one instruction.
<p><code><nobr>LEA</nobr></code>, despite being a purely arithmetic
instruction which accesses no memory, still requires square brackets around
its second operand, as if it were a memory reference.
<h3><a name="section-A.113">A.113 <code><nobr>LEAVE</nobr></code>: Destroy Stack Frame</a></h3>
<p><pre>
LEAVE                         ; C9                   [186]
</pre>
<p><code><nobr>LEAVE</nobr></code> destroys a stack frame of the form
created by the <code><nobr>ENTER</nobr></code> instruction (see
<a href="#section-A.40">section A.40</a>). It is functionally equivalent to
<code><nobr>MOV ESP,EBP</nobr></code> followed by
<code><nobr>POP EBP</nobr></code> (or <code><nobr>MOV SP,BP</nobr></code>
followed by <code><nobr>POP BP</nobr></code> in 16-bit mode).
<h3><a name="section-A.114">A.114 <code><nobr>LGDT</nobr></code>, <code><nobr>LIDT</nobr></code>, <code><nobr>LLDT</nobr></code>: Load Descriptor Tables</a></h3>
<p><pre>
LGDT mem                      ; 0F 01 /2             [286,PRIV] 
LIDT mem                      ; 0F 01 /3             [286,PRIV] 
LLDT r/m16                    ; 0F 00 /2             [286,PRIV]
</pre>
<p><code><nobr>LGDT</nobr></code> and <code><nobr>LIDT</nobr></code> both
take a 6-byte memory area as an operand: they load a 32-bit linear address
and a 16-bit size limit from that area (in the opposite order) into the
GDTR (global descriptor table register) or IDTR (interrupt descriptor table
register). These are the only instructions which directly use
<em>linear</em> addresses, rather than segment/offset pairs.
<p><code><nobr>LLDT</nobr></code> takes a segment selector as an operand.
The processor looks up that selector in the GDT and stores the limit and
base address given there into the LDTR (local descriptor table register).
<p>See also <code><nobr>SGDT</nobr></code>, <code><nobr>SIDT</nobr></code>
and <code><nobr>SLDT</nobr></code> (<a href="#section-A.232">section
A.232</a>).
<h3><a name="section-A.115">A.115 <code><nobr>LMSW</nobr></code>: Load/Store Machine Status Word</a></h3>
<p><pre>
LMSW r/m16                    ; 0F 01 /6             [286,PRIV]
</pre>
<p><code><nobr>LMSW</nobr></code> loads the bottom four bits of the source
operand into the bottom four bits of the <code><nobr>CR0</nobr></code>
control register (or the Machine Status Word, on 286 processors). See also
<code><nobr>SMSW</nobr></code> (<a href="#section-A.238">section
A.238</a>).
<h3><a name="section-A.116">A.116 <code><nobr>LOADALL</nobr></code>, <code><nobr>LOADALL286</nobr></code>: Load Processor State</a></h3>
<p><pre>
LOADALL                       ; 0F 07                [386,UNDOC] 
LOADALL286                    ; 0F 05                [286,UNDOC]
</pre>
<p>This instruction, in its two different-opcode forms, is apparently
supported on most 286 processors, some 386 and possibly some 486. The
opcode differs between the 286 and the 386.
<p>The function of the instruction is to load all information relating to
the state of the processor out of a block of memory: on the 286, this block
is located implicitly at absolute address <code><nobr>0x800</nobr></code>,
and on the 386 and 486 it is at <code><nobr>[ES:EDI]</nobr></code>.
<h3><a name="section-A.117">A.117 <code><nobr>LODSB</nobr></code>, <code><nobr>LODSW</nobr></code>, <code><nobr>LODSD</nobr></code>: Load from String</a></h3>
<p><pre>
LODSB                         ; AC                   [8086] 
LODSW                         ; o16 AD               [8086] 
LODSD                         ; o32 AD               [386]
</pre>
<p><code><nobr>LODSB</nobr></code> loads a byte from
<code><nobr>[DS:SI]</nobr></code> or <code><nobr>[DS:ESI]</nobr></code>
into <code><nobr>AL</nobr></code>. It then increments or decrements
(depending on the direction flag: increments if the flag is clear,
decrements if it is set) <code><nobr>SI</nobr></code> or
<code><nobr>ESI</nobr></code>.
<p>The register used is <code><nobr>SI</nobr></code> if the address size is
16 bits, and <code><nobr>ESI</nobr></code> if it is 32 bits. If you need to
use an address size not equal to the current <code><nobr>BITS</nobr></code>
setting, you can use an explicit <code><nobr>a16</nobr></code> or
<code><nobr>a32</nobr></code> prefix.
<p>The segment register used to load from <code><nobr>[SI]</nobr></code> or
<code><nobr>[ESI]</nobr></code> can be overridden by using a segment
register name as a prefix (for example,
<code><nobr>es lodsb</nobr></code>).
<p><code><nobr>LODSW</nobr></code> and <code><nobr>LODSD</nobr></code> work
in the same way, but they load a word or a doubleword instead of a byte,
and increment or decrement the addressing registers by 2 or 4 instead of 1.
<h3><a name="section-A.118">A.118 <code><nobr>LOOP</nobr></code>, <code><nobr>LOOPE</nobr></code>, <code><nobr>LOOPZ</nobr></code>, <code><nobr>LOOPNE</nobr></code>, <code><nobr>LOOPNZ</nobr></code>: Loop with Counter</a></h3>
<p><pre>
LOOP imm                      ; E2 rb                [8086] 
LOOP imm,CX                   ; a16 E2 rb            [8086] 
LOOP imm,ECX                  ; a32 E2 rb            [386]
</pre>
<p><pre>
LOOPE imm                     ; E1 rb                [8086] 
LOOPE imm,CX                  ; a16 E1 rb            [8086] 
LOOPE imm,ECX                 ; a32 E1 rb            [386] 
LOOPZ imm                     ; E1 rb                [8086] 
LOOPZ imm,CX                  ; a16 E1 rb            [8086] 
LOOPZ imm,ECX                 ; a32 E1 rb            [386]
</pre>
<p><pre>
LOOPNE imm                    ; E0 rb                [8086] 
LOOPNE imm,CX                 ; a16 E0 rb            [8086] 
LOOPNE imm,ECX                ; a32 E0 rb            [386] 
LOOPNZ imm                    ; E0 rb                [8086] 
LOOPNZ imm,CX                 ; a16 E0 rb            [8086] 
LOOPNZ imm,ECX                ; a32 E0 rb            [386]
</pre>
<p><code><nobr>LOOP</nobr></code> decrements its counter register (either
<code><nobr>CX</nobr></code> or <code><nobr>ECX</nobr></code> - if one is
not specified explicitly, the <code><nobr>BITS</nobr></code> setting
dictates which is used) by one, and if the counter does not become zero as
a result of this operation, it jumps to the given label. The jump has a
range of 128 bytes.
<p><code><nobr>LOOPE</nobr></code> (or its synonym
<code><nobr>LOOPZ</nobr></code>) adds the additional condition that it only
jumps if the counter is nonzero <em>and</em> the zero flag is set.
Similarly, <code><nobr>LOOPNE</nobr></code> (and
<code><nobr>LOOPNZ</nobr></code>) jumps only if the counter is nonzero and
the zero flag is clear.
<h3><a name="section-A.119">A.119 <code><nobr>LSL</nobr></code>: Load Segment Limit</a></h3>
<p><pre>
LSL reg16,r/m16               ; o16 0F 03 /r         [286,PRIV] 
LSL reg32,r/m32               ; o32 0F 03 /r         [286,PRIV]
</pre>
<p><code><nobr>LSL</nobr></code> is given a segment selector in its source
(second) operand; it computes the segment limit value by loading the
segment limit field from the associated segment descriptor in the GDT or
LDT. (This involves shifting left by 12 bits if the segment limit is
page-granular, and not if it is byte-granular; so you end up with a byte
limit in either case.) The segment limit obtained is then loaded into the
destination (first) operand.
<h3><a name="section-A.120">A.120 <code><nobr>LTR</nobr></code>: Load Task Register</a></h3>
<p><pre>
LTR r/m16                     ; 0F 00 /3             [286,PRIV]
</pre>
<p><code><nobr>LTR</nobr></code> looks up the segment base and limit in the
GDT or LDT descriptor specified by the segment selector given as its
operand, and loads them into the Task Register.
<h3><a name="section-A.121">A.121 <code><nobr>MASKMOVQ</nobr></code>: Byte Mask Write</a></h3>
<p><pre>
MASKMOVQ mmxreg,mmxreg        ; 0F F7 /r             [KATMAI]
</pre>
<p><code><nobr>MASKMOVQ</nobr></code> uses the most significant bit in each
byte of the second MMX resister to selectively write (0 = no write, 1 =
write) each byte of the first MMX register to the 64-bit memory location
DS:DI or DS:EDI (depending on the addressing mode).
<h3><a name="section-A.122">A.122 <code><nobr>MAXPS</nobr></code>: SSE Packed Single-FP Maximum</a></h3>
<p><pre>
MAXPS xmmreg,r/m128           ; 0F 5F /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MAXPS</nobr></code> considers its operands as vectors of
four 32-bit floating-point numbers, and for each pair it stores the maximum
of the the two in the corresponding quarter of the destination register.
<h3><a name="section-A.123">A.123 <code><nobr>MAXSS</nobr></code>: SSE Scalar Single-FP Maximum</a></h3>
<p><pre>
MAXSS xmmreg,r/m128           ; F3 0F 5F /r          [KATMAI,SSE]
</pre>
<p><code><nobr>MAXSS</nobr></code> determines the maximum 32-bit
floating-point number from the lowest quarter of both operands, and places
this in the lowest quarter of the destination register.
<h3><a name="section-A.124">A.124 <code><nobr>MINPS</nobr></code>: SSE Packed Single-FP Minimum</a></h3>
<p><pre>
MINPS xmmreg,r/m128           ; 0F 5D /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MINPS</nobr></code> considers its operands as vectors of
four 32-bit floating-point numbers, and for each pair it stores the minimum
of the the two in the corresponding quarter of the destination register.
<h3><a name="section-A.125">A.125 <code><nobr>MINSS</nobr></code>: SSE Scalar Single-FP Maximum</a></h3>
<p><pre>
MINSS xmmreg,r/m128           ; F3 0F 5D /r          [KATMAI,SSE]
</pre>
<p><code><nobr>MINSS</nobr></code> determines the minimum 32-bit
floating-point number from the lowest quarter of both operands, and places
this in the lowest quarter of the destination register.
<h3><a name="section-A.126">A.126 <code><nobr>MOV</nobr></code>: Move Data</a></h3>
<p><pre>
MOV r/m8,reg8                 ; 88 /r                [8086] 
MOV r/m16,reg16               ; o16 89 /r            [8086] 
MOV r/m32,reg32               ; o32 89 /r            [386] 
MOV reg8,r/m8                 ; 8A /r                [8086] 
MOV reg16,r/m16               ; o16 8B /r            [8086] 
MOV reg32,r/m32               ; o32 8B /r            [386]
</pre>
<p><pre>
MOV reg8,imm8                 ; B0+r ib              [8086] 
MOV reg16,imm16               ; o16 B8+r iw          [8086] 
MOV reg32,imm32               ; o32 B8+r id          [386] 
MOV r/m8,imm8                 ; C6 /0 ib             [8086] 
MOV r/m16,imm16               ; o16 C7 /0 iw         [8086] 
MOV r/m32,imm32               ; o32 C7 /0 id         [386]
</pre>
<p><pre>
MOV AL,memoffs8               ; A0 ow/od             [8086] 
MOV AX,memoffs16              ; o16 A1 ow/od         [8086] 
MOV EAX,memoffs32             ; o32 A1 ow/od         [386] 
MOV memoffs8,AL               ; A2 ow/od             [8086] 
MOV memoffs16,AX              ; o16 A3 ow/od         [8086] 
MOV memoffs32,EAX             ; o32 A3 ow/od         [386]
</pre>
<p><pre>
MOV r/m16,segreg              ; o16 8C /r            [8086] 
MOV r/m32,segreg              ; o32 8C /r            [386] 
MOV segreg,r/m16              ; o16 8E /r            [8086] 
MOV segreg,r/m32              ; o32 8E /r            [386]
</pre>
<p><pre>
MOV reg32,CR0/2/3/4           ; 0F 20 /r             [386] 
MOV reg32,DR0/1/2/3/6/7       ; 0F 21 /r             [386] 
MOV reg32,TR3/4/5/6/7         ; 0F 24 /r             [386] 
MOV CR0/2/3/4,reg32           ; 0F 22 /r             [386] 
MOV DR0/1/2/3/6/7,reg32       ; 0F 23 /r             [386] 
MOV TR3/4/5/6/7,reg32         ; 0F 26 /r             [386]
</pre>
<p><code><nobr>MOV</nobr></code> copies the contents of its source (second)
operand into its destination (first) operand.
<p>In all forms of the <code><nobr>MOV</nobr></code> instruction, the two
operands are the same size, except for moving between a segment register
and an <code><nobr>r/m32</nobr></code> operand. These instructions are
treated exactly like the corresponding 16-bit equivalent (so that, for
example, <code><nobr>MOV DS,EAX</nobr></code> functions identically to
<code><nobr>MOV DS,AX</nobr></code> but saves a prefix when in 32-bit
mode), except that when a segment register is moved into a 32-bit
destination, the top two bytes of the result are undefined.
<p><code><nobr>MOV</nobr></code> may not use <code><nobr>CS</nobr></code>
as a destination.
<p><code><nobr>CR4</nobr></code> is only a supported register on the
Pentium and above.
<h3><a name="section-A.127">A.127 <code><nobr>MOVAPS</nobr></code>: Move Aligned Four Packed Single-FP</a></h3>
<p><pre>
MOVAPS xmmreg,r/m128          ; 0F 28 /r             [KATMAI,SSE] 
MOVAPS r/m128,xmmreg          ; 0F 29 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVAPS</nobr></code> copies 16 bytes from the source operand
to the destination operand. If one of the operands is a memory location it
must be aligned on a 16-byte boundary (otherwise use
<code><nobr>MOVUPS</nobr></code>).
<h3><a name="section-A.128">A.128 <code><nobr>MOVD</nobr></code>: Move Doubleword to/from MMX Register</a></h3>
<p><pre>
MOVD mmxreg,r/m32             ; 0F 6E /r             [PENT,MMX] 
MOVD r/m32,mmxreg             ; 0F 7E /r             [PENT,MMX]
</pre>
<p><code><nobr>MOVD</nobr></code> copies 32 bits from its source (second)
operand into its destination (first) operand. When the destination is a
64-bit MMX register, the top 32 bits are set to zero.
<h3><a name="section-A.129">A.129 <code><nobr>MOVHLPS</nobr></code>: SSE Move High to Low</a></h3>
<p><pre>
MOVHLPS xmmreg,xmmreg         ; OF 12 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVHLPS</nobr></code> moves 8 bytes from the upper half of
the source register to the lower half of the destination register.
<h3><a name="section-A.130">A.130 <code><nobr>MOVHPS</nobr></code>: SSE Move High</a></h3>
<p><pre>
MOVHPS xmmreg,mem64           ; 0F 16 /r             [KATMAI,SSE] 
MOVHPS mem64,xmmreg           ; 0F 17 /r             [KATMAI,SSE] 
MOVHPS xmmreg,xmmreg          ; 0F 16 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVHPS xmmreg,mem64</nobr></code> moves 8 bytes from mem64
to the upper half of xmmreg.
<p><code><nobr>MOVHPS mem64,xmmreg</nobr></code> moves 8 bytes from the
upper half of xmmreg to mem64.
<p><code><nobr>MOVHPS xmmreg,xmmreg</nobr></code> is simply a synonym for
<code><nobr>MOVLHPS xmmreg,xmmreg</nobr></code>.
<h3><a name="section-A.131">A.131 <code><nobr>MOVLHPS</nobr></code>: SSE Move Low to High</a></h3>
<p><pre>
MOVLHPS xmmreg,xmmreg         ; 0F 16 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVLHPS</nobr></code> moves 8 bytes from the lower half of
the source register to the upper half of the destination register.
<h3><a name="section-A.132">A.132 <code><nobr>MOVLPS</nobr></code>: SSE Move Low</a></h3>
<p><pre>
MOVLPS xmmreg,mem64           ; 0F 12 /r             [KATMAI,SSE] 
MOVLPS mem64,xmmreg           ; 0F 13 /r             [KATMAI,SSE] 
MOVLPS xmmreg,xmmreg          ; 0F 12 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVLPS xmmreg,mem64</nobr></code> moves 8 bytes from mem64
to the lower half of xmmreg.
<p><code><nobr>MOVLPS mem64,xmmreg</nobr></code> moves 8 bytes from the
lower half of xmmreg to mem64.
<p><code><nobr>MOVLPS xmmreg,xmmreg</nobr></code> is simply a synonym for
<code><nobr>MOVHLPS xmmreg,xmmreg</nobr></code>.
<h3><a name="section-A.133">A.133 <code><nobr>MOVMSKPS</nobr></code>: Move Mask To Integer</a></h3>
<p><pre>
MOVMSKPS reg32,xmmreg         ; 0F 50 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVMSKPS</nobr></code> forms a 4-bit mask from the most
significant bit of each of the four 32-bit numbers in the source register,
and stores this mask in the destination register.
<h3><a name="section-A.134">A.134 <code><nobr>MOVNTPS</nobr></code>: Move Aligned Four Packed Single-FP Non Temporal</a></h3>
<p><pre>
MOVNTPS mem128,xmmreg         ; 0F 2B /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVNTPS</nobr></code> copies the contents of the XMM
register into the given memory location, doing so in such a way as to
minimize cache pollution. The memory location must be 16-byte aligned.
<h3><a name="section-A.135">A.135 <code><nobr>MOVNTQ</nobr></code>: Move 64 Bits Non Temporal</a></h3>
<p><pre>
MOVNTQ mem64,mmxreg           ; 0F E7 /r             [KATMAI]
</pre>
<p><code><nobr>MOVNTPS</nobr></code> copies the contents of the MMX
register into the given memory location, doing so in such a way as to
minimize cache pollution.
<h3><a name="section-A.136">A.136 <code><nobr>MOVQ</nobr></code>: Move Quadword to/from MMX Register</a></h3>
<p><pre>
MOVQ mmxreg,r/m64             ; 0F 6F /r             [PENT,MMX] 
MOVQ r/m64,mmxreg             ; 0F 7F /r             [PENT,MMX]
</pre>
<p><code><nobr>MOVQ</nobr></code> copies 64 bits from its source (second)
operand into its destination (first) operand.
<h3><a name="section-A.137">A.137 <code><nobr>MOVSB</nobr></code>, <code><nobr>MOVSW</nobr></code>, <code><nobr>MOVSD</nobr></code>: Move String</a></h3>
<p><pre>
MOVSB                         ; A4                   [8086] 
MOVSW                         ; o16 A5               [8086] 
MOVSD                         ; o32 A5               [386]
</pre>
<p><code><nobr>MOVSB</nobr></code> copies the byte at
<code><nobr>[ES:DI]</nobr></code> or <code><nobr>[ES:EDI]</nobr></code> to
<code><nobr>[DS:SI]</nobr></code> or <code><nobr>[DS:ESI]</nobr></code>. It
then increments or decrements (depending on the direction flag: increments
if the flag is clear, decrements if it is set) <code><nobr>SI</nobr></code>
and <code><nobr>DI</nobr></code> (or <code><nobr>ESI</nobr></code> and
<code><nobr>EDI</nobr></code>).
<p>The registers used are <code><nobr>SI</nobr></code> and
<code><nobr>DI</nobr></code> if the address size is 16 bits, and
<code><nobr>ESI</nobr></code> and <code><nobr>EDI</nobr></code> if it is 32
bits. If you need to use an address size not equal to the current
<code><nobr>BITS</nobr></code> setting, you can use an explicit
<code><nobr>a16</nobr></code> or <code><nobr>a32</nobr></code> prefix.
<p>The segment register used to load from <code><nobr>[SI]</nobr></code> or
<code><nobr>[ESI]</nobr></code> can be overridden by using a segment
register name as a prefix (for example,
<code><nobr>es movsb</nobr></code>). The use of
<code><nobr>ES</nobr></code> for the store to
<code><nobr>[DI]</nobr></code> or <code><nobr>[EDI]</nobr></code> cannot be
overridden.
<p><code><nobr>MOVSW</nobr></code> and <code><nobr>MOVSD</nobr></code> work
in the same way, but they copy a word or a doubleword instead of a byte,
and increment or decrement the addressing registers by 2 or 4 instead of 1.
<p>The <code><nobr>REP</nobr></code> prefix may be used to repeat the
instruction <code><nobr>CX</nobr></code> (or <code><nobr>ECX</nobr></code>
- again, the address size chooses which) times.
<h3><a name="section-A.138">A.138 <code><nobr>MOVSS</nobr></code>: Move Scalar Single-FP</a></h3>
<p><pre>
MOVSS xmmreg,xmmreg/mem32     ; F3 0F 10 /r          [KATMAI,SSE] 
MOVSS xmmreg/mem32,xmmreg     ; F3 0F 11 /r          [KATMAI,SSE]
</pre>
<p><code><nobr>MOVSS</nobr></code> copies the lower 4 bytes of the source
operand to the lower 4 bytes of the destination operand.
<h3><a name="section-A.139">A.139 <code><nobr>MOVSX</nobr></code>, <code><nobr>MOVZX</nobr></code>: Move Data with Sign or Zero Extend</a></h3>
<p><pre>
MOVSX reg16,r/m8              ; o16 0F BE /r         [386] 
MOVSX reg32,r/m8              ; o32 0F BE /r         [386] 
MOVSX reg32,r/m16             ; o32 0F BF /r         [386]
</pre>
<p><pre>
MOVZX reg16,r/m8              ; o16 0F B6 /r         [386] 
MOVZX reg32,r/m8              ; o32 0F B6 /r         [386] 
MOVZX reg32,r/m16             ; o32 0F B7 /r         [386]
</pre>
<p><code><nobr>MOVSX</nobr></code> sign-extends its source (second) operand
to the length of its destination (first) operand, and copies the result
into the destination operand. <code><nobr>MOVZX</nobr></code> does the
same, but zero-extends rather than sign-extending.
<h3><a name="section-A.140">A.140 <code><nobr>MOVUPS</nobr></code>: Move Unaligned Four Packed Single-FP</a></h3>
<p><pre>
MOVUPS xmmreg,r/m128          ; 0F 10 /r             [KATMAI,SSE] 
MOVUPS r/m128,xmmreg          ; 0F 11 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MOVUPS</nobr></code> copies 16 bytes from the source operand
to the destination operand. In contrast to
<code><nobr>MOVAPS</nobr></code>, no assumption is made about alignment.
<h3><a name="section-A.141">A.141 <code><nobr>MUL</nobr></code>: Unsigned Integer Multiply</a></h3>
<p><pre>
MUL r/m8                      ; F6 /4                [8086] 
MUL r/m16                     ; o16 F7 /4            [8086] 
MUL r/m32                     ; o32 F7 /4            [386]
</pre>
<p><code><nobr>MUL</nobr></code> performs unsigned integer multiplication.
The other operand to the multiplication, and the destination operand, are
implicit, in the following way:
<ul>
<li>For <code><nobr>MUL r/m8</nobr></code>, <code><nobr>AL</nobr></code> is
multiplied by the given operand; the product is stored in
<code><nobr>AX</nobr></code>.
<li>For <code><nobr>MUL r/m16</nobr></code>, <code><nobr>AX</nobr></code>
is multiplied by the given operand; the product is stored in
<code><nobr>DX:AX</nobr></code>.
<li>For <code><nobr>MUL r/m32</nobr></code>, <code><nobr>EAX</nobr></code>
is multiplied by the given operand; the product is stored in
<code><nobr>EDX:EAX</nobr></code>.
</ul>
<p>Signed integer multiplication is performed by the
<code><nobr>IMUL</nobr></code> instruction: see
<a href="#section-A.95">section A.95</a>.
<h3><a name="section-A.142">A.142 <code><nobr>MULPS</nobr></code>: Packed Single-FP Multiply</a></h3>
<p><pre>
MULPS xmmreg,r/m128           ; 0F 59 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>MULPS</nobr></code> multiplies each of the four 32-bit
floating-point numbers in the destination register by the corresponding
numbers in the source operand.
<h3><a name="section-A.143">A.143 <code><nobr>MULSS</nobr></code>: Scalar Single-FP Multiply</a></h3>
<p><pre>
MULSS xmmreg,xmmreg/mem32     ; F3 0F 59 /r          [KATMAI,SSE]
</pre>
<p><code><nobr>MULSS</nobr></code> multiplies the first of the four 32-bit
floating-point numbers in the destination register by the corresponding
number in the source operand.
<h3><a name="section-A.144">A.144 <code><nobr>NEG</nobr></code>, <code><nobr>NOT</nobr></code>: Two's and One's Complement</a></h3>
<p><pre>
NEG r/m8                      ; F6 /3                [8086] 
NEG r/m16                     ; o16 F7 /3            [8086] 
NEG r/m32                     ; o32 F7 /3            [386]
</pre>
<p><pre>
NOT r/m8                      ; F6 /2                [8086] 
NOT r/m16                     ; o16 F7 /2            [8086] 
NOT r/m32                     ; o32 F7 /2            [386]
</pre>
<p><code><nobr>NEG</nobr></code> replaces the contents of its operand by
the two's complement negation (invert all the bits and then add one) of the
original value. <code><nobr>NOT</nobr></code>, similarly, performs one's
complement (inverts all the bits).
<h3><a name="section-A.145">A.145 <code><nobr>NOP</nobr></code>: No Operation</a></h3>
<p><pre>
NOP                           ; 90                   [8086]
</pre>
<p><code><nobr>NOP</nobr></code> performs no operation. Its opcode is the
same as that generated by <code><nobr>XCHG AX,AX</nobr></code> or
<code><nobr>XCHG EAX,EAX</nobr></code> (depending on the processor mode;
see <a href="#section-A.268">section A.268</a>).
<h3><a name="section-A.146">A.146 <code><nobr>OR</nobr></code>: Bitwise OR</a></h3>
<p><pre>
OR r/m8,reg8                  ; 08 /r                [8086] 
OR r/m16,reg16                ; o16 09 /r            [8086] 
OR r/m32,reg32                ; o32 09 /r            [386]
</pre>
<p><pre>
OR reg8,r/m8                  ; 0A /r                [8086] 
OR reg16,r/m16                ; o16 0B /r            [8086] 
OR reg32,r/m32                ; o32 0B /r            [386]
</pre>
<p><pre>
OR r/m8,imm8                  ; 80 /1 ib             [8086] 
OR r/m16,imm16                ; o16 81 /1 iw         [8086] 
OR r/m32,imm32                ; o32 81 /1 id         [386]
</pre>
<p><pre>
OR r/m16,imm8                 ; o16 83 /1 ib         [8086] 
OR r/m32,imm8                 ; o32 83 /1 ib         [386]
</pre>
<p><pre>
OR AL,imm8                    ; 0C ib                [8086] 
OR AX,imm16                   ; o16 0D iw            [8086] 
OR EAX,imm32                  ; o32 0D id            [386]
</pre>
<p><code><nobr>OR</nobr></code> performs a bitwise OR operation between its
two operands (i.e. each bit of the result is 1 if and only if at least one
of the corresponding bits of the two inputs was 1), and stores the result
in the destination (first) operand.
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<p>The MMX instruction <code><nobr>POR</nobr></code> (see
<a href="#section-A.196">section A.196</a>) performs the same operation on
the 64-bit MMX registers.
<h3><a name="section-A.147">A.147 <code><nobr>ORPS</nobr></code>: SSE Bitwise Logical OR</a></h3>
<p><pre>
ORPS xmmreg,r/m128            ; 0F 56 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>ORPS</nobr></code> performs a bitwise OR operation on the
source operand and the destination register, and stores the result in the
destination register.
<h3><a name="section-A.148">A.148 <code><nobr>OUT</nobr></code>: Output Data to I/O Port</a></h3>
<p><pre>
OUT imm8,AL                   ; E6 ib                [8086] 
OUT imm8,AX                   ; o16 E7 ib            [8086] 
OUT imm8,EAX                  ; o32 E7 ib            [386] 
OUT DX,AL                     ; EE                   [8086] 
OUT DX,AX                     ; o16 EF               [8086] 
OUT DX,EAX                    ; o32 EF               [386]
</pre>
<p><code><nobr>IN</nobr></code> writes the contents of the given source
register to the specified I/O port. The port number may be specified as an
immediate value if it is between 0 and 255, and otherwise must be stored in
<code><nobr>DX</nobr></code>. See also <code><nobr>IN</nobr></code>
(<a href="#section-A.96">section A.96</a>).
<h3><a name="section-A.149">A.149 <code><nobr>OUTSB</nobr></code>, <code><nobr>OUTSW</nobr></code>, <code><nobr>OUTSD</nobr></code>: Output String to I/O Port</a></h3>
<p><pre>
OUTSB                         ; 6E                   [186] 
OUTSW                         ; o16 6F               [186] 
OUTSD                         ; o32 6F               [386]
</pre>
<p><code><nobr>OUTSB</nobr></code> loads a byte from
<code><nobr>[DS:SI]</nobr></code> or <code><nobr>[DS:ESI]</nobr></code> and
writes it to the I/O port specified in <code><nobr>DX</nobr></code>. It
then increments or decrements (depending on the direction flag: increments
if the flag is clear, decrements if it is set) <code><nobr>SI</nobr></code>
or <code><nobr>ESI</nobr></code>.
<p>The register used is <code><nobr>SI</nobr></code> if the address size is
16 bits, and <code><nobr>ESI</nobr></code> if it is 32 bits. If you need to
use an address size not equal to the current <code><nobr>BITS</nobr></code>
setting, you can use an explicit <code><nobr>a16</nobr></code> or
<code><nobr>a32</nobr></code> prefix.
<p>The segment register used to load from <code><nobr>[SI]</nobr></code> or
<code><nobr>[ESI]</nobr></code> can be overridden by using a segment
register name as a prefix (for example,
<code><nobr>es outsb</nobr></code>).
<p><code><nobr>OUTSW</nobr></code> and <code><nobr>OUTSD</nobr></code> work
in the same way, but they output a word or a doubleword instead of a byte,
and increment or decrement the addressing registers by 2 or 4 instead of 1.
<p>The <code><nobr>REP</nobr></code> prefix may be used to repeat the
instruction <code><nobr>CX</nobr></code> (or <code><nobr>ECX</nobr></code>
- again, the address size chooses which) times.
<h3><a name="section-A.150">A.150 <code><nobr>PACKSSDW</nobr></code>, <code><nobr>PACKSSWB</nobr></code>, <code><nobr>PACKUSWB</nobr></code>: Pack Data</a></h3>
<p><pre>
PACKSSDW mmxreg,r/m64         ; 0F 6B /r             [PENT,MMX] 
PACKSSWB mmxreg,r/m64         ; 0F 63 /r             [PENT,MMX] 
PACKUSWB mmxreg,r/m64         ; 0F 67 /r             [PENT,MMX]
</pre>
<p>All these instructions start by forming a notional 128-bit word by
placing the source (second) operand on the left of the destination (first)
operand. <code><nobr>PACKSSDW</nobr></code> then splits this 128-bit word
into four doublewords, converts each to a word, and loads them side by side
into the destination register; <code><nobr>PACKSSWB</nobr></code> and
<code><nobr>PACKUSWB</nobr></code> both split the 128-bit word into eight
words, converts each to a byte, and loads <em>those</em> side by side into
the destination register.
<p><code><nobr>PACKSSDW</nobr></code> and
<code><nobr>PACKSSWB</nobr></code> perform signed saturation when reducing
the length of numbers: if the number is too large to fit into the reduced
space, they replace it by the largest signed number
(<code><nobr>7FFFh</nobr></code> or <code><nobr>7Fh</nobr></code>) that
<em>will</em> fit, and if it is too small then they replace it by the
smallest signed number (<code><nobr>8000h</nobr></code> or
<code><nobr>80h</nobr></code>) that will fit.
<code><nobr>PACKUSWB</nobr></code> performs unsigned saturation: it treats
its input as unsigned, and replaces it by the largest unsigned number that
will fit.
<h3><a name="section-A.151">A.151 <code><nobr>PADDxx</nobr></code>: MMX Packed Addition</a></h3>
<p><pre>
PADDB mmxreg,r/m64            ; 0F FC /r             [PENT,MMX] 
PADDW mmxreg,r/m64            ; 0F FD /r             [PENT,MMX] 
PADDD mmxreg,r/m64            ; 0F FE /r             [PENT,MMX]
</pre>
<p><pre>
PADDSB mmxreg,r/m64           ; 0F EC /r             [PENT,MMX] 
PADDSW mmxreg,r/m64           ; 0F ED /r             [PENT,MMX]
</pre>
<p><pre>
PADDUSB mmxreg,r/m64          ; 0F DC /r             [PENT,MMX] 
PADDUSW mmxreg,r/m64          ; 0F DD /r             [PENT,MMX]
</pre>
<p><code><nobr>PADDxx</nobr></code> all perform packed addition between
their two 64-bit operands, storing the result in the destination (first)
operand. The <code><nobr>PADDxB</nobr></code> forms treat the 64-bit
operands as vectors of eight bytes, and add each byte individually;
<code><nobr>PADDxW</nobr></code> treat the operands as vectors of four
words; and <code><nobr>PADDD</nobr></code> treats its operands as vectors
of two doublewords.
<p><code><nobr>PADDSB</nobr></code> and <code><nobr>PADDSW</nobr></code>
perform signed saturation on the sum of each pair of bytes or words: if the
result of an addition is too large or too small to fit into a signed byte
or word result, it is clipped (saturated) to the largest or smallest value
which <em>will</em> fit. <code><nobr>PADDUSB</nobr></code> and
<code><nobr>PADDUSW</nobr></code> similarly perform unsigned saturation,
clipping to <code><nobr>0FFh</nobr></code> or
<code><nobr>0FFFFh</nobr></code> if the result is larger than that.
<h3><a name="section-A.152">A.152 <code><nobr>PADDSIW</nobr></code>: MMX Packed Addition to Implicit Destination</a></h3>
<p><pre>
PADDSIW mmxreg,r/m64          ; 0F 51 /r             [CYRIX,MMX]
</pre>
<p><code><nobr>PADDSIW</nobr></code>, specific to the Cyrix extensions to
the MMX instruction set, performs the same function as
<code><nobr>PADDSW</nobr></code>, except that the result is not placed in
the register specified by the first operand, but instead in the register
whose number differs from the first operand only in the last bit. So
<code><nobr>PADDSIW MM0,MM2</nobr></code> would put the result in
<code><nobr>MM1</nobr></code>, but
<code><nobr>PADDSIW MM1,MM2</nobr></code> would put the result in
<code><nobr>MM0</nobr></code>.
<h3><a name="section-A.153">A.153 <code><nobr>PAND</nobr></code>, <code><nobr>PANDN</nobr></code>: MMX Bitwise AND and AND-NOT</a></h3>
<p><pre>
PAND mmxreg,r/m64             ; 0F DB /r             [PENT,MMX] 
PANDN mmxreg,r/m64            ; 0F DF /r             [PENT,MMX]
</pre>
<p><code><nobr>PAND</nobr></code> performs a bitwise AND operation between
its two operands (i.e. each bit of the result is 1 if and only if the
corresponding bits of the two inputs were both 1), and stores the result in
the destination (first) operand.
<p><code><nobr>PANDN</nobr></code> performs the same operation, but
performs a one's complement operation on the destination (first) operand
first.
<h3><a name="section-A.154">A.154 <code><nobr>PAVEB</nobr></code>: MMX Packed Average</a></h3>
<p><pre>
PAVEB mmxreg,r/m64            ; 0F 50 /r             [CYRIX,MMX]
</pre>
<p><code><nobr>PAVEB</nobr></code>, specific to the Cyrix MMX extensions,
treats its two operands as vectors of eight unsigned bytes, and calculates
the average of the corresponding bytes in the operands. The resulting
vector of eight averages is stored in the first operand.
<h3><a name="section-A.155">A.155 <code><nobr>PAVGB</nobr></code>, <code><nobr>PAVGW</nobr></code>: Packed Average</a></h3>
<p><pre>
PAVGB mmxreg,r/m64            ; 0F E0 /r             [KATMAI] 
PAVGW mmxreg,r/m64            ; 0F E3 /r             [KATMAI]
</pre>
<p>For each byte in the source register, <code><nobr>PAVGB</nobr></code>
computes the average of this byte and the corresponding byte in the
destination register, and stores this average in place of the byte in the
source register.
<p><code><nobr>PAVGW</nobr></code> does the same thing, but operating on 4
pairs of words instead of 8 pairs of bytes.
<p>In all cases, the values operated one are considered to be unsigned, and
the result is rounded up if it is not an integer.
<h3><a name="section-A.156">A.156 <code><nobr>PAVGUSB</nobr></code>: Average Of Unsigned Packed 8-bit Values</a></h3>
<p><pre>
PAVGUSB mmxreg,r/m64          ; 0F 0F /r BF          [3DNOW]
</pre>
<p><code><nobr>PAVGUSB</nobr></code> produces the averages (rounded up) of
the eight unsigned 8-bit integer values in the source operand and the eight
corresponding unsigned 8-bit integer values in the destination register.
<h3><a name="section-A.157">A.157 <code><nobr>PCMPxx</nobr></code>: MMX Packed Comparison</a></h3>
<p><pre>
PCMPEQB mmxreg,r/m64          ; 0F 74 /r             [PENT,MMX] 
PCMPEQW mmxreg,r/m64          ; 0F 75 /r             [PENT,MMX] 
PCMPEQD mmxreg,r/m64          ; 0F 76 /r             [PENT,MMX]
</pre>
<p><pre>
PCMPGTB mmxreg,r/m64          ; 0F 64 /r             [PENT,MMX] 
PCMPGTW mmxreg,r/m64          ; 0F 65 /r             [PENT,MMX] 
PCMPGTD mmxreg,r/m64          ; 0F 66 /r             [PENT,MMX]
</pre>
<p>The <code><nobr>PCMPxx</nobr></code> instructions all treat their
operands as vectors of bytes, words, or doublewords; corresponding elements
of the source and destination are compared, and the corresponding element
of the destination (first) operand is set to all zeros or all ones
depending on the result of the comparison.
<p><code><nobr>PCMPxxB</nobr></code> treats the operands as vectors of
eight bytes, <code><nobr>PCMPxxW</nobr></code> treats them as vectors of
four words, and <code><nobr>PCMPxxD</nobr></code> as two doublewords.
<p><code><nobr>PCMPEQx</nobr></code> sets the corresponding element of the
destination operand to all ones if the two elements compared are equal;
<code><nobr>PCMPGTx</nobr></code> sets the destination element to all ones
if the element of the first (destination) operand is greater (treated as a
signed integer) than that of the second (source) operand.
<h3><a name="section-A.158">A.158 <code><nobr>PDISTIB</nobr></code>: MMX Packed Distance and Accumulate with Implied Register</a></h3>
<p><pre>
PDISTIB mmxreg,mem64          ; 0F 54 /r             [CYRIX,MMX]
</pre>
<p><code><nobr>PDISTIB</nobr></code>, specific to the Cyrix MMX extensions,
treats its two input operands as vectors of eight unsigned bytes. For each
byte position, it finds the absolute difference between the bytes in that
position in the two input operands, and adds that value to the byte in the
same position in the implied output register. The addition is saturated to
an unsigned byte in the same way as <code><nobr>PADDUSB</nobr></code>.
<p>The implied output register is found in the same way as
<code><nobr>PADDSIW</nobr></code> (<a href="#section-A.152">section
A.152</a>).
<p>Note that <code><nobr>PDISTIB</nobr></code> cannot take a register as
its second source operand.
<h3><a name="section-A.159">A.159 <code><nobr>PEXTRW</nobr></code>: Extract Word</a></h3>
<p><pre>
PEXTRW reg32,mmxreg,imm8      ; 0F C5 /r ib          [KATMAI]
</pre>
<p><code><nobr>PEXTRW</nobr></code> moves the word in the MMX register
(selected by the two least significant bits of imm8) into the lower half of
the 32-bit integer register.
<h3><a name="section-A.160">A.160 <code><nobr>PF2ID</nobr></code>: Packed Floating-Point To Integer Conversion</a></h3>
<p><pre>
PF2ID mmxreg,r/m64            ; 0F 0F /r 1D          [3DNOW]
</pre>
<p><code><nobr>PF2ID</nobr></code> converts two 32-bit floating point
numbers in the source operand into 32-bit signed integers in the
destination register, using truncation.
<h3><a name="section-A.161">A.161 <code><nobr>PF2IW</nobr></code>: Packed Floating-Point to Integer Conversion</a></h3>
<p><pre>
PF2IW mmxreg,r/m64            ; 0F 0F /r 1C          [ATHLON]
</pre>
<p><code><nobr>PF2IW</nobr></code> converts two 32-bit floating point
numbers in the source operand into 16-bit signed integers in the
destination register, using truncation and sign-extending to 32 bits.
<h3><a name="section-A.162">A.162 <code><nobr>PFACC</nobr></code>: Floating-Point Accumulate</a></h3>
<p><pre>
PFACC mmxreg,r/m64            ; 0F 0F /r AE          [3DNOW]
</pre>
<p><code><nobr>PFACC</nobr></code> treats the source and destination
operands as pairs of 32-bit floating-point numbers. The sum of the pair in
the destination register is stored in the lower half of the destination
register, and the sum of the pair in the source operand is stored in the
upper half of the destination register.
<h3><a name="section-A.163">A.163 <code><nobr>PFADD</nobr></code>: Packed Floating-Point Addition</a></h3>
<p><pre>
PFADD mmxreg,r/m64            ; 0F 0F /r 9E          [3DNOW]
</pre>
<p><code><nobr>PFADD</nobr></code> adds the contents of the source operand
to the contents of the destination register, treating both as pairs of
32-bit floating-point numbers.
<h3><a name="section-A.164">A.164 <code><nobr>PFCMPEQ</nobr></code>, <code><nobr>PFCMPGE</nobr></code>, <code><nobr>PFCMPGT</nobr></code>: Packed Floating-Point Comparison.</a></h3>
<p><pre>
PFCMPEQ mmxreg,r/m64          ; 0F 0F /r B0          [3DNOW] 
PFCMPGE mmxreg,r/m64          ; 0F 0F /r 90          [3DNOW] 
PFCMPGT mmxreg,r/m64          ; 0F 0F /r A0          [3DNOW]
</pre>
<p>These instructions perform comparisons between pairs of 32-bit
floating-point numbers, storing the two results in the destination
register. <code><nobr>PFCMPEQ</nobr></code> stores
<code><nobr>0xFFFFFFFF</nobr></code> if the numbers are equal, and 0
otherwise. <code><nobr>PFCMPGE</nobr></code> stores
<code><nobr>0xFFFFFFFF</nobr></code> if the destination is greater than or
equal to the source, and 0 otherwise. <code><nobr>PFCMPGT</nobr></code>
stores <code><nobr>0xFFFFFFFF</nobr></code> if the destination is greater
than the source, and 0 otherwise.
<h3><a name="section-A.165">A.165 <code><nobr>PFMAX</nobr></code>: Packed Floating-Point Maximum</a></h3>
<p><pre>
PFMAX mmxreg,r/m64            ; 0F 0F /r A4          [3DNOW]
</pre>
<p>For each half of the destination register, sets it equal to the maximum
of itself and the corresponding half of the source operand, treating both
as 32-bit floating-point numbers.
<h3><a name="section-A.166">A.166 <code><nobr>PFMIN</nobr></code>: Packed Floating-Point Minimum</a></h3>
<p><pre>
PFMIN mmxreg,r/m64            ; 0F 0F /r 94          [3DNOW]
</pre>
<p>For each half of the destination register, sets it equal to the minimum
of itself and the corresponding half of the source operand, treating both
as 32-bit floating-point numbers.
<h3><a name="section-A.167">A.167 <code><nobr>PFMUL</nobr></code>: Packed Floating-Point Multiply</a></h3>
<p><pre>
PFMUL mmxreg,r/m64            ; 0F 0F /r B4          [3DNOW]
</pre>
<p><code><nobr>PFMUL</nobr></code> multiples the contents of the
destination register by the contents of the source operand, treating both
as pairs of 32-bit floating-point numbers.
<h3><a name="section-A.168">A.168 <code><nobr>PFNACC</nobr></code>: Packed Floating-Point Negative Accumulate</a></h3>
<p><pre>
PFNACC mmxreg,r/m64           ; 0F 0F /r 8A          [ATHLON]
</pre>
<p><code><nobr>PFNACC</nobr></code> works the same as
<code><nobr>PFACC</nobr></code>, except that the difference rather than the
sum is stored, the value in the upper half in both cases being subtracted
from the value in the lower half.
<h3><a name="section-A.169">A.169 <code><nobr>PFPNACC</nobr></code>: Packed Floating-Point Mixed Accumulate</a></h3>
<p><pre>
PFPNACC mmxreg,r/m64          ; 0F 0F /r 8E          [ATHLON]
</pre>
<p><code><nobr>PFPNACC</nobr></code> is a mixture of
<code><nobr>PFACC</nobr></code> and <code><nobr>PFNACC</nobr></code>. The
new value of the lower half of the destination register is obtained by
subtracting the upper half from the lower half. But the new value of the
upper half of the destination register is obtained by adding both halves of
the source operand.
<h3><a name="section-A.170">A.170 <code><nobr>PFRCP</nobr></code>: Floating-Point Reciprocal Approximation</a></h3>
<p><pre>
PFRCP mmxreg,r/m64            ; 0F 0F /r 96          [3DNOW]
</pre>
<p><code><nobr>PFRCP</nobr></code> calculates an approximation (accurate to
14 bits) of the reciprocal of the 32-bit floating-point number in the lower
half of the source and stores it in both halves of the destination.
<h3><a name="section-A.171">A.171 <code><nobr>PFRCPIT1</nobr></code>: Floating-Point Reciprocal Refinement</a></h3>
<p><pre>
PFRCPIT1 mmxreg,r/m64         ; 0F 0F /r A6          [3DNOW]
</pre>
<p><code><nobr>PFRCPIT1</nobr></code> performs the first step in the
iterative refinement of a reciprocal produced by
<code><nobr>PFRCP</nobr></code>.
<h3><a name="section-A.172">A.172 <code><nobr>PFRCPIT2</nobr></code>: Floating-Point Refinement (Last Step)</a></h3>
<p><pre>
PFRCPIT2 mmxreg,r/m64         ; 0F 0F /r B6          [3DNOW]
</pre>
<p><code><nobr>PFRCPIT2</nobr></code> performs the second and final step in
the iterative refinement of a reciprocal produced by
<code><nobr>PFRCP</nobr></code> or of a reciprocal square root produced by
<code><nobr>PFRSQRT</nobr></code>.
<h3><a name="section-A.173">A.173 <code><nobr>PFRSQIT1</nobr></code>: Floating-Point Reciprocal Square-Root Refinement</a></h3>
<p><pre>
PFRSQIT1 mmxreg,r/m64         ; 0F 0F /r A7          [3DNOW]
</pre>
<p><code><nobr>PFRSQIT1</nobr></code> performs the first step in the
iterative refinement of a reciprocal square root produced by
<code><nobr>PFRSQRT</nobr></code>.
<h3><a name="section-A.174">A.174 <code><nobr>PFRSQRT</nobr></code>: Floating-Point Reciprocal Square-Root Approximation</a></h3>
<p><pre>
PFRSQRT mmxreg,r/m64          ; 0F 0F /r 97          [3DNOW]
</pre>
<p><code><nobr>PFRSQRT</nobr></code> calculates an approximation (accurate
to 15 bits) of the reciprocal of the square root of the 32-bit
floating-point number in the lower half of the source and stores it in both
halves of the destination. If the source value is negative then it is
treated as positive except that its sign is copied to the result.
<h3><a name="section-A.175">A.175 <code><nobr>PFSUB</nobr></code>: Packed Floating-Point Subtraction</a></h3>
<p><pre>
PFSUB mmxreg,r/m64            ; 0F 0F /r 9A          [3DNOW]
</pre>
<p><code><nobr>PFSUB</nobr></code> subtracts the pair of 32-bit
floating-point numbers in the source operand from the corresponding pair in
the destination register.
<h3><a name="section-A.176">A.176 <code><nobr>PFSUBR</nobr></code>: Packed Floating-Point Reverse Subtraction</a></h3>
<p><pre>
PFSUBR mmxreg,r/m64           ; 0F 0F /r AA          [3DNOW]
</pre>
<p><code><nobr>PFSUB</nobr></code> subtracts the pair of 32-bit
floating-point numbers in the source operand from the corresponding pair in
the destination register, and then negates the results.
<h3><a name="section-A.177">A.177 <code><nobr>PI2FD</nobr></code>: Packed Integer To Floating-Point Conversion</a></h3>
<p><pre>
PI2FD mmxreg,r/m64            ; 0F 0F /r 0D          [3DNOW]
</pre>
<p><code><nobr>PI2FD</nobr></code> converts the pair of signed 32-bit
integers in the source operand into 32-bit floating-point numbers (using
truncation) and stores the results in the destination register.
<h3><a name="section-A.178">A.178 <code><nobr>PI2FW</nobr></code>: Packed Integer To Floating-Point Conversion</a></h3>
<p><pre>
PI2FW mmxreg,r/m64            ; 0F 0F /r 0C          [ATHLON]
</pre>
<p><code><nobr>PI2FW</nobr></code> treats the source operand as a pair of
signed 16-bit integers, by ignoring the upper 16 bits of each 32-bit half.
These integers are converted to 32-bit floating-point numbers and stored in
the destination register.
<h3><a name="section-A.179">A.179 <code><nobr>PINSRW</nobr></code>: Insert Word</a></h3>
<p><pre>
PINSRW mmxreg,r/m16,imm8      ; 0F C4 /r ib          [KATMAI]
</pre>
<p><code><nobr>PINSRW</nobr></code> loads a word from the 16-bit integer
register or memory location and inserts it in the MMX register, at a
position defined by the two least significant bits of the imm8 constant.
<p>Instead of specifying a 16-bit register you can instead specify a 32-bit
register, of which only the bottom half will be used. This may seem
peculiar, but it's the way Intel prefers.
<h3><a name="section-A.180">A.180 <code><nobr>PMACHRIW</nobr></code>: MMX Packed Multiply and Accumulate with Rounding</a></h3>
<p><pre>
PMACHRIW mmxreg,mem64         ; 0F 5E /r             [CYRIX,MMX]
</pre>
<p><code><nobr>PMACHRIW</nobr></code> acts almost identically to
<code><nobr>PMULHRIW</nobr></code> (<a href="#section-A.189">section
A.189</a>), but instead of <em>storing</em> its result in the implied
destination register, it <em>adds</em> its result, as four packed words, to
the implied destination register. No saturation is done: the addition can
wrap around.
<p>Note that <code><nobr>PMACHRIW</nobr></code> cannot take a register as
its second source operand.
<h3><a name="section-A.181">A.181 <code><nobr>PMADDWD</nobr></code>: MMX Packed Multiply and Add</a></h3>
<p><pre>
PMADDWD mmxreg,r/m64          ; 0F F5 /r             [PENT,MMX]
</pre>
<p><code><nobr>PMADDWD</nobr></code> treats its two inputs as vectors of
four signed words. It multiplies corresponding elements of the two
operands, giving four signed doubleword results. The top two of these are
added and placed in the top 32 bits of the destination (first) operand; the
bottom two are added and placed in the bottom 32 bits.
<h3><a name="section-A.182">A.182 <code><nobr>PMAGW</nobr></code>: MMX Packed Magnitude</a></h3>
<p><pre>
PMAGW mmxreg,r/m64            ; 0F 52 /r             [CYRIX,MMX]
</pre>
<p><code><nobr>PMAGW</nobr></code>, specific to the Cyrix MMX extensions,
treats both its operands as vectors of four signed words. It compares the
absolute values of the words in corresponding positions, and sets each word
of the destination (first) operand to whichever of the two words in that
position had the larger absolute value.
<h3><a name="section-A.183">A.183 <code><nobr>PMAXSW</nobr></code>: Packed Signed Integer Word Maximum</a></h3>
<p><pre>
PMAXSW mmxreg,r/m64           ; 0F EE /r             [KATMAI]
</pre>
<p><code><nobr>PMAXSW</nobr></code> considers both operands as vectors of 4
signed words. Each such word in the destination register is replaced by the
corresponding word in the source operand if that is larger.
<h3><a name="section-A.184">A.184 <code><nobr>PMAXUB</nobr></code>: Packed Unsigned Integer Byte Maximum</a></h3>
<p><pre>
PMAXUB mmxreg,r/m64           ; 0F DE /r             [KATMAI]
</pre>
<p><code><nobr>PMAXUB</nobr></code> considers both operands as vectors of 8
unsigned bytes. Each such byte in the destination register is replaced by
the corresponding byte in the source operand if that is larger.
<h3><a name="section-A.185">A.185 <code><nobr>PMINSW</nobr></code>: Packed Signed Integer Word Minimum</a></h3>
<p><pre>
PMINSW mmxreg,r/m64           ; 0F EA /r             [KATMAI]
</pre>
<p><code><nobr>PMINSW</nobr></code> considers both operands as vectors of 4
signed words. Each such word in the destination register is replaced by the
corresponding word in the source operand if that is smaller.
<h3><a name="section-A.186">A.186 <code><nobr>PMINUB</nobr></code>: Packed Unsigned Integer Byte Minimum</a></h3>
<p><pre>
PMINUB mmxreg,r/m64           ; 0F DA /r             [KATMAI]
</pre>
<p><code><nobr>PMINUB</nobr></code> considers both operands as vectors of 8
unsigned bytes. Each such byte in the destination register is replaced by
the corresponding byte in the source operand if that is smaller.
<h3><a name="section-A.187">A.187 <code><nobr>PMOVMSKB</nobr></code>: Move Byte Mask To Integer</a></h3>
<p><pre>
PMOVMSKB reg32,mmxreg         ; 0F D7 /r             [KATMAI]
</pre>
<p><code><nobr>PMOVMSKB</nobr></code> creates an 8-bit mask formed of the
most significant bit of each byte of its source operand, and stores this in
the destination register.
<h3><a name="section-A.188">A.188 <code><nobr>PMULHRWA</nobr></code>: Packed Multiply With Rounding</a></h3>
<p><pre>
PMULHRWA mmxreg,r/m64         ; 0F 0F /r B7          [3DNOW]
</pre>
<p><code><nobr>PMULHRWA</nobr></code> performs the same operation as
<code><nobr>PMULHW</nobr></code>, except that it rounds the results rather
than truncating.
<p>Note that the <code><nobr>PMULHRWA</nobr></code> instruction is called
<code><nobr>PMULHRW</nobr></code> in AMD documentation. But NASM uses the
form <code><nobr>PMULHRWA</nobr></code> to avoid conflict with Cyrix's
different <code><nobr>PMULHRW</nobr></code> instruction (which NASM calls
<code><nobr>PMULHRWC</nobr></code>).
<h3><a name="section-A.189">A.189 <code><nobr>PMULHRWC</nobr></code>, <code><nobr>PMULHRIW</nobr></code>: MMX Packed Multiply High with Rounding</a></h3>
<p><pre>
PMULHRWC mmxreg,r/m64         ; 0F 59 /r             [CYRIX,MMX] 
PMULHRIW mmxreg,r/m64         ; 0F 5D /r             [CYRIX,MMX]
</pre>
<p>These instructions, specific to the Cyrix MMX extensions, treat their
operands as vectors of four signed words. Words in corresponding positions
are multiplied, to give a 32-bit value in which bits 30 and 31 are
guaranteed equal. Bits 30 to 15 of this value (bit mask
<code><nobr>0x7FFF8000</nobr></code>) are taken and stored in the
corresponding position of the destination operand, after first rounding the
low bit (equivalent to adding <code><nobr>0x4000</nobr></code> before
extracting bits 30 to 15).
<p>For <code><nobr>PMULHRWC</nobr></code>, the destination operand is the
first operand; for <code><nobr>PMULHRIW</nobr></code> the destination
operand is implied by the first operand in the manner of
<code><nobr>PADDSIW</nobr></code> (<a href="#section-A.152">section
A.152</a>).
<p>Note that the <code><nobr>PMULHRWC</nobr></code> instruction is called
<code><nobr>PMULHRW</nobr></code> in Cyrix documentation. But NASM uses the
form <code><nobr>PMULHRWC</nobr></code> to avoid conflict with AMD's
different <code><nobr>PMULHRW</nobr></code> instruction (which NASM calls
<code><nobr>PMULHRWA</nobr></code>)
<h3><a name="section-A.190">A.190 <code><nobr>PMULHUW</nobr></code>: Packed Multiply High Unsigned</a></h3>
<p><pre>
PMULHUW mmxreg,r/m64          ; 0F E4 /r             [KATMAI]
</pre>
<p><code><nobr>PMULHUW</nobr></code> multiplies the four unsigned words in
the destination register with the four unsigned words in the source
operand. The high-order 16 bits of each of the 32-bit intermediate results
are written to the destination operand.
<h3><a name="section-A.191">A.191 <code><nobr>PMULHW</nobr></code>, <code><nobr>PMULLW</nobr></code>: MMX Packed Multiply</a></h3>
<p><pre>
PMULHW mmxreg,r/m64           ; 0F E5 /r             [PENT,MMX] 
PMULLW mmxreg,r/m64           ; 0F D5 /r             [PENT,MMX]
</pre>
<p><code><nobr>PMULxW</nobr></code> treats its two inputs as vectors of
four signed words. It multiplies corresponding elements of the two
operands, giving four signed doubleword results.
<p><code><nobr>PMULHW</nobr></code> then stores the top 16 bits of each
doubleword in the destination (first) operand;
<code><nobr>PMULLW</nobr></code> stores the bottom 16 bits of each
doubleword in the destination operand.
<h3><a name="section-A.192">A.192 <code><nobr>PMVccZB</nobr></code>: MMX Packed Conditional Move</a></h3>
<p><pre>
PMVZB mmxreg,mem64            ; 0F 58 /r             [CYRIX,MMX] 
PMVNZB mmxreg,mem64           ; 0F 5A /r             [CYRIX,MMX] 
PMVLZB mmxreg,mem64           ; 0F 5B /r             [CYRIX,MMX] 
PMVGEZB mmxreg,mem64          ; 0F 5C /r             [CYRIX,MMX]
</pre>
<p>These instructions, specific to the Cyrix MMX extensions, perform
parallel conditional moves. The two input operands are treated as vectors
of eight bytes. Each byte of the destination (first) operand is either
written from the corresponding byte of the source (second) operand, or left
alone, depending on the value of the byte in the <em>implied</em> operand
(specified in the same way as <code><nobr>PADDSIW</nobr></code>, in
<a href="#section-A.152">section A.152</a>).
<p><code><nobr>PMVZB</nobr></code> performs each move if the corresponding
byte in the implied operand is zero. <code><nobr>PMVNZB</nobr></code> moves
if the byte is non-zero. <code><nobr>PMVLZB</nobr></code> moves if the byte
is less than zero, and <code><nobr>PMVGEZB</nobr></code> moves if the byte
is greater than or equal to zero.
<p>Note that these instructions cannot take a register as their second
source operand.
<h3><a name="section-A.193">A.193 <code><nobr>POP</nobr></code>: Pop Data from Stack</a></h3>
<p><pre>
POP reg16                     ; o16 58+r             [8086] 
POP reg32                     ; o32 58+r             [386]
</pre>
<p><pre>
POP r/m16                     ; o16 8F /0            [8086] 
POP r/m32                     ; o32 8F /0            [386]
</pre>
<p><pre>
POP CS                        ; 0F                   [8086,UNDOC] 
POP DS                        ; 1F                   [8086] 
POP ES                        ; 07                   [8086] 
POP SS                        ; 17                   [8086] 
POP FS                        ; 0F A1                [386] 
POP GS                        ; 0F A9                [386]
</pre>
<p><code><nobr>POP</nobr></code> loads a value from the stack (from
<code><nobr>[SS:SP]</nobr></code> or <code><nobr>[SS:ESP]</nobr></code>)
and then increments the stack pointer.
<p>The address-size attribute of the instruction determines whether
<code><nobr>SP</nobr></code> or <code><nobr>ESP</nobr></code> is used as
the stack pointer: to deliberately override the default given by the
<code><nobr>BITS</nobr></code> setting, you can use an
<code><nobr>a16</nobr></code> or <code><nobr>a32</nobr></code> prefix.
<p>The operand-size attribute of the instruction determines whether the
stack pointer is incremented by 2 or 4: this means that segment register
pops in <code><nobr>BITS 32</nobr></code> mode will pop 4 bytes off the
stack and discard the upper two of them. If you need to override that, you
can use an <code><nobr>o16</nobr></code> or <code><nobr>o32</nobr></code>
prefix.
<p>The above opcode listings give two forms for general-purpose register
pop instructions: for example, <code><nobr>POP BX</nobr></code> has the two
forms <code><nobr>5B</nobr></code> and <code><nobr>8F C3</nobr></code>.
NASM will always generate the shorter form when given
<code><nobr>POP BX</nobr></code>. NDISASM will disassemble both.
<p><code><nobr>POP CS</nobr></code> is not a documented instruction, and is
not supported on any processor above the 8086 (since they use
<code><nobr>0Fh</nobr></code> as an opcode prefix for instruction set
extensions). However, at least some 8086 processors do support it, and so
NASM generates it for completeness.
<h3><a name="section-A.194">A.194 <code><nobr>POPAx</nobr></code>: Pop All General-Purpose Registers</a></h3>
<p><pre>
POPA                          ; 61                   [186] 
POPAW                         ; o16 61               [186] 
POPAD                         ; o32 61               [386]
</pre>
<p><code><nobr>POPAW</nobr></code> pops a word from the stack into each of,
successively, <code><nobr>DI</nobr></code>, <code><nobr>SI</nobr></code>,
<code><nobr>BP</nobr></code>, nothing (it discards a word from the stack
which was a placeholder for <code><nobr>SP</nobr></code>),
<code><nobr>BX</nobr></code>, <code><nobr>DX</nobr></code>,
<code><nobr>CX</nobr></code> and <code><nobr>AX</nobr></code>. It is
intended to reverse the operation of <code><nobr>PUSHAW</nobr></code> (see
<a href="#section-A.207">section A.207</a>), but it ignores the value for
<code><nobr>SP</nobr></code> that was pushed on the stack by
<code><nobr>PUSHAW</nobr></code>.
<p><code><nobr>POPAD</nobr></code> pops twice as much data, and places the
results in <code><nobr>EDI</nobr></code>, <code><nobr>ESI</nobr></code>,
<code><nobr>EBP</nobr></code>, nothing (placeholder for
<code><nobr>ESP</nobr></code>), <code><nobr>EBX</nobr></code>,
<code><nobr>EDX</nobr></code>, <code><nobr>ECX</nobr></code> and
<code><nobr>EAX</nobr></code>. It reverses the operation of
<code><nobr>PUSHAD</nobr></code>.
<p><code><nobr>POPA</nobr></code> is an alias mnemonic for either
<code><nobr>POPAW</nobr></code> or <code><nobr>POPAD</nobr></code>,
depending on the current <code><nobr>BITS</nobr></code> setting.
<p>Note that the registers are popped in reverse order of their numeric
values in opcodes (see <a href="#section-A.2.1">section A.2.1</a>).
<h3><a name="section-A.195">A.195 <code><nobr>POPFx</nobr></code>: Pop Flags Register</a></h3>
<p><pre>
POPF                          ; 9D                   [186] 
POPFW                         ; o16 9D               [186] 
POPFD                         ; o32 9D               [386]
</pre>
<p><code><nobr>POPFW</nobr></code> pops a word from the stack and stores it
in the bottom 16 bits of the flags register (or the whole flags register,
on processors below a 386). <code><nobr>POPFD</nobr></code> pops a
doubleword and stores it in the entire flags register.
<p><code><nobr>POPF</nobr></code> is an alias mnemonic for either
<code><nobr>POPFW</nobr></code> or <code><nobr>POPFD</nobr></code>,
depending on the current <code><nobr>BITS</nobr></code> setting.
<p>See also <code><nobr>PUSHF</nobr></code>
(<a href="#section-A.208">section A.208</a>).
<h3><a name="section-A.196">A.196 <code><nobr>POR</nobr></code>: MMX Bitwise OR</a></h3>
<p><pre>
POR mmxreg,r/m64              ; 0F EB /r             [PENT,MMX]
</pre>
<p><code><nobr>POR</nobr></code> performs a bitwise OR operation between
its two operands (i.e. each bit of the result is 1 if and only if at least
one of the corresponding bits of the two inputs was 1), and stores the
result in the destination (first) operand.
<h3><a name="section-A.197">A.197 <code><nobr>PREFETCH</nobr></code>, <code><nobr>PREFETCHW</nobr></code>: Prefetch cache line</a></h3>
<p><pre>
PREFETCH mem                  ; 0F 0D /0             [3DNOW] 
PREFETCHW mem                 ; 0F 0D /1             [3DNOW]
</pre>
<p><code><nobr>PREFETCH</nobr></code> loads a cache line into the L1 data
cache. <code><nobr>PREFETCHW</nobr></code> does the same, but also marks
the cache line as modified.
<h3><a name="section-A.198">A.198 <code><nobr>PREFETCHNTA</nobr></code>, <code><nobr>PREFETCHT0</nobr></code>, <code><nobr>PREFETCHT1</nobr></code>, <code><nobr>PREFETCHT2</nobr></code>: Prefetch cache line</a></h3>
<p><pre>
PREFETCHNTA mem               ; 0F 18 /0             [KATMAI] 
PREFETCHT0 mem                ; 0F 18 /1             [KATMAI] 
PREFETCHT1 mem                ; 0F 18 /2             [KATMAI] 
PREFETCHT2 mem                ; 0F 18 /3             [KATMAI]
</pre>
<p>These instructions move the data specified by the address closer to the
processor using, respectively, the nta, t0, t1 and t2 hints.
<h3><a name="section-A.199">A.199 <code><nobr>PSADBW</nobr></code>: Packed Sum of Absolute Differences</a></h3>
<p><pre>
PSADBW mmxreg,r/m64           ; 0F F6 /r             [KATMAI]
</pre>
<p><code><nobr>PSADBW</nobr></code> computes the sum of the absolute
differences of the unsigned signed bytes in the destination register and
those in the source operand. It then places this sum in the lowest word of
the destination register, and sets the three other words to zero.
<h3><a name="section-A.200">A.200 <code><nobr>PSHUFW</nobr></code>: Packed Shuffle Word</a></h3>
<p><pre>
PSHUFW mmxreg,r/m64,imm8      ; 0F 70 /r ib          [KATMAI]
</pre>
<p><code><nobr>PSHUFW</nobr></code> uses the imm8 value to select which of
the four words of the source operand will be placed in each of the words of
the destination register. Bits 0 and 1 of imm8 encode the source for word 0
(the lowest word) of the destination register, bits 2 and 3 encode the
source for word 1, bits 4 and 5 for word 2, and bits 6 and 7 for word 3
(the highest word). Each 2-bit encoding is a number in the range 0-3 that
specifies the corresponding word of the source operand.
<h3><a name="section-A.201">A.201 <code><nobr>PSLLx</nobr></code>, <code><nobr>PSRLx</nobr></code>, <code><nobr>PSRAx</nobr></code>: MMX Bit Shifts</a></h3>
<p><pre>
PSLLW mmxreg,r/m64            ; 0F F1 /r             [PENT,MMX] 
PSLLW mmxreg,imm8             ; 0F 71 /6 ib          [PENT,MMX]
</pre>
<p><pre>
PSLLD mmxreg,r/m64            ; 0F F2 /r             [PENT,MMX] 
PSLLD mmxreg,imm8             ; 0F 72 /6 ib          [PENT,MMX]
</pre>
<p><pre>
PSLLQ mmxreg,r/m64            ; 0F F3 /r             [PENT,MMX] 
PSLLQ mmxreg,imm8             ; 0F 73 /6 ib          [PENT,MMX]
</pre>
<p><pre>
PSRAW mmxreg,r/m64            ; 0F E1 /r             [PENT,MMX] 
PSRAW mmxreg,imm8             ; 0F 71 /4 ib          [PENT,MMX]
</pre>
<p><pre>
PSRAD mmxreg,r/m64            ; 0F E2 /r             [PENT,MMX] 
PSRAD mmxreg,imm8             ; 0F 72 /4 ib          [PENT,MMX]
</pre>
<p><pre>
PSRLW mmxreg,r/m64            ; 0F D1 /r             [PENT,MMX] 
PSRLW mmxreg,imm8             ; 0F 71 /2 ib          [PENT,MMX]
</pre>
<p><pre>
PSRLD mmxreg,r/m64            ; 0F D2 /r             [PENT,MMX] 
PSRLD mmxreg,imm8             ; 0F 72 /2 ib          [PENT,MMX]
</pre>
<p><pre>
PSRLQ mmxreg,r/m64            ; 0F D3 /r             [PENT,MMX] 
PSRLQ mmxreg,imm8             ; 0F 73 /2 ib          [PENT,MMX]
</pre>
<p><code><nobr>PSxxQ</nobr></code> perform simple bit shifts on the 64-bit
MMX registers: the destination (first) operand is shifted left or right by
the number of bits given in the source (second) operand, and the vacated
bits are filled in with zeros (for a logical shift) or copies of the
original sign bit (for an arithmetic right shift).
<p><code><nobr>PSxxW</nobr></code> and <code><nobr>PSxxD</nobr></code>
perform packed bit shifts: the destination operand is treated as a vector
of four words or two doublewords, and each element is shifted individually,
so bits shifted out of one element do not interfere with empty bits coming
into the next.
<p><code><nobr>PSLLx</nobr></code> and <code><nobr>PSRLx</nobr></code>
perform logical shifts: the vacated bits at one end of the shifted number
are filled with zeros. <code><nobr>PSRAx</nobr></code> performs an
arithmetic right shift: the vacated bits at the top of the shifted number
are filled with copies of the original top (sign) bit.
<h3><a name="section-A.202">A.202 <code><nobr>PSUBxx</nobr></code>: MMX Packed Subtraction</a></h3>
<p><pre>
PSUBB mmxreg,r/m64            ; 0F F8 /r             [PENT,MMX] 
PSUBW mmxreg,r/m64            ; 0F F9 /r             [PENT,MMX] 
PSUBD mmxreg,r/m64            ; 0F FA /r             [PENT,MMX]
</pre>
<p><pre>
PSUBSB mmxreg,r/m64           ; 0F E8 /r             [PENT,MMX] 
PSUBSW mmxreg,r/m64           ; 0F E9 /r             [PENT,MMX]
</pre>
<p><pre>
PSUBUSB mmxreg,r/m64          ; 0F D8 /r             [PENT,MMX] 
PSUBUSW mmxreg,r/m64          ; 0F D9 /r             [PENT,MMX]
</pre>
<p><code><nobr>PSUBxx</nobr></code> all perform packed subtraction between
their two 64-bit operands, storing the result in the destination (first)
operand. The <code><nobr>PSUBxB</nobr></code> forms treat the 64-bit
operands as vectors of eight bytes, and subtract each byte individually;
<code><nobr>PSUBxW</nobr></code> treat the operands as vectors of four
words; and <code><nobr>PSUBD</nobr></code> treats its operands as vectors
of two doublewords.
<p>In all cases, the elements of the operand on the right are subtracted
from the corresponding elements of the operand on the left, not the other
way round.
<p><code><nobr>PSUBSB</nobr></code> and <code><nobr>PSUBSW</nobr></code>
perform signed saturation on the sum of each pair of bytes or words: if the
result of a subtraction is too large or too small to fit into a signed byte
or word result, it is clipped (saturated) to the largest or smallest value
which <em>will</em> fit. <code><nobr>PSUBUSB</nobr></code> and
<code><nobr>PSUBUSW</nobr></code> similarly perform unsigned saturation,
clipping to <code><nobr>0FFh</nobr></code> or
<code><nobr>0FFFFh</nobr></code> if the result is larger than that.
<h3><a name="section-A.203">A.203 <code><nobr>PSUBSIW</nobr></code>: MMX Packed Subtract with Saturation to Implied Destination</a></h3>
<p><pre>
PSUBSIW mmxreg,r/m64          ; 0F 55 /r             [CYRIX,MMX]
</pre>
<p><code><nobr>PSUBSIW</nobr></code>, specific to the Cyrix extensions to
the MMX instruction set, performs the same function as
<code><nobr>PSUBSW</nobr></code>, except that the result is not placed in
the register specified by the first operand, but instead in the implied
destination register, specified as for <code><nobr>PADDSIW</nobr></code>
(<a href="#section-A.152">section A.152</a>).
<h3><a name="section-A.204">A.204 <code><nobr>PSWAPD</nobr></code>: Packed Swap Doubleword</a></h3>
<p><pre>
PSWAPD mmxreg,r/m64           ; 0F 0F /r BB          [ATHLON]
</pre>
<p><code><nobr>PSWAPD</nobr></code> copies the source operand to the
destination register, swapping the upper and lower halves in the process.
<h3><a name="section-A.205">A.205 <code><nobr>PUNPCKxxx</nobr></code>: Unpack Data</a></h3>
<p><pre>
PUNPCKHBW mmxreg,r/m64        ; 0F 68 /r             [PENT,MMX] 
PUNPCKHWD mmxreg,r/m64        ; 0F 69 /r             [PENT,MMX] 
PUNPCKHDQ mmxreg,r/m64        ; 0F 6A /r             [PENT,MMX]
</pre>
<p><pre>
PUNPCKLBW mmxreg,r/m64        ; 0F 60 /r             [PENT,MMX] 
PUNPCKLWD mmxreg,r/m64        ; 0F 61 /r             [PENT,MMX] 
PUNPCKLDQ mmxreg,r/m64        ; 0F 62 /r             [PENT,MMX]
</pre>
<p><code><nobr>PUNPCKxx</nobr></code> all treat their operands as vectors,
and produce a new vector generated by interleaving elements from the two
inputs. The <code><nobr>PUNPCKHxx</nobr></code> instructions start by
throwing away the bottom half of each input operand, and the
<code><nobr>PUNPCKLxx</nobr></code> instructions throw away the top half.
<p>The remaining elements, totalling 64 bits, are then interleaved into the
destination, alternating elements from the second (source) operand and the
first (destination) operand: so the leftmost element in the result always
comes from the second operand, and the rightmost from the destination.
<p><code><nobr>PUNPCKxBW</nobr></code> works a byte at a time,
<code><nobr>PUNPCKxWD</nobr></code> a word at a time, and
<code><nobr>PUNPCKxDQ</nobr></code> a doubleword at a time.
<p>So, for example, if the first operand held
<code><nobr>0x7A6A5A4A3A2A1A0A</nobr></code> and the second held
<code><nobr>0x7B6B5B4B3B2B1B0B</nobr></code>, then:
<ul>
<li><code><nobr>PUNPCKHBW</nobr></code> would return
<code><nobr>0x7B7A6B6A5B5A4B4A</nobr></code>.
<li><code><nobr>PUNPCKHWD</nobr></code> would return
<code><nobr>0x7B6B7A6A5B4B5A4A</nobr></code>.
<li><code><nobr>PUNPCKHDQ</nobr></code> would return
<code><nobr>0x7B6B5B4B7A6A5A4A</nobr></code>.
<li><code><nobr>PUNPCKLBW</nobr></code> would return
<code><nobr>0x3B3A2B2A1B1A0B0A</nobr></code>.
<li><code><nobr>PUNPCKLWD</nobr></code> would return
<code><nobr>0x3B2B3A2A1B0B1A0A</nobr></code>.
<li><code><nobr>PUNPCKLDQ</nobr></code> would return
<code><nobr>0x3B2B1B0B3A2A1A0A</nobr></code>.
</ul>
<h3><a name="section-A.206">A.206 <code><nobr>PUSH</nobr></code>: Push Data on Stack</a></h3>
<p><pre>
PUSH reg16                    ; o16 50+r             [8086] 
PUSH reg32                    ; o32 50+r             [386]
</pre>
<p><pre>
PUSH r/m16                    ; o16 FF /6            [8086] 
PUSH r/m32                    ; o32 FF /6            [386]
</pre>
<p><pre>
PUSH CS                       ; 0E                   [8086] 
PUSH DS                       ; 1E                   [8086] 
PUSH ES                       ; 06                   [8086] 
PUSH SS                       ; 16                   [8086] 
PUSH FS                       ; 0F A0                [386] 
PUSH GS                       ; 0F A8                [386]
</pre>
<p><pre>
PUSH imm8                     ; 6A ib                [286] 
PUSH imm16                    ; o16 68 iw            [286] 
PUSH imm32                    ; o32 68 id            [386]
</pre>
<p><code><nobr>PUSH</nobr></code> decrements the stack pointer
(<code><nobr>SP</nobr></code> or <code><nobr>ESP</nobr></code>) by 2 or 4,
and then stores the given value at <code><nobr>[SS:SP]</nobr></code> or
<code><nobr>[SS:ESP]</nobr></code>.
<p>The address-size attribute of the instruction determines whether
<code><nobr>SP</nobr></code> or <code><nobr>ESP</nobr></code> is used as
the stack pointer: to deliberately override the default given by the
<code><nobr>BITS</nobr></code> setting, you can use an
<code><nobr>a16</nobr></code> or <code><nobr>a32</nobr></code> prefix.
<p>The operand-size attribute of the instruction determines whether the
stack pointer is decremented by 2 or 4: this means that segment register
pushes in <code><nobr>BITS 32</nobr></code> mode will push 4 bytes on the
stack, of which the upper two are undefined. If you need to override that,
you can use an <code><nobr>o16</nobr></code> or
<code><nobr>o32</nobr></code> prefix.
<p>The above opcode listings give two forms for general-purpose register
push instructions: for example, <code><nobr>PUSH BX</nobr></code> has the
two forms <code><nobr>53</nobr></code> and <code><nobr>FF F3</nobr></code>.
NASM will always generate the shorter form when given
<code><nobr>PUSH BX</nobr></code>. NDISASM will disassemble both.
<p>Unlike the undocumented and barely supported
<code><nobr>POP CS</nobr></code>, <code><nobr>PUSH CS</nobr></code> is a
perfectly valid and sensible instruction, supported on all processors.
<p>The instruction <code><nobr>PUSH SP</nobr></code> may be used to
distinguish an 8086 from later processors: on an 8086, the value of
<code><nobr>SP</nobr></code> stored is the value it has <em>after</em> the
push instruction, whereas on later processors it is the value
<em>before</em> the push instruction.
<h3><a name="section-A.207">A.207 <code><nobr>PUSHAx</nobr></code>: Push All General-Purpose Registers</a></h3>
<p><pre>
PUSHA                         ; 60                   [186] 
PUSHAD                        ; o32 60               [386] 
PUSHAW                        ; o16 60               [186]
</pre>
<p><code><nobr>PUSHAW</nobr></code> pushes, in succession,
<code><nobr>AX</nobr></code>, <code><nobr>CX</nobr></code>,
<code><nobr>DX</nobr></code>, <code><nobr>BX</nobr></code>,
<code><nobr>SP</nobr></code>, <code><nobr>BP</nobr></code>,
<code><nobr>SI</nobr></code> and <code><nobr>DI</nobr></code> on the stack,
decrementing the stack pointer by a total of 16.
<p><code><nobr>PUSHAD</nobr></code> pushes, in succession,
<code><nobr>EAX</nobr></code>, <code><nobr>ECX</nobr></code>,
<code><nobr>EDX</nobr></code>, <code><nobr>EBX</nobr></code>,
<code><nobr>ESP</nobr></code>, <code><nobr>EBP</nobr></code>,
<code><nobr>ESI</nobr></code> and <code><nobr>EDI</nobr></code> on the
stack, decrementing the stack pointer by a total of 32.
<p>In both cases, the value of <code><nobr>SP</nobr></code> or
<code><nobr>ESP</nobr></code> pushed is its <em>original</em> value, as it
had before the instruction was executed.
<p><code><nobr>PUSHA</nobr></code> is an alias mnemonic for either
<code><nobr>PUSHAW</nobr></code> or <code><nobr>PUSHAD</nobr></code>,
depending on the current <code><nobr>BITS</nobr></code> setting.
<p>Note that the registers are pushed in order of their numeric values in
opcodes (see <a href="#section-A.2.1">section A.2.1</a>).
<p>See also <code><nobr>POPA</nobr></code>
(<a href="#section-A.194">section A.194</a>).
<h3><a name="section-A.208">A.208 <code><nobr>PUSHFx</nobr></code>: Push Flags Register</a></h3>
<p><pre>
PUSHF                         ; 9C                   [186] 
PUSHFD                        ; o32 9C               [386] 
PUSHFW                        ; o16 9C               [186]
</pre>
<p><code><nobr>PUSHFW</nobr></code> pops a word from the stack and stores
it in the bottom 16 bits of the flags register (or the whole flags
register, on processors below a 386). <code><nobr>PUSHFD</nobr></code> pops
a doubleword and stores it in the entire flags register.
<p><code><nobr>PUSHF</nobr></code> is an alias mnemonic for either
<code><nobr>PUSHFW</nobr></code> or <code><nobr>PUSHFD</nobr></code>,
depending on the current <code><nobr>BITS</nobr></code> setting.
<p>See also <code><nobr>POPF</nobr></code>
(<a href="#section-A.195">section A.195</a>).
<h3><a name="section-A.209">A.209 <code><nobr>PXOR</nobr></code>: MMX Bitwise XOR</a></h3>
<p><pre>
PXOR mmxreg,r/m64             ; 0F EF /r             [PENT,MMX]
</pre>
<p><code><nobr>PXOR</nobr></code> performs a bitwise XOR operation between
its two operands (i.e. each bit of the result is 1 if and only if exactly
one of the corresponding bits of the two inputs was 1), and stores the
result in the destination (first) operand.
<h3><a name="section-A.210">A.210 <code><nobr>RCL</nobr></code>, <code><nobr>RCR</nobr></code>: Bitwise Rotate through Carry Bit</a></h3>
<p><pre>
RCL r/m8,1                    ; D0 /2                [8086] 
RCL r/m8,CL                   ; D2 /2                [8086] 
RCL r/m8,imm8                 ; C0 /2 ib             [286] 
RCL r/m16,1                   ; o16 D1 /2            [8086] 
RCL r/m16,CL                  ; o16 D3 /2            [8086] 
RCL r/m16,imm8                ; o16 C1 /2 ib         [286] 
RCL r/m32,1                   ; o32 D1 /2            [386] 
RCL r/m32,CL                  ; o32 D3 /2            [386] 
RCL r/m32,imm8                ; o32 C1 /2 ib         [386]
</pre>
<p><pre>
RCR r/m8,1                    ; D0 /3                [8086] 
RCR r/m8,CL                   ; D2 /3                [8086] 
RCR r/m8,imm8                 ; C0 /3 ib             [286] 
RCR r/m16,1                   ; o16 D1 /3            [8086] 
RCR r/m16,CL                  ; o16 D3 /3            [8086] 
RCR r/m16,imm8                ; o16 C1 /3 ib         [286] 
RCR r/m32,1                   ; o32 D1 /3            [386] 
RCR r/m32,CL                  ; o32 D3 /3            [386] 
RCR r/m32,imm8                ; o32 C1 /3 ib         [386]
</pre>
<p><code><nobr>RCL</nobr></code> and <code><nobr>RCR</nobr></code> perform
a 9-bit, 17-bit or 33-bit bitwise rotation operation, involving the given
source/destination (first) operand and the carry bit. Thus, for example, in
the operation <code><nobr>RCR AL,1</nobr></code>, a 9-bit rotation is
performed in which <code><nobr>AL</nobr></code> is shifted left by 1, the
top bit of <code><nobr>AL</nobr></code> moves into the carry flag, and the
original value of the carry flag is placed in the low bit of
<code><nobr>AL</nobr></code>.
<p>The number of bits to rotate by is given by the second operand. Only the
bottom five bits of the rotation count are considered by processors above
the 8086.
<p>You can force the longer (286 and upwards, beginning with a
<code><nobr>C1</nobr></code> byte) form of
<code><nobr>RCL foo,1</nobr></code> by using a
<code><nobr>BYTE</nobr></code> prefix:
<code><nobr>RCL foo,BYTE 1</nobr></code>. Similarly with
<code><nobr>RCR</nobr></code>.
<h3><a name="section-A.211">A.211 <code><nobr>RCPPS</nobr></code>: SSE Packed Single-FP Reciprocal Approximation</a></h3>
<p><pre>
RCPPS xmmreg,r/m128           ; 0F 53 /r             [KATMAI,SSE]
</pre>
<p>Four each of the four 32-bit floating-point numbers in the source
operand <code><nobr>RCPPS</nobr></code> calculates an approximation of the
reciprocal and stores it in the corresponding quarter of the destination
register. The absolute value of the error for each of these approximations
is at most 3/8192.
<h3><a name="section-A.212">A.212 <code><nobr>RCPSS</nobr></code>: SSE Scalar Single-FP Reciprocal Approximation</a></h3>
<p><pre>
RCPSS xmmreg,xmmreg/mem32     ; F3 0F 53 /r          [KATMAI,SSE]
</pre>
<p><code><nobr>RCPSS</nobr></code> calculates an approximation of the
reciprocal of the 32-bit floating-point in the source operand (using the
lowest quarter of the source operand if it is a register) and places the
result in the lowest quarter of the destination register. The absolute
value of the error for this approximation is at most 3/8192.
<h3><a name="section-A.213">A.213 <code><nobr>RDMSR</nobr></code>: Read Model-Specific Registers</a></h3>
<p><pre>
RDMSR                         ; 0F 32                [PENT]
</pre>
<p><code><nobr>RDMSR</nobr></code> reads the processor Model-Specific
Register (MSR) whose index is stored in <code><nobr>ECX</nobr></code>, and
stores the result in <code><nobr>EDX:EAX</nobr></code>. See also
<code><nobr>WRMSR</nobr></code> (<a href="#section-A.264">section
A.264</a>).
<h3><a name="section-A.214">A.214 <code><nobr>RDPMC</nobr></code>: Read Performance-Monitoring Counters</a></h3>
<p><pre>
RDPMC                         ; 0F 33                [P6]
</pre>
<p><code><nobr>RDPMC</nobr></code> reads the processor
performance-monitoring counter whose index is stored in
<code><nobr>ECX</nobr></code>, and stores the result in
<code><nobr>EDX:EAX</nobr></code>.
<h3><a name="section-A.215">A.215 <code><nobr>RDSHR</nobr></code>: Read SMM Header Pointer Register</a></h3>
<p><pre>
RDSHR                         ; 0F 36                [P6,CYRIX,SMM]
</pre>
<h3><a name="section-A.216">A.216 <code><nobr>RDTSC</nobr></code>: Read Time-Stamp Counter</a></h3>
<p><pre>
RDTSC                         ; 0F 31                [PENT]
</pre>
<p><code><nobr>RDTSC</nobr></code> reads the processor's time-stamp counter
into <code><nobr>EDX:EAX</nobr></code>.
<h3><a name="section-A.217">A.217 <code><nobr>RET</nobr></code>, <code><nobr>RETF</nobr></code>, <code><nobr>RETN</nobr></code>: Return from Procedure Call</a></h3>
<p><pre>
RET                           ; C3                   [8086] 
RET imm16                     ; C2 iw                [8086]
</pre>
<p><pre>
RETF                          ; CB                   [8086] 
RETF imm16                    ; CA iw                [8086]
</pre>
<p><pre>
RETN                          ; C3                   [8086] 
RETN imm16                    ; C2 iw                [8086]
</pre>
<p><code><nobr>RET</nobr></code>, and its exact synonym
<code><nobr>RETN</nobr></code>, pop <code><nobr>IP</nobr></code> or
<code><nobr>EIP</nobr></code> from the stack and transfer control to the
new address. Optionally, if a numeric second operand is provided, they
increment the stack pointer by a further <code><nobr>imm16</nobr></code>
bytes after popping the return address.
<p><code><nobr>RETF</nobr></code> executes a far return: after popping
<code><nobr>IP</nobr></code>/<code><nobr>EIP</nobr></code>, it then pops
<code><nobr>CS</nobr></code>, and <em>then</em> increments the stack
pointer by the optional argument if present.
<h3><a name="section-A.218">A.218 <code><nobr>ROL</nobr></code>, <code><nobr>ROR</nobr></code>: Bitwise Rotate</a></h3>
<p><pre>
ROL r/m8,1                    ; D0 /0                [8086] 
ROL r/m8,CL                   ; D2 /0                [8086] 
ROL r/m8,imm8                 ; C0 /0 ib             [286] 
ROL r/m16,1                   ; o16 D1 /0            [8086] 
ROL r/m16,CL                  ; o16 D3 /0            [8086] 
ROL r/m16,imm8                ; o16 C1 /0 ib         [286] 
ROL r/m32,1                   ; o32 D1 /0            [386] 
ROL r/m32,CL                  ; o32 D3 /0            [386] 
ROL r/m32,imm8                ; o32 C1 /0 ib         [386]
</pre>
<p><pre>
ROR r/m8,1                    ; D0 /1                [8086] 
ROR r/m8,CL                   ; D2 /1                [8086] 
ROR r/m8,imm8                 ; C0 /1 ib             [286] 
ROR r/m16,1                   ; o16 D1 /1            [8086] 
ROR r/m16,CL                  ; o16 D3 /1            [8086] 
ROR r/m16,imm8                ; o16 C1 /1 ib         [286] 
ROR r/m32,1                   ; o32 D1 /1            [386] 
ROR r/m32,CL                  ; o32 D3 /1            [386] 
ROR r/m32,imm8                ; o32 C1 /1 ib         [386]
</pre>
<p><code><nobr>ROL</nobr></code> and <code><nobr>ROR</nobr></code> perform
a bitwise rotation operation on the given source/destination (first)
operand. Thus, for example, in the operation
<code><nobr>ROR AL,1</nobr></code>, an 8-bit rotation is performed in which
<code><nobr>AL</nobr></code> is shifted left by 1 and the original top bit
of <code><nobr>AL</nobr></code> moves round into the low bit.
<p>The number of bits to rotate by is given by the second operand. Only the
bottom 3, 4 or 5 bits (depending on the source operand size) of the
rotation count are considered by processors above the 8086.
<p>You can force the longer (286 and upwards, beginning with a
<code><nobr>C1</nobr></code> byte) form of
<code><nobr>ROL foo,1</nobr></code> by using a
<code><nobr>BYTE</nobr></code> prefix:
<code><nobr>ROL foo,BYTE 1</nobr></code>. Similarly with
<code><nobr>ROR</nobr></code>.
<h3><a name="section-A.219">A.219 <code><nobr>RSDC</nobr></code>: Restore Segment Register and Descriptor</a></h3>
<p><pre>
RSDC segreg,mem80             ; 0F 79 /r             [486,CYRIX,SMM]
</pre>
<h3><a name="section-A.220">A.220 <code><nobr>RSLDT</nobr></code>: Restore LDTR and Descriptor</a></h3>
<p><pre>
RSLDT mem80                   ; 0F 7B /0             [486,CYRIX,SMM]
</pre>
<h3><a name="section-A.221">A.221 <code><nobr>RSM</nobr></code>: Resume from System-Management Mode</a></h3>
<p><pre>
RSM                           ; 0F AA                [PENT]
</pre>
<p><code><nobr>RSM</nobr></code> returns the processor to its normal
operating mode when it was in System-Management Mode.
<h3><a name="section-A.222">A.222 <code><nobr>RSQRTPS</nobr></code>: Packed Single-FP Square Root Reciprocal</a></h3>
<p><pre>
RSQRTPS xmmreg,r/m128         ; 0F 52 /r             [KATMAI,SSE]
</pre>
<p>For each of the four 32-bit floating-point numbers in the source
operand, <code><nobr>RSQRTPS</nobr></code> computes an approximation of the
reciprocal of the square root, and puts this in the corresponding quarter
of the destination register. The maximum absolute error for this
approximation is 3/8192.
<h3><a name="section-A.223">A.223 <code><nobr>RSQRTSS</nobr></code>:Scalar Single-FP Square Root Reciprocal</a></h3>
<p><pre>
RSQRTSS xmmreg,r/m128         ; F3 0F 52 /r          [KATMAI,SSE]
</pre>
<p><code><nobr>RSQRTSS</nobr></code> computes an approximation of the
reciprocal of the square root of the first 32-bit floating-point number
from xmm2/m32 and puts it in the lowest quarter of the destination
register. The maximum absolute error for this approximation is 3/8192.
<h3><a name="section-A.224">A.224 <code><nobr>RSTS</nobr></code>: Restore TSR and Descriptor</a></h3>
<p><pre>
RSTS mem80                    ; 0F 7D /0             [486,CYRIX,SMM]
</pre>
<h3><a name="section-A.225">A.225 <code><nobr>SAHF</nobr></code>: Store AH to Flags</a></h3>
<p><pre>
SAHF                          ; 9E                   [8086]
</pre>
<p><code><nobr>SAHF</nobr></code> sets the low byte of the flags word
according to the contents of the <code><nobr>AH</nobr></code> register. See
also <code><nobr>LAHF</nobr></code> (<a href="#section-A.108">section
A.108</a>).
<h3><a name="section-A.226">A.226 <code><nobr>SAL</nobr></code>, <code><nobr>SAR</nobr></code>: Bitwise Arithmetic Shifts</a></h3>
<p><pre>
SAL r/m8,1                    ; D0 /4                [8086] 
SAL r/m8,CL                   ; D2 /4                [8086] 
SAL r/m8,imm8                 ; C0 /4 ib             [286] 
SAL r/m16,1                   ; o16 D1 /4            [8086] 
SAL r/m16,CL                  ; o16 D3 /4            [8086] 
SAL r/m16,imm8                ; o16 C1 /4 ib         [286] 
SAL r/m32,1                   ; o32 D1 /4            [386] 
SAL r/m32,CL                  ; o32 D3 /4            [386] 
SAL r/m32,imm8                ; o32 C1 /4 ib         [386]
</pre>
<p><pre>
SAR r/m8,1                    ; D0 /0                [8086] 
SAR r/m8,CL                   ; D2 /0                [8086] 
SAR r/m8,imm8                 ; C0 /0 ib             [286] 
SAR r/m16,1                   ; o16 D1 /0            [8086] 
SAR r/m16,CL                  ; o16 D3 /0            [8086] 
SAR r/m16,imm8                ; o16 C1 /0 ib         [286] 
SAR r/m32,1                   ; o32 D1 /0            [386] 
SAR r/m32,CL                  ; o32 D3 /0            [386] 
SAR r/m32,imm8                ; o32 C1 /0 ib         [386]
</pre>
<p><code><nobr>SAL</nobr></code> and <code><nobr>SAR</nobr></code> perform
an arithmetic shift operation on the given source/destination (first)
operand. The vacated bits are filled with zero for
<code><nobr>SAL</nobr></code>, and with copies of the original high bit of
the source operand for <code><nobr>SAR</nobr></code>.
<p><code><nobr>SAL</nobr></code> is a synonym for
<code><nobr>SHL</nobr></code> (see <a href="#section-A.233">section
A.233</a>). NASM will assemble either one to the same code, but NDISASM
will always disassemble that code as <code><nobr>SHL</nobr></code>.
<p>The number of bits to shift by is given by the second operand. Only the
bottom 3, 4 or 5 bits (depending on the source operand size) of the shift
count are considered by processors above the 8086.
<p>You can force the longer (286 and upwards, beginning with a
<code><nobr>C1</nobr></code> byte) form of
<code><nobr>SAL foo,1</nobr></code> by using a
<code><nobr>BYTE</nobr></code> prefix:
<code><nobr>SAL foo,BYTE 1</nobr></code>. Similarly with
<code><nobr>SAR</nobr></code>.
<h3><a name="section-A.227">A.227 <code><nobr>SALC</nobr></code>: Set AL from Carry Flag</a></h3>
<p><pre>
SALC                          ; D6                  [8086,UNDOC]
</pre>
<p><code><nobr>SALC</nobr></code> is an early undocumented instruction
similar in concept to <code><nobr>SETcc</nobr></code>
(<a href="#section-A.230">section A.230</a>). Its function is to set
<code><nobr>AL</nobr></code> to zero if the carry flag is clear, or to
<code><nobr>0xFF</nobr></code> if it is set.
<h3><a name="section-A.228">A.228 <code><nobr>SBB</nobr></code>: Subtract with Borrow</a></h3>
<p><pre>
SBB r/m8,reg8                 ; 18 /r                [8086] 
SBB r/m16,reg16               ; o16 19 /r            [8086] 
SBB r/m32,reg32               ; o32 19 /r            [386]
</pre>
<p><pre>
SBB reg8,r/m8                 ; 1A /r                [8086] 
SBB reg16,r/m16               ; o16 1B /r            [8086] 
SBB reg32,r/m32               ; o32 1B /r            [386]
</pre>
<p><pre>
SBB r/m8,imm8                 ; 80 /3 ib             [8086] 
SBB r/m16,imm16               ; o16 81 /3 iw         [8086] 
SBB r/m32,imm32               ; o32 81 /3 id         [386]
</pre>
<p><pre>
SBB r/m16,imm8                ; o16 83 /3 ib         [8086] 
SBB r/m32,imm8                ; o32 83 /3 ib         [8086]
</pre>
<p><pre>
SBB AL,imm8                   ; 1C ib                [8086] 
SBB AX,imm16                  ; o16 1D iw            [8086] 
SBB EAX,imm32                 ; o32 1D id            [386]
</pre>
<p><code><nobr>SBB</nobr></code> performs integer subtraction: it subtracts
its second operand, plus the value of the carry flag, from its first, and
leaves the result in its destination (first) operand. The flags are set
according to the result of the operation: in particular, the carry flag is
affected and can be used by a subsequent <code><nobr>SBB</nobr></code>
instruction.
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<p>To subtract one number from another without also subtracting the
contents of the carry flag, use <code><nobr>SUB</nobr></code>
(<a href="#section-A.245">section A.245</a>).
<h3><a name="section-A.229">A.229 <code><nobr>SCASB</nobr></code>, <code><nobr>SCASW</nobr></code>, <code><nobr>SCASD</nobr></code>: Scan String</a></h3>
<p><pre>
SCASB                         ; AE                   [8086] 
SCASW                         ; o16 AF               [8086] 
SCASD                         ; o32 AF               [386]
</pre>
<p><code><nobr>SCASB</nobr></code> compares the byte in
<code><nobr>AL</nobr></code> with the byte at
<code><nobr>[ES:DI]</nobr></code> or <code><nobr>[ES:EDI]</nobr></code>,
and sets the flags accordingly. It then increments or decrements (depending
on the direction flag: increments if the flag is clear, decrements if it is
set) <code><nobr>DI</nobr></code> (or <code><nobr>EDI</nobr></code>).
<p>The register used is <code><nobr>DI</nobr></code> if the address size is
16 bits, and <code><nobr>EDI</nobr></code> if it is 32 bits. If you need to
use an address size not equal to the current <code><nobr>BITS</nobr></code>
setting, you can use an explicit <code><nobr>a16</nobr></code> or
<code><nobr>a32</nobr></code> prefix.
<p>Segment override prefixes have no effect for this instruction: the use
of <code><nobr>ES</nobr></code> for the load from
<code><nobr>[DI]</nobr></code> or <code><nobr>[EDI]</nobr></code> cannot be
overridden.
<p><code><nobr>SCASW</nobr></code> and <code><nobr>SCASD</nobr></code> work
in the same way, but they compare a word to <code><nobr>AX</nobr></code> or
a doubleword to <code><nobr>EAX</nobr></code> instead of a byte to
<code><nobr>AL</nobr></code>, and increment or decrement the addressing
registers by 2 or 4 instead of 1.
<p>The <code><nobr>REPE</nobr></code> and <code><nobr>REPNE</nobr></code>
prefixes (equivalently, <code><nobr>REPZ</nobr></code> and
<code><nobr>REPNZ</nobr></code>) may be used to repeat the instruction up
to <code><nobr>CX</nobr></code> (or <code><nobr>ECX</nobr></code> - again,
the address size chooses which) times until the first unequal or equal byte
is found.
<h3><a name="section-A.230">A.230 <code><nobr>SETcc</nobr></code>: Set Register from Condition</a></h3>
<p><pre>
SETcc r/m8                    ; 0F 90+cc /2          [386]
</pre>
<p><code><nobr>SETcc</nobr></code> sets the given 8-bit operand to zero if
its condition is not satisfied, and to 1 if it is.
<h3><a name="section-A.231">A.231 <code><nobr>SFENCE</nobr></code>: Store Fence</a></h3>
<p><pre>
SFENCE                        ; 0F AE /7             [KATMAI]
</pre>
<p><code><nobr>SFENCE</nobr></code> guarantees that all store instructions
which precede it in the program order are globally visible before any store
instructions which follow it.
<h3><a name="section-A.232">A.232 <code><nobr>SGDT</nobr></code>, <code><nobr>SIDT</nobr></code>, <code><nobr>SLDT</nobr></code>: Store Descriptor Table Pointers</a></h3>
<p><pre>
SGDT mem                      ; 0F 01 /0             [286,PRIV] 
SIDT mem                      ; 0F 01 /1             [286,PRIV] 
SLDT r/m16                    ; 0F 00 /0             [286,PRIV]
</pre>
<p><code><nobr>SGDT</nobr></code> and <code><nobr>SIDT</nobr></code> both
take a 6-byte memory area as an operand: they store the contents of the
GDTR (global descriptor table register) or IDTR (interrupt descriptor table
register) into that area as a 32-bit linear address and a 16-bit size limit
from that area (in that order). These are the only instructions which
directly use <em>linear</em> addresses, rather than segment/offset pairs.
<p><code><nobr>SLDT</nobr></code> stores the segment selector corresponding
to the LDT (local descriptor table) into the given operand.
<p>See also <code><nobr>LGDT</nobr></code>, <code><nobr>LIDT</nobr></code>
and <code><nobr>LLDT</nobr></code> (<a href="#section-A.114">section
A.114</a>).
<h3><a name="section-A.233">A.233 <code><nobr>SHL</nobr></code>, <code><nobr>SHR</nobr></code>: Bitwise Logical Shifts</a></h3>
<p><pre>
SHL r/m8,1                    ; D0 /4                [8086] 
SHL r/m8,CL                   ; D2 /4                [8086] 
SHL r/m8,imm8                 ; C0 /4 ib             [286] 
SHL r/m16,1                   ; o16 D1 /4            [8086] 
SHL r/m16,CL                  ; o16 D3 /4            [8086] 
SHL r/m16,imm8                ; o16 C1 /4 ib         [286] 
SHL r/m32,1                   ; o32 D1 /4            [386] 
SHL r/m32,CL                  ; o32 D3 /4            [386] 
SHL r/m32,imm8                ; o32 C1 /4 ib         [386]
</pre>
<p><pre>
SHR r/m8,1                    ; D0 /5                [8086] 
SHR r/m8,CL                   ; D2 /5                [8086] 
SHR r/m8,imm8                 ; C0 /5 ib             [286] 
SHR r/m16,1                   ; o16 D1 /5            [8086] 
SHR r/m16,CL                  ; o16 D3 /5            [8086] 
SHR r/m16,imm8                ; o16 C1 /5 ib         [286] 
SHR r/m32,1                   ; o32 D1 /5            [386] 
SHR r/m32,CL                  ; o32 D3 /5            [386] 
SHR r/m32,imm8                ; o32 C1 /5 ib         [386]
</pre>
<p><code><nobr>SHL</nobr></code> and <code><nobr>SHR</nobr></code> perform
a logical shift operation on the given source/destination (first) operand.
The vacated bits are filled with zero.
<p>A synonym for <code><nobr>SHL</nobr></code> is
<code><nobr>SAL</nobr></code> (see <a href="#section-A.226">section
A.226</a>). NASM will assemble either one to the same code, but NDISASM
will always disassemble that code as <code><nobr>SHL</nobr></code>.
<p>The number of bits to shift by is given by the second operand. Only the
bottom 3, 4 or 5 bits (depending on the source operand size) of the shift
count are considered by processors above the 8086.
<p>You can force the longer (286 and upwards, beginning with a
<code><nobr>C1</nobr></code> byte) form of
<code><nobr>SHL foo,1</nobr></code> by using a
<code><nobr>BYTE</nobr></code> prefix:
<code><nobr>SHL foo,BYTE 1</nobr></code>. Similarly with
<code><nobr>SHR</nobr></code>.
<h3><a name="section-A.234">A.234 <code><nobr>SHLD</nobr></code>, <code><nobr>SHRD</nobr></code>: Bitwise Double-Precision Shifts</a></h3>
<p><pre>
SHLD r/m16,reg16,imm8         ; o16 0F A4 /r ib      [386] 
SHLD r/m32,reg32,imm8         ; o32 0F A4 /r ib      [386] 
SHLD r/m16,reg16,CL           ; o16 0F A5 /r         [386] 
SHLD r/m32,reg32,CL           ; o32 0F A5 /r         [386]
</pre>
<p><pre>
SHRD r/m16,reg16,imm8         ; o16 0F AC /r ib      [386] 
SHRD r/m32,reg32,imm8         ; o32 0F AC /r ib      [386] 
SHRD r/m16,reg16,CL           ; o16 0F AD /r         [386] 
SHRD r/m32,reg32,CL           ; o32 0F AD /r         [386]
</pre>
<p><code><nobr>SHLD</nobr></code> performs a double-precision left shift.
It notionally places its second operand to the right of its first, then
shifts the entire bit string thus generated to the left by a number of bits
specified in the third operand. It then updates only the <em>first</em>
operand according to the result of this. The second operand is not
modified.
<p><code><nobr>SHRD</nobr></code> performs the corresponding right shift:
it notionally places the second operand to the <em>left</em> of the first,
shifts the whole bit string right, and updates only the first operand.
<p>For example, if <code><nobr>EAX</nobr></code> holds
<code><nobr>0x01234567</nobr></code> and <code><nobr>EBX</nobr></code>
holds <code><nobr>0x89ABCDEF</nobr></code>, then the instruction
<code><nobr>SHLD EAX,EBX,4</nobr></code> would update
<code><nobr>EAX</nobr></code> to hold <code><nobr>0x12345678</nobr></code>.
Under the same conditions, <code><nobr>SHRD EAX,EBX,4</nobr></code> would
update <code><nobr>EAX</nobr></code> to hold
<code><nobr>0xF0123456</nobr></code>.
<p>The number of bits to shift by is given by the third operand. Only the
bottom 5 bits of the shift count are considered.
<h3><a name="section-A.235">A.235 <code><nobr>SHUFPS</nobr></code>: Shuffle Single-FP</a></h3>
<p><pre>
SHUFPS xmmreg,r/m128,imm8     ; 0F C6 /r ib          [KATMAI,SSE]
</pre>
<p><code><nobr>SHUFPS</nobr></code> copies two quarters of the destination
register to the lower two quarters of the destination register, and copies
two quarters of the source operand to the upper two quarters of the
destination register.
<p>Bits 0 and 1 of imm8 determine which of the four quarters of the
destination register gets copied to the lowest quater of the destination
register. Bits 2 and 3 of imm8 similary deterine which quarter is copied to
the second quarter of the destination register. Bits 4-7 likewise select
the quarters of the source operand to be copied.
<h3><a name="section-A.236">A.236 <code><nobr>SMI</nobr></code>: System Management Interrupt</a></h3>
<p><pre>
SMI                           ; F1                   [386,UNDOC]
</pre>
<p>This is an opcode apparently supported by some AMD processors (which is
why it can generate the same opcode as <code><nobr>INT1</nobr></code>), and
places the machine into system-management mode, a special debugging mode.
<h3><a name="section-A.237">A.237 <code><nobr>SMINT</nobr></code>, <code><nobr>SMINTOLD</nobr></code>: Software SMM Interrupt</a></h3>
<p><pre>
SMINT                         ; 0F 38                [P6,CYRIX] 
SMINTOLD                      ; 0F 7E                [486,CYRIX]
</pre>
<p><code><nobr>SMINT</nobr></code> causes the CPU to enter System
Management Mode (SMM). <code><nobr>SMINTOLD</nobr></code> is NASM's
mnenonic for the older encoding of <code><nobr>SMINT</nobr></code>, which
Cyrix had to change because of a conflict with the MMX
<code><nobr>MOVD</nobr></code> instruction.
<h3><a name="section-A.238">A.238 <code><nobr>SMSW</nobr></code>: Store Machine Status Word</a></h3>
<p><pre>
SMSW r/m16                    ; 0F 01 /4             [286,PRIV]
</pre>
<p><code><nobr>SMSW</nobr></code> stores the bottom half of the
<code><nobr>CR0</nobr></code> control register (or the Machine Status Word,
on 286 processors) into the destination operand. See also
<code><nobr>LMSW</nobr></code> (<a href="#section-A.115">section
A.115</a>).
<h3><a name="section-A.239">A.239 <code><nobr>SQRTPS</nobr></code>: Packed Single-FP Square Root</a></h3>
<p><pre>
SQRTPS xmmreg,r/m128          ; 0F 51 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>SQRTPS</nobr></code> considers the source operand as a
vector of four 32-bit floating-point numbers, and for each of these it
computes the square root and stores the result in the corresponding quarter
of the destination register.
<h3><a name="section-A.240">A.240 <code><nobr>SQRTSS</nobr></code>: Scalar Single-FP Square Root</a></h3>
<p><pre>
SQRTSS xmmreg,xmmreg/mem32    ; F3 0F 51 /r          [KATMAI,SSE]
</pre>
<p><code><nobr>SQRTSS</nobr></code> computes the square root of the 32-bit
floating-point number in the lowest quarter of the source operand and
stores the result in the lowest quarter of the destination register.
<h3><a name="section-A.241">A.241 <code><nobr>STC</nobr></code>, <code><nobr>STD</nobr></code>, <code><nobr>STI</nobr></code>: Set Flags</a></h3>
<p><pre>
STC                           ; F9                   [8086] 
STD                           ; FD                   [8086] 
STI                           ; FB                   [8086]
</pre>
<p>These instructions set various flags. <code><nobr>STC</nobr></code> sets
the carry flag; <code><nobr>STD</nobr></code> sets the direction flag; and
<code><nobr>STI</nobr></code> sets the interrupt flag (thus enabling
interrupts).
<p>To clear the carry, direction, or interrupt flags, use the
<code><nobr>CLC</nobr></code>, <code><nobr>CLD</nobr></code> and
<code><nobr>CLI</nobr></code> instructions (<a href="#section-A.19">section
A.19</a>). To invert the carry flag, use <code><nobr>CMC</nobr></code>
(<a href="#section-A.20">section A.20</a>).
<h3><a name="section-A.242">A.242 <code><nobr>STMXCSR</nobr></code>: SSE Store MXCSR</a></h3>
<p><pre>
STMXCSR mem32                 ; 0F AE /3             [KATMAI,SSE]
</pre>
<p><code><nobr>STMXCSR</nobr></code> copies the the MXCSR (the SSE
control/status register) into the 32-bit memory location.
<h3><a name="section-A.243">A.243 <code><nobr>STOSB</nobr></code>, <code><nobr>STOSW</nobr></code>, <code><nobr>STOSD</nobr></code>: Store Byte to String</a></h3>
<p><pre>
STOSB                         ; AA                   [8086] 
STOSW                         ; o16 AB               [8086] 
STOSD                         ; o32 AB               [386]
</pre>
<p><code><nobr>STOSB</nobr></code> stores the byte in
<code><nobr>AL</nobr></code> at <code><nobr>[ES:DI]</nobr></code> or
<code><nobr>[ES:EDI]</nobr></code>, and sets the flags accordingly. It then
increments or decrements (depending on the direction flag: increments if
the flag is clear, decrements if it is set) <code><nobr>DI</nobr></code>
(or <code><nobr>EDI</nobr></code>).
<p>The register used is <code><nobr>DI</nobr></code> if the address size is
16 bits, and <code><nobr>EDI</nobr></code> if it is 32 bits. If you need to
use an address size not equal to the current <code><nobr>BITS</nobr></code>
setting, you can use an explicit <code><nobr>a16</nobr></code> or
<code><nobr>a32</nobr></code> prefix.
<p>Segment override prefixes have no effect for this instruction: the use
of <code><nobr>ES</nobr></code> for the store to
<code><nobr>[DI]</nobr></code> or <code><nobr>[EDI]</nobr></code> cannot be
overridden.
<p><code><nobr>STOSW</nobr></code> and <code><nobr>STOSD</nobr></code> work
in the same way, but they store the word in <code><nobr>AX</nobr></code> or
the doubleword in <code><nobr>EAX</nobr></code> instead of the byte in
<code><nobr>AL</nobr></code>, and increment or decrement the addressing
registers by 2 or 4 instead of 1.
<p>The <code><nobr>REP</nobr></code> prefix may be used to repeat the
instruction <code><nobr>CX</nobr></code> (or <code><nobr>ECX</nobr></code>
- again, the address size chooses which) times.
<h3><a name="section-A.244">A.244 <code><nobr>STR</nobr></code>: Store Task Register</a></h3>
<p><pre>
STR r/m16                     ; 0F 00 /1             [286,PRIV]
</pre>
<p><code><nobr>STR</nobr></code> stores the segment selector corresponding
to the contents of the Task Register into its operand.
<h3><a name="section-A.245">A.245 <code><nobr>SUB</nobr></code>: Subtract Integers</a></h3>
<p><pre>
SUB r/m8,reg8                 ; 28 /r                [8086] 
SUB r/m16,reg16               ; o16 29 /r            [8086] 
SUB r/m32,reg32               ; o32 29 /r            [386]
</pre>
<p><pre>
SUB reg8,r/m8                 ; 2A /r                [8086] 
SUB reg16,r/m16               ; o16 2B /r            [8086] 
SUB reg32,r/m32               ; o32 2B /r            [386]
</pre>
<p><pre>
SUB r/m8,imm8                 ; 80 /5 ib             [8086] 
SUB r/m16,imm16               ; o16 81 /5 iw         [8086] 
SUB r/m32,imm32               ; o32 81 /5 id         [386]
</pre>
<p><pre>
SUB r/m16,imm8                ; o16 83 /5 ib         [8086] 
SUB r/m32,imm8                ; o32 83 /5 ib         [386]
</pre>
<p><pre>
SUB AL,imm8                   ; 2C ib                [8086] 
SUB AX,imm16                  ; o16 2D iw            [8086] 
SUB EAX,imm32                 ; o32 2D id            [386]
</pre>
<p><code><nobr>SUB</nobr></code> performs integer subtraction: it subtracts
its second operand from its first, and leaves the result in its destination
(first) operand. The flags are set according to the result of the
operation: in particular, the carry flag is affected and can be used by a
subsequent <code><nobr>SBB</nobr></code> instruction
(<a href="#section-A.228">section A.228</a>).
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<h3><a name="section-A.246">A.246 <code><nobr>SUBPS</nobr></code>: Packed Single-FP Subtract</a></h3>
<p><pre>
SUBPS xmmreg,r/m128           ; 0F 5C /r             [KATMAI,SSE]
</pre>
<p><code><nobr>SUBPS</nobr></code> considers both operands as vectors of
four 32-bit floating-point numbers, and subtracts each such number in the
source operand from the corresponding number in the destination register.
<h3><a name="section-A.247">A.247 <code><nobr>SUBSS</nobr></code>: Scalar Single-FP Subtract</a></h3>
<p><pre>
SUBSS xmmreg,xmmreg/mem32     ; F3 0F 5C /r          [KATMAI,SSE]
</pre>
<p><code><nobr>SUBSS</nobr></code> subtracts the 32-bit floating-point
number in the lowest 4 bytes of the source operand from the corresponding
number in the destination register.
<h3><a name="section-A.248">A.248 <code><nobr>SVDC</nobr></code>: Save Segment Register and Descriptor</a></h3>
<p><pre>
SVDC mem80,segreg             ; 0F 78 /r             [486,CYRIX,SMM]
</pre>
<h3><a name="section-A.249">A.249 <code><nobr>SVLDT</nobr></code>: Save LDTR and Descriptor</a></h3>
<p><pre>
SVLDT mem80                   ; 0F 7A /0             [486,CYRIX,SMM]
</pre>
<h3><a name="section-A.250">A.250 <code><nobr>SVTS</nobr></code>: Save TSR and Descriptor</a></h3>
<p><pre>
SVTS mem80                    ; 0F 7C /0             [486,CYRIX,SMM]
</pre>
<h3><a name="section-A.251">A.251 <code><nobr>SYSCALL</nobr></code>: Call Operating System</a></h3>
<p><pre>
SYSCALL                       ; 0F 05                [P6,AMD]
</pre>
<p>Sets <code><nobr>ECX</nobr></code> to the value of
<code><nobr>EIP</nobr></code> and then sets <code><nobr>CS</nobr></code>,
<code><nobr>EIP</nobr></code> and <code><nobr>SS</nobr></code> in a manner
previously determined by the operating system. This is designed to allow a
fast system call facility.
<h3><a name="section-A.252">A.252 <code><nobr>SYSENTER</nobr></code>: Fast Transistion to System Call Entry Point</a></h3>
<p><pre>
SYSENTER                      ; 0F 34                [P6]
</pre>
<p>Sets <code><nobr>CS</nobr></code>, <code><nobr>EIP</nobr></code>,
<code><nobr>SS</nobr></code> and <code><nobr>ESP</nobr></code> in a manner
previously determined by the operating system. This is designed to allow a
fast system call facility.
<h3><a name="section-A.253">A.253 <code><nobr>SYSEXIT</nobr></code>: Fast Transistion from System Call Entry Point</a></h3>
<p><pre>
SYSEXIT                       ; 0F 36                [P6,PRIV]
</pre>
<p>Sets <code><nobr>CS</nobr></code> and <code><nobr>SS</nobr></code> in a
manner previously determined by the operating system, and sets
<code><nobr>EIP</nobr></code> to the value of
<code><nobr>EDX</nobr></code>, and <code><nobr>ESP</nobr></code> to the
value of <code><nobr>ECX</nobr></code>. This is designed to allow return
from a system call entered by means of <code><nobr>SYSENTER</nobr></code>.
<h3><a name="section-A.254">A.254 <code><nobr>SYSRET</nobr></code>: Return From Operating System</a></h3>
<p><pre>
SYSRET                        ; 0F 07                [P6,AMD,PRIV]
</pre>
<p>Sets <code><nobr>EIP</nobr></code> to the value of
<code><nobr>ECX</nobr></code> and sets <code><nobr>CS</nobr></code> and
<code><nobr>SS</nobr></code> in a manner previously determined by the
operating system. This is designed to allow return from a system call
entered by means of <code><nobr>SYSCALL</nobr></code>.
<h3><a name="section-A.255">A.255 <code><nobr>TEST</nobr></code>: Test Bits (notional bitwise AND)</a></h3>
<p><pre>
TEST r/m8,reg8                ; 84 /r                [8086] 
TEST r/m16,reg16              ; o16 85 /r            [8086] 
TEST r/m32,reg32              ; o32 85 /r            [386]
</pre>
<p><pre>
TEST r/m8,imm8                ; F6 /7 ib             [8086] 
TEST r/m16,imm16              ; o16 F7 /7 iw         [8086] 
TEST r/m32,imm32              ; o32 F7 /7 id         [386]
</pre>
<p><pre>
TEST AL,imm8                  ; A8 ib                [8086] 
TEST AX,imm16                 ; o16 A9 iw            [8086] 
TEST EAX,imm32                ; o32 A9 id            [386]
</pre>
<p><code><nobr>TEST</nobr></code> performs a `mental' bitwise AND of its
two operands, and affects the flags as if the operation had taken place,
but does not store the result of the operation anywhere.
<h3><a name="section-A.256">A.256 <code><nobr>UCOMISS</nobr></code>: Unordered Scalar Single-FP Compare and set EFLAGS</a></h3>
<p><pre>
UCOMISS xmmreg,xmmreg/mem32   ; 0F 2E /r             [KATMAI,SSE]
</pre>
<p><code><nobr>UCOMISS</nobr></code> compares the 32-bit floating-point
numbers in the lowest part of the two operands, and sets the CPU flags
appropriately. <code><nobr>UCOMISS</nobr></code> differs from
<code><nobr>COMISS</nobr></code> in that it signals an invalid numeric
exeception only if an operand is an sNaN, whereas
<code><nobr>COMISS</nobr></code> does so also if an operand is a qNaN.
<h3><a name="section-A.257">A.257 <code><nobr>UD2</nobr></code>: Undefined Instruction</a></h3>
<p><pre>
UD2                           ; 0F 0B                [286]
</pre>
<p><code><nobr>UD2</nobr></code> raises the invalid opcode exception, and
is the preferred way to do this explicitly.
<h3><a name="section-A.258">A.258 <code><nobr>UMOV</nobr></code>: User Move Data</a></h3>
<p><pre>
UMOV r/m8,reg8                ; 0F 10 /r             [386,UNDOC] 
UMOV r/m16,reg16              ; o16 0F 11 /r         [386,UNDOC] 
UMOV r/m32,reg32              ; o32 0F 11 /r         [386,UNDOC]
</pre>
<p><pre>
UMOV reg8,r/m8                ; 0F 12 /r             [386,UNDOC] 
UMOV reg16,r/m16              ; o16 0F 13 /r         [386,UNDOC] 
UMOV reg32,r/m32              ; o32 0F 13 /r         [386,UNDOC]
</pre>
<p>This undocumented instruction is used by in-circuit emulators to access
user memory (as opposed to host memory). It is used just like an ordinary
memory/register or register/register <code><nobr>MOV</nobr></code>
instruction, but accesses user space.
<h3><a name="section-A.259">A.259 <code><nobr>UNPCKHPS</nobr></code>: Unpack High Packed Single-FP Data</a></h3>
<p><pre>
UNPCKHPS xmmreg,r/m128        ; 0F 15 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>UNPCKHPS</nobr></code> performs an interleaved unpack of the
high-order data elements of the two operands in the following manner:
labelling the data elements of the destination register as X0, X1, X2 and
X3 (from low to high) and those of the source operand as Y0, Y1, Y2 and Y3
the <code><nobr>UNPCKHPS</nobr></code> instruction simultaneously performs
the four assignments X0 := X2, X1 := Y2, X2 := X3 and X3 := Y3.
<h3><a name="section-A.260">A.260 <code><nobr>UNPCKLPS</nobr></code>: Unpack Low Packed Single-FP Data</a></h3>
<p><pre>
UNPCKLPS xmmreg,r/m128        ; 0F 14 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>UNPCKLPS</nobr></code> performs an interleaved unpack of the
low-order data elements of the two operands in the following manner:
labelling the data elements of the destination register as X0, X1, X2 and
X3 (from low to high) and those of the source operand as Y0, Y1, Y2 and Y3
the <code><nobr>UNPCKLPS</nobr></code> instruction simultaneously performs
the four assignments X0 := X0, X1 := Y0, X2 := X1 and X3 := Y1.
<h3><a name="section-A.261">A.261 <code><nobr>VERR</nobr></code>, <code><nobr>VERW</nobr></code>: Verify Segment Readability/Writability</a></h3>
<p><pre>
VERR r/m16                    ; 0F 00 /4             [286,PRIV]
</pre>
<p><pre>
VERW r/m16                    ; 0F 00 /5             [286,PRIV]
</pre>
<p><code><nobr>VERR</nobr></code> sets the zero flag if the segment
specified by the selector in its operand can be read from at the current
privilege level. <code><nobr>VERW</nobr></code> sets the zero flag if the
segment can be written.
<h3><a name="section-A.262">A.262 <code><nobr>WAIT</nobr></code>: Wait for Floating-Point Processor</a></h3>
<p><pre>
WAIT                          ; 9B                   [8086]
</pre>
<p><code><nobr>WAIT</nobr></code>, on 8086 systems with a separate 8087
FPU, waits for the FPU to have finished any operation it is engaged in
before continuing main processor operations, so that (for example) an FPU
store to main memory can be guaranteed to have completed before the CPU
tries to read the result back out.
<p>On higher processors, <code><nobr>WAIT</nobr></code> is unnecessary for
this purpose, and it has the alternative purpose of ensuring that any
pending unmasked FPU exceptions have happened before execution continues.
<h3><a name="section-A.263">A.263 <code><nobr>WBINVD</nobr></code>: Write Back and Invalidate Cache</a></h3>
<p><pre>
WBINVD                        ; 0F 09                [486]
</pre>
<p><code><nobr>WBINVD</nobr></code> invalidates and empties the processor's
internal caches, and causes the processor to instruct external caches to do
the same. It writes the contents of the caches back to memory first, so no
data is lost. To flush the caches quickly without bothering to write the
data back first, use <code><nobr>INVD</nobr></code>
(<a href="#section-A.102">section A.102</a>).
<h3><a name="section-A.264">A.264 <code><nobr>WRMSR</nobr></code>: Write Model-Specific Registers</a></h3>
<p><pre>
WRMSR                         ; 0F 30                [PENT]
</pre>
<p><code><nobr>WRMSR</nobr></code> writes the value in
<code><nobr>EDX:EAX</nobr></code> to the processor Model-Specific Register
(MSR) whose index is stored in <code><nobr>ECX</nobr></code>. See also
<code><nobr>RDMSR</nobr></code> (<a href="#section-A.213">section
A.213</a>).
<h3><a name="section-A.265">A.265 <code><nobr>WRSHR</nobr></code>: Write SMM Header Pointer Register</a></h3>
<p><pre>
WRSHR                         ; 0F 37                [P6,CYRIX,SMM]
</pre>
<h3><a name="section-A.266">A.266 <code><nobr>XADD</nobr></code>: Exchange and Add</a></h3>
<p><pre>
XADD r/m8,reg8                ; 0F C0 /r             [486] 
XADD r/m16,reg16              ; o16 0F C1 /r         [486] 
XADD r/m32,reg32              ; o32 0F C1 /r         [486]
</pre>
<p><code><nobr>XADD</nobr></code> exchanges the values in its two operands,
and then adds them together and writes the result into the destination
(first) operand. This instruction can be used with a
<code><nobr>LOCK</nobr></code> prefix for multi-processor synchronisation
purposes.
<h3><a name="section-A.267">A.267 <code><nobr>XBTS</nobr></code>: Extract Bit String</a></h3>
<p><pre>
XBTS reg16,r/m16              ; o16 0F A6 /r         [386,UNDOC] 
XBTS reg32,r/m32              ; o32 0F A6 /r         [386,UNDOC]
</pre>
<p>No clear documentation seems to be available for this instruction: the
best I've been able to find reads `Takes a string of bits from the first
operand and puts them in the second operand'. It is present only in early
386 processors, and conflicts with the opcodes for
<code><nobr>CMPXCHG486</nobr></code>. NASM supports it only for
completeness. Its counterpart is <code><nobr>IBTS</nobr></code> (see
<a href="#section-A.93">section A.93</a>).
<h3><a name="section-A.268">A.268 <code><nobr>XCHG</nobr></code>: Exchange</a></h3>
<p><pre>
XCHG reg8,r/m8                ; 86 /r                [8086] 
XCHG reg16,r/m8               ; o16 87 /r            [8086] 
XCHG reg32,r/m32              ; o32 87 /r            [386]
</pre>
<p><pre>
XCHG r/m8,reg8                ; 86 /r                [8086] 
XCHG r/m16,reg16              ; o16 87 /r            [8086] 
XCHG r/m32,reg32              ; o32 87 /r            [386]
</pre>
<p><pre>
XCHG AX,reg16                 ; o16 90+r             [8086] 
XCHG EAX,reg32                ; o32 90+r             [386] 
XCHG reg16,AX                 ; o16 90+r             [8086] 
XCHG reg32,EAX                ; o32 90+r             [386]
</pre>
<p><code><nobr>XCHG</nobr></code> exchanges the values in its two operands.
It can be used with a <code><nobr>LOCK</nobr></code> prefix for purposes of
multi-processor synchronisation.
<p><code><nobr>XCHG AX,AX</nobr></code> or
<code><nobr>XCHG EAX,EAX</nobr></code> (depending on the
<code><nobr>BITS</nobr></code> setting) generates the opcode
<code><nobr>90h</nobr></code>, and so is a synonym for
<code><nobr>NOP</nobr></code> (<a href="#section-A.145">section A.145</a>).
<h3><a name="section-A.269">A.269 <code><nobr>XLATB</nobr></code>: Translate Byte in Lookup Table</a></h3>
<p><pre>
XLATB                         ; D7                   [8086]
</pre>
<p><code><nobr>XLATB</nobr></code> adds the value in
<code><nobr>AL</nobr></code>, treated as an unsigned byte, to
<code><nobr>BX</nobr></code> or <code><nobr>EBX</nobr></code>, and loads
the byte from the resulting address (in the segment specified by
<code><nobr>DS</nobr></code>) back into <code><nobr>AL</nobr></code>.
<p>The base register used is <code><nobr>BX</nobr></code> if the address
size is 16 bits, and <code><nobr>EBX</nobr></code> if it is 32 bits. If you
need to use an address size not equal to the current
<code><nobr>BITS</nobr></code> setting, you can use an explicit
<code><nobr>a16</nobr></code> or <code><nobr>a32</nobr></code> prefix.
<p>The segment register used to load from <code><nobr>[BX+AL]</nobr></code>
or <code><nobr>[EBX+AL]</nobr></code> can be overridden by using a segment
register name as a prefix (for example,
<code><nobr>es xlatb</nobr></code>).
<h3><a name="section-A.270">A.270 <code><nobr>XOR</nobr></code>: Bitwise Exclusive OR</a></h3>
<p><pre>
XOR r/m8,reg8                 ; 30 /r                [8086] 
XOR r/m16,reg16               ; o16 31 /r            [8086] 
XOR r/m32,reg32               ; o32 31 /r            [386]
</pre>
<p><pre>
XOR reg8,r/m8                 ; 32 /r                [8086] 
XOR reg16,r/m16               ; o16 33 /r            [8086] 
XOR reg32,r/m32               ; o32 33 /r            [386]
</pre>
<p><pre>
XOR r/m8,imm8                 ; 80 /6 ib             [8086] 
XOR r/m16,imm16               ; o16 81 /6 iw         [8086] 
XOR r/m32,imm32               ; o32 81 /6 id         [386]
</pre>
<p><pre>
XOR r/m16,imm8                ; o16 83 /6 ib         [8086] 
XOR r/m32,imm8                ; o32 83 /6 ib         [386]
</pre>
<p><pre>
XOR AL,imm8                   ; 34 ib                [8086] 
XOR AX,imm16                  ; o16 35 iw            [8086] 
XOR EAX,imm32                 ; o32 35 id            [386]
</pre>
<p><code><nobr>XOR</nobr></code> performs a bitwise XOR operation between
its two operands (i.e. each bit of the result is 1 if and only if exactly
one of the corresponding bits of the two inputs was 1), and stores the
result in the destination (first) operand.
<p>In the forms with an 8-bit immediate second operand and a longer first
operand, the second operand is considered to be signed, and is
sign-extended to the length of the first operand. In these cases, the
<code><nobr>BYTE</nobr></code> qualifier is necessary to force NASM to
generate this form of the instruction.
<p>The MMX instruction <code><nobr>PXOR</nobr></code> (see
<a href="#section-A.209">section A.209</a>) performs the same operation on
the 64-bit MMX registers.
<h3><a name="section-A.271">A.271 <code><nobr>XORPS</nobr></code>: SSE Bitwise Logical OR</a></h3>
<p><pre>
XORPS xmmreg,r/m128           ; 0F 57 /r             [KATMAI,SSE]
</pre>
<p><code><nobr>XORPS</nobr></code> performs a bitwise OR operation on the
source operand and the destination register, and stores the result in the
destination register.
<p align=center><a href="nasmdo10.htm">Previous Chapter</a> |
<a href="nasmdoc0.htm">Contents</a> |
<a href="nasmdoci.htm">Index</a>
</body></html>
