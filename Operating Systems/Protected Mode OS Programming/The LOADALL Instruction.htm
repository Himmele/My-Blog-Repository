<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0052)http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm -->
<HTML><HEAD><TITLE>The LOADALL Instruction</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY text=#000000 vLink=#330066 aLink=#ff0000 link=#0000ff bgColor=#ffffff 
leftMargin=8 background="The LOADALL Instruction-Dateien/back3.gif" topMargin=8 
MARGINHEIGHT="8" MARGINWIDTH="8">
<TABLE cellSpacing=0 cellPadding=0 border=0>
  <TBODY>
  <TR><!--------------- LEFT SIDE ------------>
    <TD vAlign=top><FONT face=arial,helvetica size=-1><A 
      href="http://x86.ddj.com/"><IMG height=90 
      src="The LOADALL Instruction-Dateien/logo_small.gif" width=115 align=top 
      border=0></A><BR clear=all><!-- Left side nav items: two-column table, bullets in left column -->
      <TABLE cellSpacing=0 cellPadding=0 width=128 border=0>
        <TBODY>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://www.ddj.com/"><IMG height=20 alt="DDJ Home" 
            src="The LOADALL Instruction-Dateien/ddjhome.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD><IMG height=5 alt="" 
            src="The LOADALL Instruction-Dateien/spacer.gif" width=1 
            align=top><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/news/hotnews.htm"><IMG height=40 
            alt="Today's Headlines" 
            src="The LOADALL Instruction-Dateien/newnews.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/news/old.htm"><IMG height=20 
            alt="Past Headlines" 
            src="The LOADALL Instruction-Dateien/pastnews.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/articles/articles.htm"><IMG 
            height=40 alt="Microprocessor Articles" 
            src="The LOADALL Instruction-Dateien/m_articles.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/secrets/intelsecrets.htm"><IMG 
            height=20 alt="Intel Secrets" 
            src="The LOADALL Instruction-Dateien/intel.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/errata/errataseries.htm"><IMG 
            height=20 alt="Intel Errata" 
            src="The LOADALL Instruction-Dateien/errata.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/ddj/ddj.htm"><IMG height=40 
            alt="Undocumented Corner" 
            src="The LOADALL Instruction-Dateien/udoc.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/intel.doc/inteldocs.htm"><IMG 
            height=40 alt="Processor Manuals" 
            src="The LOADALL Instruction-Dateien/pmanual.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A 
            href="http://x86.ddj.com/intel.doc/intelmotherboards.htm"><IMG 
            height=40 alt="Motherboard Manuals" 
            src="The LOADALL Instruction-Dateien/mmanual.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD vAlign=top><IMG height=20 alt="* " 
            src="The LOADALL Instruction-Dateien/dot.gif" width=7 
          VALIGN="top"></TD>
          <TD><A href="http://x86.ddj.com/links.htm"><IMG height=20 alt=Links 
            src="The LOADALL Instruction-Dateien/links.gif" width=120 
            border=0></A><BR clear=all></TD></TR>
        <TR>
          <TD><IMG height=50 alt="" 
            src="The LOADALL Instruction-Dateien/spacer.gif" width=1 
            align=top><BR clear=all></TD></TR>
        <TR>
          <TD align=left colSpan=2><!-- REMOTE AD CALL <%/remoteviewad?site=x86&pagepos=buttonsponsor|site=x86|pagepos=buttonsponsor%> --><A 
            href="http://newads.cmpnet.com/event.ng/Type=click&amp;ProfileID=6783&amp;RunID=38371&amp;AdID=25450&amp;GroupID=304&amp;FamilyID=2749&amp;TagValues=2901.2949&amp;Redirect=http://www.sdmagazine.com" 
            target=_top><IMG height=1 alt="" 
            src="The LOADALL Instruction-Dateien/clear_1x1.gif" width=1 
            border=0></A> <!-- REMOTE AD CALL <%/remoteviewad?site=ddj&pagepos=buttonsponsor&uri=nav-bottom|uri=nav-bottom|site=ddj|pagepos=buttonsponsor%> --><!-- AD ERROR: No profiles found to match request (site=ddj, pagepos=buttonsponsor, server_name=, uri=)--></TD></TR></TBODY></TABLE></FONT></TD><!-- End left-hand column --><!--------------- MAIN BODY ------------>
    <TD vAlign=top>
      <TABLE cellSpacing=0 cellPadding=0 border=0>
        <TBODY>
        <TR>
          <TD><!-- First row: ad --><!-- REMOTE AD CALL <%/remoteviewad?site=x86&pagepos=top|site=x86|pagepos=top%> --><A 
            href="http://newads.cmpnet.com/event.ng/Type=click&amp;ProfileID=7160&amp;RunID=39005&amp;AdID=29421&amp;GroupID=320&amp;FamilyID=1&amp;TagValues=178.2949&amp;Redirect=http://www.microsoft.com/redirect.asp?PageID=157&amp;PARAM=TECWDOB&amp;TARGET=http://msdn.microsoft.com/events/teched/" 
            target=_top><IMG height=60 alt="" 
            src="The LOADALL Instruction-Dateien/micro_contest_2.gif" width=468 
            border=1></A> </TD></TR>
        <TR>
          <TD background="The LOADALL Instruction-Dateien/dash_wide.gif"><!-- 2nd row: rule --><IMG 
            height=10 src="The LOADALL Instruction-Dateien/spacer.gif" width=1> 
          </TD></TR>
        <TR>
          <TD><!-- 3rd row: Header --><IMG height=40 
            alt="Microprocessor Resources" 
            src="The LOADALL Instruction-Dateien/microprocessor.gif" 
            width=350><BR clear=all><IMG height=10 
            src="D:\Eigene Dateien\OS Programming\The LOADALL Instruction-Dateien\spacer(1).gif" 
            width=1><BR></TD></TR>
        <TR>
          <TD><!-- 4th row: Page content -->
            <TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD>
                  <H1 align=center><FONT color=#0000ff>The <I>LOADALL</I> 
                  Instruction</FONT></H1>
                  <H1 align=center><FONT color=#0000ff>by</FONT></H1>
                  <H1 align=center><FONT color=#0000ff>Robert 
Collins</FONT></H1>
                  <HR>

                  <P>Of the few undocumented instructions in the 80286 and 80386 
                  microprocessors, the <I>LOADALL </I>instruction is the most 
                  widely known. Nevertheless, very few people understand how to 
                  use it. Using <I>LOADALL </I>is not as simp)e as merely 
                  knowing the <I>LOADALL </I>opcode and its format, because 
                  knowing how to use <I>LOADALL </I>requires a knowledge of many 
                  aspects of the CPUs' behavior that are not documented in their 
                  respective data sheets.</P>
                  <P>The 286 <I>LOADALL </I>is widely known because a 15-page 
                  lntel confidential document describing its use was given to 
                  many developers. 286 <I>LOADALL </I>is so commonly used in 
                  production code that DOS 3.3 (and above) and OS/2 have 
                  provisions for using <I>LOADALL </I>built in them. Every 386 
                  and 486 BIOS emulates 286 <I>LOADALL </I>and even Microsoft 
                  CODEVIEW recognizes the 286 <I>LOADALL </I>opcode and 
                  disassembles it.</P>
                  <P>On the other hand, the 386 <I>LOADALL </I>is not widely 
                  known, and very few developers even know it exists. In this 
                  article, I will explain how to use both the 286 and 386 
                  <I>LOADALL </I>instructions and present source code to 
                  demonstrate the various aspects of CPU behavior that become 
                  apparent, or can be proven, when using <I>LOADALL.</I></P>
                  <P><!-- Begin Master Table --></P>
                  <DIV align=center>
                  <CENTER>
                  <TABLE cellSpacing=0 cellPadding=8 border=0>
                    <TBODY>
                    <TR>
                      <TD vAlign=top width="60%">Intel originally included 
                        <I>LOADALL </I>in the CPU mask for testing purposes and 
                        In Circuit Emulator (ICE) support. As its name implies, 
                        <I>LOADALL </I>loads all of the CPU registers, including 
                        the "hidden" software-invisible registers. At the 
                        completion of a <I>LOADALL </I>instruction, the entire 
                        CPU state is defined according to the <I>LOADALL 
                        </I>data table. <I>LOADALL </I>loads all of the 
                        software-visible registers such as <I>AX, </I>and all of 
                        the software-invisible registers such as the <A 
                        href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#sb1" 
                        name=SB1Ptr>segment descriptor caches</A>.
                        <P>By manipulating the descriptor cache base registers, 
                        you can access the entire address space without 
                        switching to protected mode. In other words, by using 
                        <I>LOADALL, </I>you can access memory above 1Mb from 
                        real mode. Since the alternative method for the 286 
                        (switching to protected mode, accessing the desired 
                        memory, then resetting the CPU - the only way to get the 
                        286 back to real mode) has a significant performance 
                        penalty, <I>LOADALL </I>is most significant to 286 
                        programmers. <I>LOADALL </I>provides them with a new 
                        capability that is not available by any other means.</P>
                        <P><FONT color=#ff0000 size=5><B><I>LOADALL 
                        </I></B><B>Details</B></FONT></P>
                        <P><I>LOADALL </I>is closely coupled with the CPU 
                        hardware. Both the 286 and 386 have different internal 
                        hardware and Intel implemented <I>LOADALL </I>using 
                        different opcodes on the 286 and 386. 80286 <I>LOADALL 
                        </I>(opcode 0F05) produces an invalid opcode exception 
                        when executed on the 386, and 80386 <I>LOADALL 
                        </I>(opcode 0F07) produces an invalid opcode exception 
                        when executed on the 286.</P>
                        <P><I>LOADALL </I>loads all CPU registers (including 
                        <I>MSW, GDTR, CSBASE, ESACCESS) </I>from a memory image. 
                        You can execute <I>LOADALL </I>in real or protected 
                        mode, but only at privilege level 0 (CPL=0). If you 
                        execute <I>LOADALL </I>at any other privilege level, the 
                        CPU generates an exception.</P>
                        <P>By directly loading the descriptor cache registers 
                        with <I>LOADALL, </I>a program has explicit control over 
                        the base address, segment limit, and access rights 
                        associated with each memory segment. Normally, the CPU 
                        loads these values each time it loads a segment 
                        register, but <I>LOADALL </I>allows you to load these 
                        hidden registers independently of their segment register 
                        counterparts.</P>
                        <P>In real mode, <I>LOADALL </I>makes it possible to 
                        access a memory segment that is not associated with any 
                        segment register. Likewise in protected mode, you can 
                        access memory that has no descriptor table entry.</P>
                        <P><I>LOADALL </I>performs no protection checks against 
                        any of the loaded register values. When you execute it 
                        at <I>CPL 0, LOADALL </I>can generate no exceptions. The 
                        segment access rights and limit portions may be values 
                        that would otherwise be illegal in the context of real 
                        mode or protected mode, but <I>LOADALL </I>willingly 
                        loads these values with no checks. Once loaded, however, 
                        the CPU performs full access checks when accessing a 
                        segment. For example, you can load a segment whose 
                        access is marked "not present." Normally, this condition 
                        would generate exception 11, "segment not present", but 
                        <I>LOADALL </I>does not generate exception 11. Instead, 
                        any attempt to access this segment will generate 
                        exception 13.</P>
                        <P><I>LOADALL </I>does not check coherency between the 
                        software-visible segment registers and the 
                        software-invisible segment descriptor cache registers. 
                        Any segment descriptor base register may point to any 
                        area in the CPU address space, while the 
                        software-visible segment register may contain any other 
                        arbitrary value. The CPU makes all memory references 
                        according to the descriptor cache registers, not the 
                        software-visible segment registers. All subsequent 
                        segment register loads will reload the descriptor cache 
                        register. Beware of using values in CS that do not 
                        perfectly match a code segment descriptor table entry, 
                        or a real mode code segment - an interrupt return 
                        <I>(IRET) </I>may either cause an exception or execution 
                        to resume at an unexpected location. Likewise, pushing 
                        and subsequently popping any segment register will force 
                        the descriptor cache register to reload according to the 
                        CPU's conventional protocol, thereby inhibiting any 
                        further real mode extended memory references.</P>
                        <P><FONT color=#ff0000 size=5><B>80286 
                        </B><B><I>LOADALL</I></B></FONT></P>
                        <P>You encode the 80286 <I>LOADALL </I>as a two-byte 
                        opcode, 0F05h. <I>LOADALL </I>reads its table from a 
                        fixed memory location at 800h (80:0 in real-mode 
                        addressing). <I>LOADALL </I>performs 51 bus cycles 
                        <I>(WORD </I>cycles), and takes 195 clocks with no wait 
                        states. <A 
                        href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#tbl1">Table 
                        1</A> shows the format you must prepare at location 800h 
                        before executing the 286 <I>LOADALL </I>instruction. All 
                        CPU register entries in the <I>LOADALL </I>table conform 
                        to the standard Intel format, where the least 
                        significant byte is at the lowest memory address. <A 
                        href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#tbl2a">Table 
                        2</A> shows the 286 format of the descriptor cache 
                        entries.</P>
                        <P><BR></P>
                        <P><!-- Begin "Table 1" in column 1 of Master Table --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=12 border=0>
                          <CAPTION align=top><A name=Tbl1></A><STRONG>Table 1 -- 
                          80286 </STRONG><STRONG><I>LOADALL</I></STRONG><STRONG> 
                          Table</STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TH vAlign=bottom>Physical Address</TH>
                            <TH vAlign=bottom>Description</TH>
                            <TH vAlign=bottom>Data Size</TH>
                            <TH vAlign=bottom>Data Value</TH></TR>
                          <TR>
                            <TD vAlign=top>
                              <P align=center>[800] 
                              <BR>[802]<BR>[804]<BR>[806]<BR>[808]<BR>[80A]<BR>[80C]<BR>[80E]<BR>[810]<BR>[812]<BR>[814]<BR>[816]<BR>[818]<BR>[81A]<BR>[81C]<BR>[81E]<BR>[820]<BR>[822]<BR>[824]<BR>[826]<BR>[828]<BR>[82A]<BR>[82C]<BR>[82E]<BR>[830]<BR>[832]<BR>[834]<BR>[836]<BR>[83C]<BR>[842]<BR>[848]<BR>[84E]<BR>[854]<BR>[85A]<BR>[860]<BR>[866] 
                              </P></TD>
                            <TD 
                              vAlign=top>None<BR>None<BR>MSW<BR>None<BR>None<BR>None<BR>None<BR>None<BR>None<BR>None<BR>None<BR>TR_REG<BR>FLAGS<BR>IP<BR>LDT_REG<BR>DS_REG<BR>SS_REG<BR>CS_REG<BR>ES_REG<BR>DI<BR>SI<BR>BP<BR>SP<BR>BX<BR>DX<BR>CX<BR>AX<BR>ES_DESC<BR>CS_DESC<BR>SS_DESC<BR>DS_DESC<BR>GDT_DESC<BR>LDT_DESC<BR>IDT_DESC<BR>TSS_DESC<BR>ENT&nbsp;OF&nbsp;TABLE</TD>
                            <TD vAlign=top 
                              align=middle>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DW<BR>DESC_CACHE286<BR>DESC_CACHE286<BR>DESC_CACHE286<BR>DESC_CACHE286<BR>DESC_CACHE286<BR>DESC_CACHE286<BR>DESC_CACHE286<BR>DESC_CACHE286<BR></TD>
                            <TD vAlign=top 
                              align=middle>0<BR>0<BR>0<BR>?<BR>0<BR>0<BR>0<BR>0<BR>0<BR>0<BR>0<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR></TD></TR>
                          <TR>
                            <TD colSpan=4><PRE><FONT size=4>DESC_CACHE286 STRUC
    Addr_A15_A00 DW ?
    Addr_A23_A16 DB ?
    Access DB ?
    Limit DW ?
ENDS</FONT></PRE></TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Table 1" within column 1 of Master Table -->Intel 
                        recommends some guidelines for proper execution 
                        following <I>LOADALL. </I>The stack segment should be a 
                        read/write data segment; the code segment can be execute 
                        on1y (access=95h), read/execute (access=9bh), or 
                        read/write/execute (access=93h). Proper protected mode 
                        operation also requires that the DPL of <I>CS </I>and 
                        DPL of <I>SS </I>be equal. These attributes determine 
                        the CPL of the processor. Also, the DPL fields of <I>ES 
                        </I>and <I>DS </I>should be equal to 3 to prevent 
                        <I>RETF </I>or <I>IRET </I>instructions from zeroing 
                        these registers. </P>
                        <P>The code in <A 
                        href="http://x86.ddj.com/ftp/source/286load/286load.asm">listing 
                        1</A> demonstrates how to exp1ore the various operating 
                        modes with 286 <I>LOADALL </I>and how to access extended 
                        memory while in real mode. The <I>LOADALL </I>test 
                        performs various functions that would be impossible to 
                        duplicate without using <I>LOADALL.</I></P>
                        <P><FONT color=#ff0000 size=5><B>80386 
                        </B><B><I>LOADALL</I></B></FONT></P>
                        <P>The 386 LOADALL is encoded as a two-byte opcode 
                        (0F07). Unlike the 286 LOADALL, this LOADALL instruction 
                        reads its data from a table pointed to by ES:EDI. 
                        Segment overrides are allowed, but apparently ignored. 
                        The 386 LOADALL performs 51 bus cycles (DWORD cycles) 
                        and takes 122 clocks with no wait states. Table 3 shows 
                        the 386 LOADALL format. However, <A 
                        href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#tbl3">Table 
                        3</A> does not show that prior to reading the LOADALL 
                        table, LOADALL reads 10 DWORDs exactly 100h bytes beyond 
                        the beginning of the table (ES:EDI+100h). This data is 
                        not used to load any of the registers LOADALL does not 
                        load (CR2, CR3, DRO-DR3, TR6, TR7), or the Numeric 
                        Processor eXtension (NPX). At this time, the purpose of 
                        reading this data and its destination is a mystery. 
                        Figure 1 shows an ICE trace showing all the bus cycles 
                        associated with LOADALL's execution.</P>
                        <P>As with the 286 LOADALL, all CPU register entries in 
                        the LOADALL table are in the standard Intel format where 
                        the least significant byte is at the lowest memory 
                        address. The 386 descriptor cache entries have the 
                        format shown in <A 
                        href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#tbl4">Table 
                        4</A>.</P>
                        <P><A 
                        href="http://x86.ddj.com/ftp/source/386load/386load.asm">Listing 
                        2</A> shows how to test 386 LOADALL. This test is more 
                        comprehensive than the 286 LOADALL test because of the 
                        expanded capabilities of the 386 microprocessor. This 
                        test puts the CPU into various states that are illegal 
                        and are impossible to duplicate through any other 
                        software means.</P>
                        <P><FONT color=#ff0000 size=5><B><I>LOADALL 
                        </I></B><B>Emulation</B></FONT></P>
                        <P>Due to the large number of systems programs that use 
                        286 <I>LOADALL, </I>all 386 and 486 BIOS's must emu1ate 
                        the 286 <I>LOADALL </I>instruction (opcode 0<I>F05). 
                        </I>On the 386 and 486, the 286 <I>LOADALL 
                        </I>instruction generates an invalid opcode exception. 
                        The BIOS traps this exception and does its best to 
                        emulate the functionality of the <I>LOADALL 
                        </I>instruction, but perfect emulation is impossible 
                        without using <I>LOADALL </I>itself. Using 386 
                        <I>LOADALL </I>to emulate 286 <I>LOADALL </I>can be 
                        done, but has its risks. First of all, the 486 does not 
                        have a <I>LOADALL </I>instruction. Second, Intel has 
                        threatened to remove <I>LOADALL </I>from the 386 
                        mask.</P>
                        <P>Perfect emulation is possible on the 386 by using 386 
                        <I>LOADALL </I>to emulate 286 <I>LOADALL. </I><A 
                        href="http://x86.ddj.com/ftp/source/emuload/emuload.asm">Listing 
                        3</A> shows a TSR program that uses 386 <I>LOADALL 
                        </I>to emulate 286 <I>LOADALL. </I>The program first 
                        tests that you are a 386 before insta1ling itself. By 
                        using this emu1ation program, you can guarantee perfect 
                        286 <I>LOADALL </I>emulation.</P>
                        <P><FONT color=#ff0000 
                        size=5><B>Conclusion</B></FONT></P>
                        <P><I>LOADALL </I>is a very powerful instruction, but 
                        the features that make it so powerful also make it 
                        risky. For example, <I>LOADALL </I>can put the processor 
                        in states that are otherwise impossible to duplicate 
                        through any other software means. Using <I>LOADALL 
                        </I>requires a thorough understanding of how the CPU 
                        processes register loads, the ramifications of those 
                        register loads, and careful planning. The illegally 
                        induced processor states can easily cause system crashes 
                        if not properly planned for. The best way to avoid 
                        system crashes is to avoid using <I>LOADALL </I>unless 
                        you are totally confident in your understanding of the 
                        CPU and in your programming skills.</P>
                        <P>The 286 <I>LOADALL </I>is described in a 15-page 
                        Intel-confidential document The document describes in 
                        detail how to use the instruction, and also describes 
                        many of its possible uses. <I>LOADALL </I>can be used to 
                        access extended memory while in real mode, and to 
                        emulate real mode while in protected mode. Programs such 
                        as RAMDRIVE, ABOVEDISC, and OS/2 use <I>LOADALL. </I>DOS 
                        3.3 has provisions for using <I>LOADALL </I>by leaving a 
                        102-byte 'hole' at 80:0. If you are a systems programmer 
                        and have a need to know this information, Intel will 
                        provide it, along with source code to emulate 286 
                        <I>LOADALL </I>on the 386 (without using 386 
                        <I>LOADALL).</I></P>
                        <P>Unlike the 286 <I>LOADALL, </I>the 386 <I>LOADALL 
                        </I>is still an Intel top secret. l do not know of any 
                        document that describes its use, format, or acknowledges 
                        its existence. Very few people at Intel wil1 acknowledge 
                        that <I>LOADALL </I>even exists in the 80386 mask. The 
                        official Intel line is that, due to U.S. Military 
                        pressure, <I>LOADALL </I>was removed from the 80386 mask 
                        over a year ago. However, running the program in 
                        Listing-2 demonstrates that <I>LOADALL </I>is alive, 
                        well, and still available on the latest stepping of the 
                        80386.</P>
                        <HR>

                        <P align=left>View source code for 286 LOADALL:<BR><A 
                        href="http://x86.ddj.com/ftp/source/286load/286load.asm">ftp://ftp.x86.org/source/286load/286load.asm<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/286load/loadfns.286">ftp://ftp.x86.org/source/286load/loadfns.286<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/286load/macros.286">ftp://ftp.x86.org/source/286load/macros.286<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/include/cpu_type.asm">http://x86.ddj.com/ftp/source/include/cpu_type.asm</A></P>
                        <P align=left>View source code for 386 LOADALL:<BR><A 
                        href="http://x86.ddj.com/ftp/source/386load/386load.asm">ftp://ftp.x86.org/source/386load/386load.asm<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/386load/loadfns.386">ftp://ftp.x86.org/source/386load/loadfns.386<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/386load/macros.386">ftp://ftp.x86.org/source/386load/macros.386<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/include/cpu_type.asm">http://x86.ddj.com/ftp/source/include/cpu_type.asm</A></P>
                        <P align=left>View source code for EMULOAD (286 LOADALL 
                        emulation using 386 LOADALL):<BR><A 
                        href="http://x86.ddj.com/ftp/source/emuload/emuload.asm">ftp://ftp.x86.org/source/emuload/emuload.asm<BR></A><A 
                        href="http://x86.ddj.com/ftp/source/include/cpu_type.asm">http://x86.ddj.com/ftp/source/include/cpu_type.asm</A></P>
                        <P align=left>Download entire source code archive for 
                        286LOAD, 386LOAD, and EMULOAD:<BR><A 
                        href="http://x86.ddj.com/ftp/dloads/loadall.zip">http://x86.ddj.com/ftp/dloads/loadall.zip</A></P></TD><!-- End column 1 in Master Table --><!-- Begin Column 2 in Master Table -->
                      <TD vAlign=top width="40%"><!-- Begin Sidebar 1 -->
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=15 border=1>
                          <TBODY>
                          <TR>
                            <TD vAlign=top>
                              <H2 align=center><A name=SB1></A>DESCRIPTOR CACHE 
                              REGISTERS</H2>
                              <P>Whether in real or protected mode, the CPU 
                              stores the base address of each segment in hidden 
                              registers called descriptor cache registers. Each 
                              time the CPU loads a segment register, the segment 
                              base address, segment size limit, and access 
                              attributes (access rights) are loaded, or 
                              "cached," ) into these hidden registers. To 
                              enhance performance, the CPU makes all subsequent 
                              memory references via the descriptor cache 
                              registers instead of calculating the physical 
                              address, or looking up the base address in the 
                              descriptor table. Understanding the role of these 
                              hidden registers is paramount for exploiting 
                              highly advanced programming techniques, and for 
                              exploiting the undocumented LOADALL instruction.<A 
                              href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#fig2a">Figure 
                              2(a</A>) shows the descriptor cache layout for the 
                              80286, and <A 
                              href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#fig2b">Figure 
                              2(b</A>) shows the layout for the 80386, and 
                              80486.</P>
                              <DIV align=center>
                              <CENTER>
                              <TABLE cellSpacing=0 cellPadding=2 border=1>
                                <CAPTION align=top><A 
                                name=Fig2a></A><STRONG>Figure 2 (a) 80286 
                                Descriptor Cache Register</STRONG></CAPTION>
                                <TBODY>
                                <TR>
                                <TD vAlign=bottom align=middle colSpan=16><FONT 
                                size=2><STRONG>[47..32]</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>31</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle colSpan=2><FONT 
                                size=2><STRONG>[30..29]</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>28</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle colSpan=3><FONT 
                                size=2><STRONG>[27..25]</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>24</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle colSpan=24><FONT 
                                size=2><STRONG>[23..00]</STRONG></FONT></TD></TR>
                                <TR>
                                <TD align=middle colSpan=16>16-bit Limit</TD>
                                <TD align=middle>P</TD>
                                <TD align=middle colSpan=2>DPL</TD>
                                <TD align=middle>S</TD>
                                <TD align=middle colSpan=3>Type</TD>
                                <TD align=middle>A</TD>
                                <TD align=middle colSpan=24>24-bit base 
                                address</TD></TR></TBODY></TABLE></CENTER></DIV>
                              <P><BR></P>
                              <DIV align=center>
                              <CENTER>
                              <TABLE cellSpacing=0 cellPadding=20 border=0>
                                <TBODY>
                                <TR>
                                <TD>
                                <DIV align=center>
                                <CENTER>
                                <TABLE cellSpacing=0 cellPadding=2 width="100%" 
                                border=1>
                                <CAPTION align=top><A 
                                name=Fig2b></A><STRONG>Figure 2 (b) 80386/80486 
                                Descriptor Cache Register</STRONG></CAPTION>
                                <TBODY>
                                <TR>
                                <TD vAlign=bottom align=middle colSpan=8><FONT 
                                size=2><STRONG>[31..24]</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>23</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle colSpan=2><FONT 
                                size=2><STRONG>[22..21]</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>20</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle colSpan=3><FONT 
                                size=2><STRONG>[19..17]</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>16</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>15</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>14</STRONG></FONT></TD>
                                <TD vAlign=bottom align=middle colSpan=14><FONT 
                                size=2><STRONG>[13..00]</STRONG></FONT></TD></TR>
                                <TR>
                                <TD align=middle colSpan=8>0</TD>
                                <TD align=middle>P</TD>
                                <TD align=middle colSpan=2>DPL</TD>
                                <TD align=middle>S</TD>
                                <TD align=middle colSpan=3>Type</TD>
                                <TD align=middle>A</TD>
                                <TD align=middle>0</TD>
                                <TD align=middle>D</TD>
                                <TD align=middle 
                                colSpan=14>0</TD></TR></TBODY></TABLE></CENTER></DIV></TD></TR>
                                <TR>
                                <TD>
                                <DIV align=center>
                                <CENTER>
                                <TABLE cellSpacing=0 cellPadding=2 width="100%" 
                                border=1>
                                <TBODY>
                                <TR>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>[63..32]</STRONG></FONT></TD></TR>
                                <TR>
                                <TD align=middle>32-bit Physical 
                                Address</TD></TR></TBODY></TABLE></CENTER></DIV></TD></TR>
                                <TR>
                                <TD>
                                <DIV align=center>
                                <CENTER>
                                <TABLE cellSpacing=0 cellPadding=2 width="100%" 
                                border=1>
                                <TBODY>
                                <TR>
                                <TD vAlign=bottom align=middle><FONT 
                                size=2><STRONG>[95..64]</STRONG></FONT></TD></TR>
                                <TR>
                                <TD align=middle>32-bit 
                                Limit</TD></TR></TBODY></TABLE></CENTER></DIV></TD></TR></TBODY></TABLE></CENTER></DIV>
                              <P>At power-up, the descriptor cache registers are 
                              loaded with fixed, default values, the CPU is in 
                              real mode, and all segments are marked as 
                              read/write data segments, including the code 
                              segment (CS). According to Intel, each time the 
                              CPU loads a segment register in real mode, the 
                              base address is 16 times the segment value, while 
                              the access rights and size limit attributes are 
                              given fixed, "real-mode compatible" values. This 
                              is not true. In fact, only the CS descriptor cache 
                              access rights get loaded with fixed values each 
                              time the segment register is 1oaded - and even 
                              then only when a far jump is encountered. Loading 
                              any other segment register in real mode does not 
                              change the access rights or the segment size limit 
                              attributes stored in the descriptor cache 
                              registers. For these segments, the access rights 
                              and segment size limit attributes are honored from 
                              any previous setting (see <A 
                              href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#fig3">Figure 
                              3</A>). Thus it is possible to have a four 
                              giga-byte, read-only data segment in real mode on 
                              the 80386, but Intel will not acknowledge, or 
                              support this mode of operation.</P>
                              <P>Protected mode differs from real mode in this 
                              respect each time the CPU loads a segment 
                              register, it fully loads the descriptor cache 
                              register, no previous values are honored. The CPU 
                              loads the descriptor cache directly from the 
                              descriptor table. The CPU checks the validity of 
                              the segment by testing the access rights in the 
                              descriptor table, and illegal va1ues will generate 
                              exceptions. Any attempt to load CS with a 
                              read/write data segment will generate a protection 
                              error. Likewise, any attempt to 1oad a data 
                              segment register as an executable segment will 
                              also generate an exception. The CPU enforces these 
                              protection rules very strictly if the descriptor 
                              table entry passes all the tests, then the CPU 
                              loads the descriptor cache register. </P>
                              <P align=center><A name=Fig3></A><STRONG>Figure 3 
                              -- Descriptor Cache Contents (Real 
                              Mode)</STRONG></P>
                              <P align=center><IMG height=408 
                              src="The LOADALL Instruction-Dateien/fig3.gif" 
                              width=380></P></TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End Sidebar 1 --></P>
                        <HR>

                        <P><!-- Begin "Table 2(a)" --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=2 width="100%" 
border=1>
                          <CAPTION align=top><A name=Tbl2a></A><STRONG>Table 2 
                          (a) -- 80286 Descriptor Cache Entry Formats 
                          </STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TD align=middle><FONT size=4><B>Offset</B></FONT> 
                            </TD>
                            <TD><FONT size=4><B>Description</B></FONT></TD></TR>
                          <TR>
                            <TD align=middle>0-2</TD>
                            <TD>24-bit physical address of the segment in 
                              memory. These bytes are stored in standard Intel 
                              format with the least significant byte at the 
                              lowest memory address.</TD></TR>
                          <TR>
                            <TD align=middle>3</TD>
                            <TD>Access rights. The format of this byte is the 
                              same as that in the descriptor table. This access 
                              byte is loaded in the descriptor cache register 
                              regardless of its validity. Therefore the 
                              "present" bit in the access rights field becomes a 
                              "descriptor valid" bit. When this bit is cleared, 
                              the descriptor is considered invalid, and any 
                              memory reference using this descriptor generates 
                              exception 13, with error code 0. The Descriptor 
                              Privilege Level (DPL) of the SS and CS descriptor 
                              caches determines the Current Privilege Level 
                              (CPL). The CS descriptor cache may be loaded as a 
                              read/write data segment.</TD></TR>
                          <TR>
                            <TD align=middle>4-5</TD>
                            <TD>Segment limit. The standard 16-bit segment 
                              limit stored in standard Intel 
                          format.</TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Table 2(a)" --><BR><BR><!-- Begin "Table 2(b)" --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=2 width="100%" 
border=1>
                          <CAPTION align=top><A name=Tbl2b></A><STRONG>Table 2 
                          (b) -- 80286 GDT and IDT Descriptor Cache Entry 
                          Formats</STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TD align=middle><FONT 
                            size=4><B>Offset</B></FONT></TD>
                            <TD><FONT size=4><B>Description</B></FONT></TD></TR>
                          <TR>
                            <TD align=middle>0-2</TD>
                            <TD>24-bit physical address of the segment in 
                              memory.</TD></TR>
                          <TR>
                            <TD align=middle>3</TD>
                            <TD>Should be 0.</TD></TR>
                          <TR>
                            <TD align=middle>4-5</TD>
                            <TD>Segment 
                        limit.</TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Table 2(b)" --></P>
                        <HR>

                        <P><!-- Begin "Table 3" --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=8 border=0>
                          <CAPTION align=top><A name=Tbl3></A><STRONG>Table 3 -- 
                          80386 
                          </STRONG><STRONG><B><I>LOADALL</I></B></STRONG><STRONG> 
                          Table </STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TH vAlign=bottom>Offset</TH>
                            <TH vAlign=bottom>Description</TH>
                            <TH vAlign=bottom>Data Size</TH>
                            <TH vAlign=bottom>Data Value</TH></TR>
                          <TR>
                            <TD vAlign=top>
                              <P align=center>[00] 
                              <BR>[04]<BR>[08]<BR>[0C]<BR>[10]<BR>[14]<BR>[18]<BR>[1C]<BR>[20]<BR>[24]<BR>[28]<BR>[2C]<BR>[30]<BR>[34]<BR>[38]<BR>[3C]<BR>[40]<BR>[44]<BR>[48]<BR>[4C]<BR>[50]<BR>[54]<BR>[60]<BR>[6C]<BR>[78]<BR>[84]<BR>[90]<BR>[9C]<BR>[A8]<BR>[B4]<BR>[C0]<BR>[CC] 
                              </P></TD>
                            <TD 
                              vAlign=top>CR0<BR>EFLAGS<BR>EIP<BR>EDI<BR>ESI<BR>EBP<BR>ESP<BR>EBX<BR>EDX<BR>ECX<BR>EAX<BR>DR6<BR>DR7<BR>TR_REG<BR>LDT_REG<BR>GS_REG<BR>FS_REG<BR>DS_REG<BR>SS_REG<BR>CS_REG<BR>ES_REG<BR>TSS_DESC<BR>IDT_DESC<BR>GDT_DESC<BR>LDT_DESC<BR>GS_DESC<BR>FS_DESC<BR>DS_DESC<BR>SS_DESC<BR>CS_DESC<BR>ES_DESC<BR>LENGTH&nbsp;OF&nbsp;TABLE</TD>
                            <TD vAlign=top 
                              align=middle>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>DD<BR>REG_STRUC<BR>REG_STRUC<BR>REG_STRUC<BR>REG_STRUC<BR>REG_STRUC<BR>REG_STRUC<BR>REG_STRUC<BR>REG_STRUC<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR>DESC_CACHE<BR></TD>
                            <TD vAlign=top 
                              align=middle>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>?<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR>&lt;?,?,?&gt;<BR></TD></TR>
                          <TR>
                            <TD vAlign=top colSpan=2><PRE><FONT size=4>REG_STRUC STRUC
    REG_VAL    DW     ?
               DW     0
ENDS</FONT></PRE></TD>
                            <TD colSpan=2><PRE><FONT size=4>DESC_CACHE STRUC
              DB     0
     _Type    DB     ?
              DB     0
              DB     0
     _Addr    DD     ?
    _Limit    DD     ?
ENDS</FONT></PRE></TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Table 3" --></P>
                        <HR>

                        <P><!-- Begin "Table 4(a)" --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=3 width="100%" 
border=1>
                          <CAPTION align=top><A name=Tbl4></A><STRONG>Table 4 
                          (a) -- 80386 Descriptor Cache Entries 
                          </STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TD align=middle><FONT size=4><B>Offset</B></FONT> 
                            </TD>
                            <TD><FONT size=4><B>Description</B></FONT></TD></TR>
                          <TR>
                            <TD align=middle>0-3 </TD>
                            <TD>Access rights. The access rights dword 
                              consumes 11 bits of this 32-bit field. See <A 
                              href="http://x86.ddj.com/articles/loadall/tspec_a3_doc.htm#fig2b" 
                              name=F2Ptr>figure 2</A> for a complete description 
                              of this field.</TD></TR>
                          <TR>
                            <TD align=middle>4-7 </TD>
                            <TD>32-bit base address of the segment in 
                            memory..</TD></TR>
                          <TR>
                            <TD align=middle>8-11 </TD>
                            <TD>32-bit base address of the segment in 
                            memory.</TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Table 4(a)" --><BR><BR><!-- Begin "Table 4(b)" --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=3 width="100%" 
border=1>
                          <CAPTION align=top><STRONG>Table 4 (b) -- 80386 GDT 
                          and IDT Descriptor Cache Entry Formats 
                          </STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TD align=middle><FONT size=4><B>Offset</B></FONT> 
                            </TD>
                            <TD><FONT size=4><B>Description</B></FONT></TD></TR>
                          <TR>
                            <TD align=middle>0-3 </TD>
                            <TD>Should be 0.</TD></TR>
                          <TR>
                            <TD align=middle>4-7 </TD>
                            <TD>32-bit base address of GDTR or IDTR.</TD></TR>
                          <TR>
                            <TD align=middle>8-11 </TD>
                            <TD>32-bit limit of GDTR or 
                        IDTR.</TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Table 4(b)" --></P>
                        <HR>

                        <P><!-- Begin "Figure 1" --></P>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=3 border=0>
                          <CAPTION align=top><STRONG>Figure 1 -- 
                          In-Circuit-Emulator Trace of 80386 
                          </STRONG><EM><STRONG>LOADALL</STRONG></EM><STRONG> 
                          Instruction</STRONG></CAPTION>
                          <TBODY>
                          <TR>
                            <TD vAlign=top><FONT 
                              size=2><STRONG>Frame</STRONG></FONT></TD>
                            <TD vAlign=top colSpan=3><FONT size=2>The FRAME 
                              number is like a clock count for the CPU. At every 
                              CPU clock, the ICE takes a picture. When a valid 
                              cycle occurs, the ICE records its occurance. 
                              Therefore, it is possible to determine how many 
                              CPU clocks a sequence of instructions takes to 
                              execute by reading this information.</FONT></TD></TR>
                          <TR>
                            <TD vAlign=top><FONT 
                              size=2><STRONG>Type</STRONG></FONT></TD>
                            <TD vAlign=top colSpan=3><FONT size=2>Cycle type. 
                              Shown here are F=Fetch, R=Read, and 
                              X=eXecute.</FONT></TD></TR>
                          <TR>
                            <TD vAlign=top><FONT 
                              size=2><STRONG>Address</STRONG></FONT></TD>
                            <TD vAlign=top colSpan=3><FONT size=2>The 32-bit 
                              physical address asserted on the CPU address bus 
                              during each cycle.</FONT></TD></TR>
                          <TR>
                            <TD vAlign=top><FONT 
                              size=2><STRONG>Data</STRONG></FONT></TD>
                            <TD colSpan=3><FONT size=2>The data asserted on 
                              the CPU data bus during each cycle.</FONT></TD></TR>
                          <TR>
                            <TD><FONT 
                              size=2><STRONG>BE3#<BR>BE2#<BR>BE1#<BR>BE0#</STRONG></FONT></TD>
                            <TD colSpan=3><FONT size=2>Byte enable pins on the 
                              CPU. These pins determine which bytes of the 
                              32-bits of data are valid. These pins are active 
                              low, so 8-bits of data are valid for each 
                              '0.'</FONT></TD></TR>
                          <TR>
                            <TD><FONT size=2><STRONG>W/R#</STRONG></FONT></TD>
                            <TD><FONT size=2>Write/Read.</FONT></TD>
                            <TD><FONT size=2>Write = 1</FONT></TD>
                            <TD><FONT size=2>Read = 0</FONT></TD></TR>
                          <TR>
                            <TD><FONT size=2><STRONG>D/C#</STRONG></FONT></TD>
                            <TD><FONT size=2>Data/Code.</FONT></TD>
                            <TD><FONT size=2>Data = 1</FONT></TD>
                            <TD><FONT size=2>Code = 0</FONT></TD></TR>
                          <TR>
                            <TD><FONT size=2><STRONG>M/IO#</STRONG></FONT></TD>
                            <TD><FONT size=2>Memory/IO</FONT></TD>
                            <TD><FONT size=2>Memory = 1</FONT></TD>
                            <TD><FONT size=2>IO = 
                        0</FONT></TD></TR></TBODY></TABLE></CENTER></DIV>
                        <DIV align=center>
                        <CENTER>
                        <TABLE cellSpacing=0 cellPadding=5 border=0>
                          <TBODY>
                          <TR>
                            <TD vAlign=bottom align=middle><PRE><FONT size=2><TT>Frame
Dec</TT></FONT><FONT face="Courier New"> </FONT></PRE></TD>
                            <TD vAlign=bottom align=middle><PRE><FONT face="Courier New" size=2>Type</FONT><FONT face="Courier New"> </FONT></PRE></TD>
                            <TD vAlign=bottom align=middle><PRE><FONT face="Courier New" size=2>Address 
(Hex)</FONT><FONT face="Courier New"> </FONT></PRE></TD>
                            <TD vAlign=bottom align=middle><PRE><FONT face="Courier New" size=2>Data
(Hex)</FONT><FONT face="Courier New"> </FONT></PRE></TD>
                            <TD vAlign=bottom align=middle><PRE><FONT face="Courier New" size=2>BBBB
EEEE
3210
####</FONT><FONT face="Courier New"> </FONT></PRE></TD>
                            <TD vAlign=bottom align=middle><PRE><FONT size=2>WDM
///
RCI
  O
###</FONT></PRE></TD>
                            <TD vAlign=bottom><PRE><FONT size=2>Comments</FONT></PRE></TD></TR>
                          <TR>
                            <TD vAlign=top align=middle><PRE><FONT size=2><TT>5
8
011
013
015
017
019
021
023
025
027
029
031
033
035
037
039
041
043
045
047
049
051
053
055
057
059
061
063
065
067
069
071
073
075
077
079
081
083
085
087
089
091
093
095
097
099
101
103
105
107
109
111
113
115
117
119
121
123
125
127
129
131</TT></FONT></PRE></TD>
                            <TD vAlign=top align=middle><PRE><FONT size=2>F
X
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R
R</FONT></PRE></TD>
                            <TD vAlign=top align=middle><PRE><FONT size=2>0000DE40
executed
0000D8F0
0000D8F4
0000D8F8
0000D8FC
0000D900
0000D904
0000D908
0000D90C
0000D910
0000D914
0000D7F0
0000D7F4
0000D7F8
0000D7FC
0000D800
0000D804
0000D808
0000D80C
0000D810
0000D814
0000D818
0000D81C
0000D820
0000D824
0000D828
0000D82C
0000D830
0000D834
0000D838
0000D83C
0000D840
0000D844
0000D848
0000D84C
0000D850
0000D854
0000D858
0000D85C
0000D860
0000D864
0000D868
0000D86C
0000D870
0000D874
0000D878
0000D87C
0000D880
0000D884
0000D888
0000D88C
0000D890
0000D894
0000D898
0000D89C
0000D8A0
0000D8A4
0000D8A8
0000D8AC
0000D8B0
0000D8B4
0000D8B8</FONT></PRE></TD>
                            <TD vAlign=top align=middle><PRE><FONT size=2>B490070F
2 bytes
01010101
02020202
03030303
04040404
05050505
06060606
07070707
08080808
09090909
0A0A0A0A
7FFFFFE0
00000002
00000133
66666666
77777777
55555555
88888888
22222222
44444444
33333333
11111111
FFFF0FF0
0000D402
xxxx0000
xxxx0000
xxxx5555
xxxx4444
xxxx2222
xxxx6666
xxxx1111
xxxx3333
00008900
00070000
00000800
00000000
00000000
000003FF
00000000
00000000
00000000
00008200
00090000
00000088
00008300
00050000
0000FFFF
00009300
00040000
0000FFFF
00009300
00020000
0000FFFF
00009300
00060000
0000FFFF
00009B00
0000DD30
0000FFFF
00009300
00030000
00FFFFFF</FONT></PRE></TD>
                            <TD vAlign=top align=middle><PRE><FONT size=2>0000
at
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
1100
1100
1100
1100
1100
1100
1100
1100
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000
0000</FONT></PRE></TD>
                            <TD vAlign=top align=middle><PRE><FONT size=2>001
DE40L
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011
011</FONT></PRE></TD>
                            <TD vAlign=top><PRE><FONT size=2>LOADALL fetched
LOADALL begins execution
\</FONT><FONT face="Courier New" size=2>
 \
  \   The10"mystery"
   \  reads,exactly
    \ 100h bytes beyond
    / the beginning of
   /  the LOADALL table.
  /
 /
/
CR0
EFLAGS
EIP
EDI
ESI
EBP
ESP
EBX
EDX
ECX
EAX
DR6
DR7
TR Register
LDT Register
GS Register
FS Register
DS Register
SS Register
CS Register
ES Register
TSS DescriptorCache


IDT DescriptorCache


GDT DescriptorCache


LDT DescriptorCache


GS DescriptorCache


FS DescriptorCache


DS DescriptorCache


SS DescriptorCache


CS DescriptorCache


ES DescriptorCache

</FONT></PRE></TD></TR></TBODY></TABLE></CENTER></DIV>
                        <P><!-- End "Figure 1" --></P></TD></TR></TBODY></TABLE></CENTER></DIV>
                  <HR>

                  <P align=left><A 
                  href="http://x86.ddj.com/articles/articles.htm#loadallptr">Back 
                  to Books and Articles home 
        page</A></P></TD></TR></TBODY></TABLE></TD></TR>
        <TR>
          <TD background="The LOADALL Instruction-Dateien/dash_wide.gif"><!-- rule --><IMG 
            height=10 src="The LOADALL Instruction-Dateien/spacer.gif" width=1> 
          </TD></TR>
        <TR>
          <TD><!-- Bottom Advertisement -->
            <TABLE cellSpacing=0 cellPadding=1 width=490 bgColor=#cccccc 
            border=0>
              <TBODY>
              <TR>
                <TD vAlign=center align=middle><FONT face=Arial 
                  size=1>Advertisement</FONT> </TD></TR>
              <TR>
                <TD vAlign=center align=middle><!-- REMOTE AD CALL <%/remoteviewad?site=x86&pagepos=bottom|site=x86|pagepos=bottom%> --><A 
                  href="http://newads.cmpnet.com/event.ng/Type=click&amp;ProfileID=7167&amp;RunID=39872&amp;AdID=29899&amp;GroupID=320&amp;FamilyID=1&amp;TagValues=179.2949&amp;Redirect=http:java.sun.com/javaone/" 
                  target=_top><IMG height=60 alt="" 
                  src="The LOADALL Instruction-Dateien/ddj_javaone_468.gif" 
                  width=468 border=1></A> </TD></TR></TBODY></TABLE></TD></TR>
        <TR>
          <TD><!-- Copyright message --><FONT face="Arial, Helvetica" 
            size=-1>Copyright  2002 <I>Dr. Dobb's 
        Journal<BR></I></FONT></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></BODY></HTML>
