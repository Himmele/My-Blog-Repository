<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0071)http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf.3e.html -->
<HTML><HEAD><TITLE>./_Man_Solaris_2.6_html/html3e/elf.3e.html</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<META content="MSHTML 6.00.2600.0" name=GENERATOR></HEAD>
<BODY bgColor=#ffffff>
<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left><A 
      href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/index.html"><IMG 
      alt="up | " src="Examples-Dateien/_up.gif"></A> <A 
      href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/toc.html"><IMG 
      alt="Inhaltsverzeichniss | " src="Examples-Dateien/_index.gif"></A> 
    <TD align=right><A href="mailto:hpb@cs.rit.edu"><IMG alt=Kommentar 
      src="Examples-Dateien/_mail.gif"> </A></TD></TR></TBODY></TABLE>
<HR SIZE=4>
<!-- This file has been generated by unroff 1.0, 10/07/97 16:09:13. --><!-- Do not edit! --><!--  t --><!--  @(#)elf.3e 1.51 97/02/18 SMI; --><!--  Copyright 1989 AT&amp;T --><!--  All Rights Reserved --><!--  Copyright (c) 1997 Sun Microsystems, Inc. --><!--  All Rights Reserved. -->
<H2>elf - object file access library 
<HR>
</H2>
<H2>SYNOPSIS</H2>
<P><B>cc </B>[ <I>flag</I> ... ] <I>file</I> ...<TT> </TT><B>-lelf </B>[ 
<I>library</I> ... ] 
<P><B>#include &lt;libelf.h&gt; </B>
<H2>DESCRIPTION</H2>
<P>Functions in the ELF access library let a program manipulate ELF (Executable 
and Linking Format) object files, archive files, and archive members.<TT> 
</TT>The header provides type and function declarations for all library 
services.<TT> </TT>
<P>Programs communicate with many of the higher-level routines using an <I>ELF 
descriptor</I>.<TT> </TT>That is, when the program starts working with a file, 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_begin.3e.html">elf_begin.3e</A> 
creates an ELF descriptor through which the program manipulates the structures 
and information in the file.<TT> </TT>These ELF descriptors can be used both to 
read and to write files.<TT> </TT>After the program establishes an ELF 
descriptor for a file, it may then obtain <I>section descriptors </I>to 
manipulate the sections of the file (see <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getscn.3e.html">elf_getscn.3e</A> 
Sections hold the bulk of an object file's real information, such as text, data, 
the symbol table, and so on.<TT> </TT>A section descriptor ``belongs'' to a 
particular ELF descriptor, just as a section belongs to a file.<TT> 
</TT>Finally, <I>data descriptors </I>are available through section descriptors, 
allowing the program to manipulate the information associated with a 
section.<TT> </TT>A data descriptor ``belongs'' to a section descriptor.<TT> 
</TT>
<P>Descriptors provide private handles to a file and its pieces.<TT> </TT>In 
other words, a data descriptor is associated with one section descriptor, which 
is associated with one ELF descriptor, which is associated with one file.<TT> 
</TT>Although descriptors are private, they give access to data that may be 
shared.<TT> </TT>Consider programs that combine input files, using incoming data 
to create or update another file.<TT> </TT>Such a program might get data 
descriptors for an input and an output section.<TT> </TT>It then could update 
the output descriptor to reuse the input descriptor's data.<TT> </TT>That is, 
the descriptors are distinct, but they could share the associated data 
bytes.<TT> </TT>This sharing avoids the space overhead for duplicate buffers and 
the performance overhead for copying data unnecessarily.<TT> </TT>
<H3>File Classes</H3>ELF provides a framework in which to define a family of 
object files, supporting multiple processors and architectures.<TT> </TT>An 
important distinction among object files is the <I>class</I>, or capacity, of 
the file.<TT> </TT>The 32-bit class supports architectures in which a 32-bit 
object can represent addresses, file sizes, and so on, as in the following: <BR><!-- .ne 10 -->
<DL>
  <DT>
  <DD><PRE>
Name	Purpose

<B>Elf32_Addr</B>	Unsigned address
<B>Elf32_Half</B>	Unsigned medium integer
<B>Elf32_Off</B>	Unsigned file offset
<B>Elf32_Sword</B>	Signed large integer
<B>Elf32_Word</B>	Unsigned large integer
<B>unsigned char</B>	Unsigned small integer
</PRE></DD></DL>
<P>Other classes will be defined as necessary, to support larger (or smaller) 
machines.<TT> </TT>Some library services deal only with data objects for a 
specific class, while others are class-independent.<TT> </TT>To make this 
distinction clear, library function names reflect their status, as described 
below.<TT> </TT>
<H3>Data Representation</H3>Conceptually, two parallel sets of objects support 
cross compilation environments.<TT> </TT>One set corresponds to file contents, 
while the other set corresponds to the native memory image of the program 
manipulating the file.<TT> </TT>Type definitions supplied by the headers work on 
the native machine, which may have different data encodings (size, byte order, 
and so on) than the target machine.<TT> </TT>Although native memory objects 
should be at least as big as the file objects (to avoid information loss), they 
may be bigger if that is more natural for the host machine.<TT> </TT>
<P>Translation facilities exist to convert between file and memory 
representations.<TT> </TT>Some library routines convert data automatically, 
while others leave conversion as the program's responsibility.<TT> </TT>Either 
way, programs that create object files must write file-typed objects to those 
files; programs that read object files must take a similar view.<TT> </TT>See <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_xlatetof.3e.html">elf32_xlatetof.3e</A> 
and <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_fsize.3e.html">elf32_fsize.3e</A> 
for more information.<TT> </TT>
<P>Programs may translate data explicitly, taking full control over the object 
file layout and semantics.<TT> </TT>If the program prefers not to have and 
exercise complete control, the library provides a higher-level interface that 
hides many object file details.<TT> </TT><B>elf_begin() </B>and related 
functions let a program deal with the native memory types, converting between 
memory objects and their file equivalents automatically when reading or writing 
an object file.<TT> </TT>
<H3>ELF Versions</H3>Object file versions allow ELF to adapt to new 
requirements.<TT> </TT><I>Three </I><I>independent </I><I>versions </I>can be 
important to a program.<TT> </TT>First, an application program knows about a 
particular version by virtue of being compiled with certain headers.<TT> 
</TT>Second, the access library similarly is compiled with header files that 
control what versions it understands.<TT> </TT>Third, an ELF object file holds a 
value identifying its version, determined by the ELF version known by the file's 
creator.<TT> </TT>Ideally, all three versions would be the same, but they may 
differ.<TT> </TT>
<DL>
  <DT>
  <DD>If a program's version is newer than the access library, the program might 
  use information unknown to the library.<TT> </TT>Translation routines might 
  not work properly, leading to undefined behavior.<TT> </TT>This condition 
  merits installing a new library.<TT> </TT>
  <DT>
  <DD>The library's version might be newer than the program's and the 
  file's.<TT> </TT>The library understands old versions, thus avoiding 
  compatibility problems in this case.<TT> </TT>
  <DT>
  <DD>Finally, a file's version might be newer than either the program or the 
  library understands.<TT> </TT>The program might or might not be able to 
  process the file properly, depending on whether the file has extra information 
  and whether that information can be safely ignored.<TT> </TT>Again, the safe 
  alternative is to install a new library that understands the file's 
  version.<TT> </TT></DD></DL>
<P>To accommodate these differences, a program must use <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_version.3e.html">elf_version.3e</A> 
to pass its version to the library, thus establishing the <I>working version 
</I>for the process.<TT> </TT>Using this, the library accepts data from and 
presents data to the program in the proper representations.<TT> </TT>When the 
library reads object files, it uses each file's version to interpret the 
data.<TT> </TT>When writing files or converting memory types to the file 
equivalents, the library uses the program's working version for the file 
data.<TT> </TT>
<H3>System Services</H3>As mentioned above, <B>elf_begin() </B>and related 
routines provide a higher-level interface to ELF files, performing input and 
output on behalf of the application program.<TT> </TT>These routines assume a 
program can hold entire files in memory, without explicitly using temporary 
files.<TT> </TT>When reading a file, the library routines bring the data into 
memory and perform subsequent operations on the memory copy.<TT> </TT>Programs 
that wish to read or write large object files with this model must execute on a 
machine with a large process virtual address space.<TT> </TT>If the underlying 
operating system limits the number of open files, a program can use <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_cntl.3e.html">elf_cntl.3e</A> 
to retrieve all necessary data from the file, allowing the program to close the 
file descriptor and reuse it.<TT> </TT>
<P>Although the <B>elf_begin() </B>interfaces are convenient and efficient for 
many programs, they might be inappropriate for some.<TT> </TT>In those cases, an 
application may invoke the <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_xlatetom.3e.html">elf32_xlatetom.3e</A> 
or <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_xlatetof.3e.html">elf32_xlatetof.3e</A> 
data translation routines directly.<TT> </TT>These routines perform no input or 
output, leaving that as the application's responsibility.<TT> </TT>By assuming a 
larger share of the job, an application controls its input and output model.<TT> 
</TT>
<H3>Library Names</H3>
<P>Names associated with the library take several forms.<TT> </TT>
<DL>
  <DT><B>elf_</B><I>name </I>
  <DD>These class-independent names perform some service, <I>name</I>, for the 
  program.<TT> </TT>
  <DT><B>elf32_</B><I>name </I>
  <DD>Service names with an embedded class, <B>32 </B>here, indicate they work 
  only for the designated class of files.<TT> </TT>
  <DT><B>Elf_</B><I>Type</I> 
  <DD>Data types can be class-independent as well, distinguished by 
  <I>Type</I>.<TT> </TT>
  <DT><B>Elf32_</B><I>Type</I> 
  <DD>Class-dependent data types have an embedded class name, <B>32</B> 
  here.<TT> </TT>
  <DT><B>ELF_C_</B><I>CMD</I> 
  <DD>Several functions take commands that control their actions.<TT> </TT>These 
  values are members of the <B>Elf_Cmd</B> enumeration; they range from zero 
  through <B>ELF_C_NUM</B>-1<B>. </B>
  <DT><B>ELF_F_</B><I>FLAG</I> 
  <DD>Several functions take flags that control library status and/or 
  actions.<TT> </TT>Flags are bits that may be combined.<TT> </TT>
  <DT><B>ELF32_FSZ_</B><I>TYPE</I> 
  <DD>These constants give the file sizes in bytes of the basic ELF types for 
  the 32-bit class of files.<TT> </TT>See <B>elf32_fsize() </B>for more 
  information.<TT> </TT>
  <DT><B>ELF_K_</B><I>KIND</I> 
  <DD>The function <B>elf_kind() </B>identifies the <I>KIND </I>of file 
  associated with an ELF descriptor.<TT> </TT>These values are members of the 
  <B>Elf_Kind</B> enumeration; they range from zero through 
  <B>ELF_K_NUM</B>-1<B>. </B><BR>
  <DT><B>ELF_T_</B><I>TYPE</I> 
  <DD>When a service function, such as <B>elf32_xlatetom() </B>or 
  <B>elf32_xlatetof()</B>, deals with multiple types, names of this form specify 
  the desired <I>TYPE</I>.<TT> </TT>Thus, for example, <B>ELF_T_EHDR </B>is 
  directly related to <B>Elf32_Ehdr</B>.<TT> </TT>These values are members of 
  the <B>Elf_Type</B> enumeration; they range from zero through 
  <B>ELF_T_NUM</B>-1<B>. </B></DD></DL>
<H2>EXAMPLES</H2>The basic interpretation of an ELF file consists of: 
<DL>
  <DT>
  <DD>• opening an ELF object file 
  <P>• obtaining an ELF descriptor 
  <P>• analyzing the file using the descriptor.<TT> </TT>
  <P></P></DD></DL>The following example opens the file, obtains the ELF 
descriptor, and prints out the names of each section in the file.<TT> </TT>
<P><B></B><PRE><B>#include	&lt;fcntl.h&gt;
#include	&lt;stdio.h&gt;
#include	&lt;libelf.h&gt;
#include	&lt;stdlib.h&gt;
#include	&lt;string.h&gt;
static void failure(void);

void
main(int argc, char ** argv)
{
	Elf32_Shdr *	shdr;
	Elf32_Ehdr *	ehdr;
	Elf *		elf;
	Elf_Scn *	scn;
	Elf_Data *	data;
	int		fd;
	unsigned int	cnt;

		</B><I>/* Open the input file */</I><B>
	if ((fd = open(argv[1], O_RDONLY)) == -1)
		exit(1);

		</B><I>/* Obtain the ELF descriptor */</I><B>
	(void) elf_version(EV_CURRENT);
	if ((elf = elf_begin(fd, ELF_C_READ, NULL)) == NULL)
		failure();

		</B><I>/* Obtain the .shstrtab data buffer */</I><B>
	if (((ehdr = elf32_getehdr(elf)) == NULL) ||
	    ((scn = elf_getscn(elf, ehdr-&gt;e_shstrndx)) == NULL) ||
	    ((data = elf_getdata(scn, NULL)) == NULL))
		failure();

		</B><I>/* Traverse input filename, printing each section */</I><B>
	for (cnt = 1, scn = NULL; scn = elf_nextscn(elf, scn); cnt++) {
		if ((shdr = elf32_getshdr(scn)) == NULL)
			failure();

	(void) printf("[%d]t%s\n", cnt,
		(char *)data-&gt;d_buf + shdr-&gt;sh_name);
	}
}		</B><I>/* end main */</I><B>

static void
failure()
{
	(void) fprintf(stderr, "%s\n", elf_errmsg(elf_errno()));
	exit(1);
}


</B></PRE>Below is sample output from compiling and executing the above code, 
which prints the names of the sections using itself as the input file <PRE><B>
	% cc -o elfprint example.c -lelf 
	% elfprint elfprint
	 [1]	.interp
	 [2]	.hash
	 [3]	.dynsym
	 [4]	.dynstr
	 [5]	.rela.ex_shared
	 [6]	.rela.bss
	 [7]	.rela.plt
	 [8]	.text
	 [9]	.init
	 [10]	.fini
	 [11]	.exception_ranges
	 ...
</B></PRE><B></B>
<H2>ATTRIBUTES</H2>See <A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html5/attributes.5.html">attributes.5</A> 
for descriptions of the following attributes: 
<P><PRE>+---------------+-----------------+
|ATTRIBUTE TYPE | ATTRIBUTE VALUE |
+---------------+-----------------+
|MT-Level       | MT-Safe         |
+---------------+-----------------+
</PRE>
<H2>SEE ALSO</H2><A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_fsize.3e.html">elf32_fsize.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_getshdr.3e.html">elf32_getshdr.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf32_xlatetof.3e.html">elf32_xlatetof.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_begin.3e.html">elf_begin.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_cntl.3e.html">elf_cntl.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_errmsg.3e.html">elf_errmsg.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_fill.3e.html">elf_fill.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getarhdr.3e.html">elf_getarhdr.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getarsym.3e.html">elf_getarsym.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getbase.3e.html">elf_getbase.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getdata.3e.html">elf_getdata.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getident.3e.html">elf_getident.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_getscn.3e.html">elf_getscn.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_hash.3e.html">elf_hash.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_kind.3e.html">elf_kind.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_memory.3e.html">elf_memory.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_rawfile.3e.html">elf_rawfile.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_strptr.3e.html">elf_strptr.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_update.3e.html">elf_update.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/elf_version.3e.html">elf_version.3e</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html4/ar.4.html">ar.4</A> 
<A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html5/attributes.5.html">attributes.5</A> 

<P><!-- The ``Object Files'' in the chapter --><I>ANSI C Programmer's Guide </I>
<H3>SPARC only</H3><A 
href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html4/a.out.4.html">a.out.4</A> 

<H2>NOTES</H2>Information in the ELF headers is separated into common parts and 
processor-specific parts.<TT> </TT>A program can make a processor's information 
available by including the appropriate header: 
<B>&lt;sys/elf_</B><I>NAME</I><B>.h&gt;</B> where <I>NAME </I>matches the 
processor name as used in the ELF file header.<TT> </TT>
<P>
<DL>
  <DT>
  <DD><PRE>Name	Processor

<B>M32</B>	AT&amp;T WE 32100
<B>SPARC</B>	SPARC
<B>386</B>	Intel 80386, 80486, Pentium
</PRE></DD></DL>
<P>Other processors will be added to the table as necessary.<TT> </TT>
<P>To illustrate, a program could use the following code to ``see'' the 
processor-specific information for the SPARC based system. 
<DL>
  <DT>
  <DD>
  <P><PRE><B>#include &lt;libelf.h&gt;
#include &lt;sys/elf_SPARC.h&gt;
</B></PRE></DD></DL>
<P>Without the <B>&lt;sys/elf_SPARC.h&gt;</B> definition, only the common ELF 
information would be visible.<TT> </TT>
<P>A program could use the following code to ``see'' the processor-specific 
information for the Intel 80386: 
<DL>
  <DT>
  <DD>
  <P><PRE><B>#include &lt;libelf.h&gt;
#include &lt;sys/elf_386.h&gt;
</B></PRE></DD></DL>
<P>Without the <B>&lt;sys/elf_386.h&gt;</B> definition, only the common ELF 
information would be visible.<TT> </TT>
<P>Although reading the objects is rather straightforward, writing/updating them 
can corrupt the shared offsets among sections.<TT> </TT>Upon creation, 
relationships are established among the sections that must be maintained even if 
the object's size is changed.<TT> </TT>
<P>
<HR SIZE=4>

<TABLE width="100%">
  <TBODY>
  <TR>
    <TD align=left><A 
      href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/index.html"><IMG 
      alt="index | " src="Examples-Dateien/_up.gif"></A> <A 
      href="http://www.cs.rit.edu/~hpb/Man/_Man_Solaris_2.6_html/html3e/toc.html"><IMG 
      alt="Inhaltsverzeichniss | " src="Examples-Dateien/_index.gif"></A> 
    <TD align=right><A href="mailto:hpb@cs.rit.edu"><IMG alt=Kommentar 
      src="Examples-Dateien/_mail.gif"> </A></TD></TR></TBODY></TABLE>
<P>Created by <EM>unroff &amp; hp-tools.</EM> © by Hans-Peter Bischof. All 
Rights Reserved (1997). 
<P>Last modified 07/October/97 </P></BODY></HTML>
